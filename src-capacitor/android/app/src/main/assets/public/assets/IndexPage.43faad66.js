var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { c as createComponent, f as useSpinnerProps, g as useSpinner, b as useSizeProps, u as useSize, a as hMergeSlot, h as hSlot, Q as QIcon } from "./use-spinner.1c2c3cde.js";
import { h, c as computed, g as getCurrentInstance, p as inject, D as emptyRenderFn, E as layoutKey, G as pageContainerKey, L as defineComponent, r as ref, a8 as shallowRef, w as watch, b as onMounted, o as onBeforeUnmount, _ as _export_sfc, a9 as watchEffect, M as resolveComponent, N as openBlock, O as createBlock, Q as withCtx, Y as createElementBlock, R as createVNode, V as createCommentVNode, S as createBaseVNode, Z as toDisplayString, X as createTextVNode } from "./index.008f6724.js";
import { a as useDarkProps, u as useDark } from "./use-dark.891f17df.js";
const svg = [
  h("g", {
    "stroke-width": "4",
    "stroke-linecap": "round"
  }, [
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(180)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: "1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(210)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: "0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(240)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".1;0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(270)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".15;.1;0;1;.85;.7;.65;.55;.45;.35;.25;.15",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(300)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".25;.15;.1;0;1;.85;.7;.65;.55;.45;.35;.25",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(330)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".35;.25;.15;.1;0;1;.85;.7;.65;.55;.45;.35",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(0)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".45;.35;.25;.15;.1;0;1;.85;.7;.65;.55;.45",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(30)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".55;.45;.35;.25;.15;.1;0;1;.85;.7;.65;.55",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(60)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".65;.55;.45;.35;.25;.15;.1;0;1;.85;.7;.65",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(90)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".7;.65;.55;.45;.35;.25;.15;.1;0;1;.85;.7",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(120)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: ".85;.7;.65;.55;.45;.35;.25;.15;.1;0;1;.85",
        repeatCount: "indefinite"
      })
    ]),
    h("line", {
      y1: "17",
      y2: "29",
      transform: "translate(32,32) rotate(150)"
    }, [
      h("animate", {
        attributeName: "stroke-opacity",
        dur: "750ms",
        values: "1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1",
        repeatCount: "indefinite"
      })
    ])
  ])
];
var QSpinnerIos = createComponent({
  name: "QSpinnerIos",
  props: useSpinnerProps,
  setup(props) {
    const { cSize, classes } = useSpinner(props);
    return () => h("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      stroke: "currentColor",
      fill: "currentColor",
      viewBox: "0 0 64 64"
    }, svg);
  }
});
const defaultSizes = {
  xs: 2,
  sm: 4,
  md: 6,
  lg: 10,
  xl: 14
};
function width(val, reverse, $q) {
  return {
    transform: reverse === true ? `translateX(${$q.lang.rtl === true ? "-" : ""}100%) scale3d(${-val},1,1)` : `scale3d(${val},1,1)`
  };
}
var QLinearProgress = createComponent({
  name: "QLinearProgress",
  props: {
    ...useDarkProps,
    ...useSizeProps,
    value: {
      type: Number,
      default: 0
    },
    buffer: Number,
    color: String,
    trackColor: String,
    reverse: Boolean,
    stripe: Boolean,
    indeterminate: Boolean,
    query: Boolean,
    rounded: Boolean,
    animationSpeed: {
      type: [String, Number],
      default: 2100
    },
    instantFeedback: Boolean
  },
  setup(props, { slots }) {
    const { proxy } = getCurrentInstance();
    const isDark = useDark(props, proxy.$q);
    const sizeStyle = useSize(props, defaultSizes);
    const motion = computed(() => props.indeterminate === true || props.query === true);
    const widthReverse = computed(() => props.reverse !== props.query);
    const style = computed(() => ({
      ...sizeStyle.value !== null ? sizeStyle.value : {},
      "--q-linear-progress-speed": `${props.animationSpeed}ms`
    }));
    const classes = computed(
      () => "q-linear-progress" + (props.color !== void 0 ? ` text-${props.color}` : "") + (props.reverse === true || props.query === true ? " q-linear-progress--reverse" : "") + (props.rounded === true ? " rounded-borders" : "")
    );
    const trackStyle = computed(() => width(props.buffer !== void 0 ? props.buffer : 1, widthReverse.value, proxy.$q));
    const transitionSuffix = computed(() => `with${props.instantFeedback === true ? "out" : ""}-transition`);
    const trackClass = computed(
      () => `q-linear-progress__track absolute-full q-linear-progress__track--${transitionSuffix.value} q-linear-progress__track--${isDark.value === true ? "dark" : "light"}` + (props.trackColor !== void 0 ? ` bg-${props.trackColor}` : "")
    );
    const modelStyle = computed(() => width(motion.value === true ? 1 : props.value, widthReverse.value, proxy.$q));
    const modelClass = computed(
      () => `q-linear-progress__model absolute-full q-linear-progress__model--${transitionSuffix.value} q-linear-progress__model--${motion.value === true ? "in" : ""}determinate`
    );
    const stripeStyle = computed(() => ({ width: `${props.value * 100}%` }));
    const stripeClass = computed(
      () => `q-linear-progress__stripe absolute-${props.reverse === true ? "right" : "left"} q-linear-progress__stripe--${transitionSuffix.value}`
    );
    return () => {
      const child = [
        h("div", {
          class: trackClass.value,
          style: trackStyle.value
        }),
        h("div", {
          class: modelClass.value,
          style: modelStyle.value
        })
      ];
      props.stripe === true && motion.value === false && child.push(
        h("div", {
          class: stripeClass.value,
          style: stripeStyle.value
        })
      );
      return h("div", {
        class: classes.value,
        style: style.value,
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 1,
        "aria-valuenow": props.indeterminate === true ? void 0 : props.value
      }, hMergeSlot(slots.default, child));
    };
  }
});
var QPage = createComponent({
  name: "QPage",
  props: {
    padding: Boolean,
    styleFn: Function
  },
  setup(props, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const $layout = inject(layoutKey, emptyRenderFn);
    if ($layout === emptyRenderFn) {
      console.error("QPage needs to be a deep child of QLayout");
      return emptyRenderFn;
    }
    const $pageContainer = inject(pageContainerKey, emptyRenderFn);
    if ($pageContainer === emptyRenderFn) {
      console.error("QPage needs to be child of QPageContainer");
      return emptyRenderFn;
    }
    const style = computed(() => {
      const offset = ($layout.header.space === true ? $layout.header.size : 0) + ($layout.footer.space === true ? $layout.footer.size : 0);
      if (typeof props.styleFn === "function") {
        const height = $layout.isContainer.value === true ? $layout.containerHeight.value : $q.screen.height;
        return props.styleFn(offset, height);
      }
      return {
        minHeight: $layout.isContainer.value === true ? $layout.containerHeight.value - offset + "px" : $q.screen.height === 0 ? offset !== 0 ? `calc(100vh - ${offset}px)` : "100vh" : $q.screen.height - offset + "px"
      };
    });
    const classes = computed(
      () => `q-page${props.padding === true ? " q-layout-padding" : ""}`
    );
    return () => h("main", {
      class: classes.value,
      style: style.value
    }, hSlot(slots.default));
  }
});
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function round(v) {
  return v + 0.5 | 0;
}
const lim = (v, l, h3) => Math.max(Math.min(v, h3), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
const hex = [..."0123456789ABCDEF"];
const h1 = (b) => hex[b & 15];
const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
const eq$1 = (b) => (b & 240) >> 4 === (b & 15);
const isShort = (v) => eq$1(v.r) && eq$1(v.g) && eq$1(v.b) && eq$1(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
const alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h3, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h3 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h3, s, v) {
  const f = (n, k = (n + h3 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h3, w, b) {
  const rgb = hsl2rgbn(h3, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h3, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h3 = hueValue(r, g, b, d, max);
    h3 = h3 * 60 + 0.5;
  }
  return [h3 | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h3, s, l) {
  return calln(hsl2rgbn, h3, s, l);
}
function hwb2rgb(h3, w, b) {
  return calln(hwb2rgbn, h3, w, b);
}
function hsv2rgb(h3, s, v) {
  return calln(hsv2rgbn, h3, s, v);
}
function hue(h3) {
  return (h3 % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h3 = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h3, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h3, p1, p2);
  } else {
    v = hsl2rgb(h3, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h3 = rgb2hsl(v);
  h3[0] = hue(h3[0] + deg);
  h3 = hsl2rgb(h3);
  v.r = h3[0];
  v.g = h3[1];
  v.b = h3[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h3 = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h3}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h3}, ${s}%, ${l}%)`;
}
const map$2 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
const names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys2 = Object.keys(names$1);
  const tkeys = Object.keys(map$2);
  let i, j, k, ok, nk;
  for (i = 0; i < keys2.length; i++) {
    ok = nk = keys2[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map$2[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
const to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate$1(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone$1(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone$1(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone$1(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate$1(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}
/*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
function noop() {
}
const uid = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray$2(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject$1(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys2;
  if (isArray$2(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject$1(loopable)) {
    keys2 = Object.keys(loopable);
    len = keys2.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys2[i]], keys2[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone(source) {
  if (isArray$2(source)) {
    return source.map(clone);
  }
  if (isObject$1(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys2 = Object.keys(source);
    const klen = keys2.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys2[k]] = clone(source[keys2[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject$1(tval) && isObject$1(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray$2(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject$1(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject$1(current)) {
      continue;
    }
    const keys2 = Object.keys(current);
    for (let k = 0, klen = keys2.length; k < klen; ++k) {
      merger(keys2[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject$1(tval) && isObject$1(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone(sval);
  }
}
const keyResolvers = {
  "": (v) => v,
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys2 = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys2.push(tmp);
      tmp = "";
    }
  }
  return keys2;
}
function _getKeyResolver(key) {
  const keys2 = _splitKey(key);
  return (obj) => {
    for (const k of keys2) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value) => typeof value !== "undefined";
const isFunction$1 = (value) => typeof value === "function";
const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
const _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
const arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
const requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
const _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(
        _lookupByKey(_parsed, axis, min).lo,
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
      ), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
      ), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
const atEdge = (t) => t === 0 || t === 1;
const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
const effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
const numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
const colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
const formatters = {
  values(value) {
    return isArray$2(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
const overrides = /* @__PURE__ */ Object.create(null);
const descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys2 = key.split(".");
  for (let i = 0, n = keys2.length; i < n; ++i) {
    const k = keys2[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root2, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root2, scope), values);
  }
  return merge(getScope$1(root2, ""), scope);
}
class Defaults {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject$1(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
}
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && !isArray$2(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray$2(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray$2(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width2) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width2 !== 0 ? Math.max(width2 / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width2, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width2 = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width2, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width2, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width2, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width2 = w ? w / 2 : size;
        ctx.rect(x - width2, y - size, 2 * width2, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray$2(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h: h3, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x, y + h3 - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h3 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h3);
  ctx.arc(x + w - radius.bottomRight, y + h3 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
const numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject$1(props);
  const keys2 = objProps ? Object.keys(props) : props;
  const read = isObject$1(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys2) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray$2(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction$1(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction$1(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value) => isObject$1(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction$1(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray$2(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue2, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue2(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject$1(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction$1(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray$2(target) && isObject$1(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys2 = target._keys;
  if (!keys2) {
    keys2 = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys2;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start;
    item = data[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
const getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
const positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width: width2, height } = chart;
  if (borderBox) {
    width2 -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width2 * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width2, height) {
  let maxWidth, maxHeight;
  if (width2 === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width2 = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width2 = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width: width2,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
const round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width: width2, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width2 -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width2 = Math.max(0, width2 - margins.width);
  height = Math.max(0, aspectRatio ? width2 / aspectRatio : height - margins.height);
  width2 = round1(Math.min(width2, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width2 && !height) {
    height = round1(width2 / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width2 = round1(Math.floor(height * aspectRatio));
  }
  return {
    width: width2,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
const supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
const getRightToLeftAdapter = function(rectX, width2) {
  return {
    x(x) {
      return rectX + rectX + width2 - x;
    },
    setWidth(w) {
      width2 = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
const getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width2) {
  return rtl ? getRightToLeftAdapter(rectX, width2) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({
        start: s % count,
        end: e % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache.includes(value)) {
      cache.push(value);
    }
    return cache.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}
/*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
class Animator {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = /* @__PURE__ */ new Animator();
const transparent = "transparent";
const interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
class Animation {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
}
class Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject$1(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject$1(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray$2(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
function awaitAll(animations, properties) {
  const running = [];
  const keys2 = Object.keys(properties);
  for (let i = 0; i < keys2.length; i++) {
    const anim = animations[keys2[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject$1(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys2 = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys2.push(metasets[i].index);
  }
  return keys2;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys2 = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys2.length; i < ilen; ++i) {
    datasetIndex = +keys2[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys2 = Object.keys(data);
  const adata = new Array(keys2.length);
  let i, ilen, key;
  for (i = 0, ilen = keys2.length; i < ilen; ++i) {
    key = keys2[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
class DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject$1(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray$2(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject$1(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements2[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active, mode);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray$2(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
}
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
class BubbleController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
}
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
class DoughnutController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject$1(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
class LineController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = 0; i < pointsCount; ++i) {
      const point = points[i];
      const properties = directUpdate ? point : {};
      if (i < start || i >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
}
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class PolarAreaController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
}
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
class PieController extends DoughnutController {
}
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class RadarController extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
}
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class ScatterController extends DatasetController {
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      if (!this.datasetElementType) {
        this.addElements();
      }
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    } else if (this.datasetElementType) {
      delete meta.dataset;
      this.datasetElementType = false;
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
}
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class DateAdapterBase {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
}
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements2.push({
            element,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
const STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject$1(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width2, height) {
  box.top = top;
  box.left = left;
  box.right = left + width2;
  box.bottom = top + height;
  box.width = width2;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width2 = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width2, height);
      }
      stack.start = y;
      stack.placed += width2;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width2 = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width2, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width2, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width2, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width2 - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width2,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class BasePlatform {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width2, height, aspectRatio) {
    width2 = Math.max(0, width2 || element.width);
    height = height || element.height;
    return {
      width: width2,
      height: Math.max(0, aspectRatio ? Math.floor(width2 / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
}
class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
}
const EXPANDO_KEY = "$chartjs";
const EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
const isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
const eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
const drpListeningCharts = /* @__PURE__ */ new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width2, height) => {
    const w = container.clientWidth;
    listener(width2, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width2 = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width2 === 0 && height === 0) {
      return;
    }
    resize(width2, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
class DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width2, height, aspectRatio) {
    return getMaximumSize(canvas, width2, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
}
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
class Element {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
}
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
const getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray$2(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width2 = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject$1(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject$1(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width2 + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width2 + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
class Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width2, height, nestedLabel;
    for (i = 0; i < length; i += increment) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width2 = height = 0;
      if (!isNullOrUndef(label) && !isArray$2(label)) {
        width2 = _measureText(ctx, cache.data, cache.gc, width2, label);
        height = lineHeight;
      } else if (isArray$2(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray$2(nestedLabel)) {
            width2 = _measureText(ctx, cache.data, cache.gc, width2, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width2);
      heights.push(height);
      widestLabelSize = Math.max(width2, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h3 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h3 * cos > w * sin ? w / cos : h3 / sin : h3 * sin < w * cos ? h3 / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject$1(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject$1(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject$1(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject$1(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray$2(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width2 = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width2 / 2;
            break;
          case "right":
            left -= width2;
            break;
        }
        backdrop = {
          left,
          top,
          width: width2 + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width: width2, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width2, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject$1(position)) {
      offset += padding.bottom;
      if (isArray$2(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
}
class TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
}
var registry = /* @__PURE__ */ new Registry();
class PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
}
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys2 = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys2.length; i++) {
    plugins2.push(registry.getPlugin(keys2[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins2) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys2 = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys2);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject$1(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
const keyCache = /* @__PURE__ */ new Map();
const keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys2 = keyCache.get(cacheKey);
  if (!keys2) {
    keys2 = generate();
    keyCache.set(cacheKey, keys2);
    keysCached.add(keys2);
  }
  return keys2;
}
const addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
class Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys2) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys2.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys2.forEach((key) => addIfFound(scopes, options, key));
      keys2.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys2.forEach((key) => addIfFound(scopes, defaults, key));
      keys2.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction$1(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject$1(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
}
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
const hasFunction = (value) => isObject$1(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction$1(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction$1(value) || hasFunction(value)) || indexable && isArray$2(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.0";
const KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys2 = Object.keys(obj);
  for (const key of keys2) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
class Chart {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width2 = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width2;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width: width2, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width2 / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width2, height) {
    if (!animator.running(this)) {
      this._resize(width2, height);
    } else {
      this._resizeBeforeDraw = {
        width: width2,
        height
      };
    }
  }
  _resize(width2, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width2, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction$1(mode) ? mode({
        datasetIndex: i
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width: width2, height } = this._resizeBeforeDraw;
      this._resize(width2, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta, this.chartArea);
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width2, height) => {
      if (this.canvas) {
        this.resize(width2, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
class ArcElement extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
}
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
const usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
class LineElement extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
}
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
class PointElement extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
}
__publicField(PointElement, "id", "point");
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width: width2, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width2 / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject$1(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width2 = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width2 / 2, height / 2);
  const radius = parseBorderRadius(bar, width2 / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width2,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width2 - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h3 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h3,
    radius: rect.radius
  };
}
class BarElement extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
}
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
const BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
];
const BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i) {
  return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
  dataset.borderColor = getBorderColor(i);
  dataset.backgroundColor = getBackgroundColor(i);
  return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
  return i;
}
function colorizePolarAreaDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
  return i;
}
function getColorizer(chart) {
  let i = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i = colorizeDoughnutDataset(dataset, i);
    } else if (controller instanceof PolarAreaController) {
      i = colorizePolarAreaDataset(dataset, i);
    } else if (controller) {
      i = colorizeDefaultDataset(dataset, i);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k;
  for (k in descriptors2) {
    if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {
    start,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {
    property,
    start,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({
        x: first.x,
        y
      });
      points.push({
        x: last.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first.y
      });
      points.push({
        x,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray$2(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject$1(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject$1(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject$1(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
}
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis
    });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, {
      line,
      target,
      color: above,
      scale,
      property
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, {
    line,
    target,
    color: below,
    scale,
    property
  });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
const getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width2, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width2 = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width2 = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width2, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width2 = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width2 + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width2 : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width2 + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
}
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
class Title extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray$2(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
}
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const map = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map.get(chart));
    map.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray$2(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width2 = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width2 = Math.max(width2, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width2 += padding.width;
  return {
    width: width2,
    height
  };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width: width2 } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width2 + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width2 - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width: width2 } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width2 / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width2 / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width: width2 } = size;
  if (xAlign === "right") {
    x -= width2;
  } else if (xAlign === "center") {
    x -= width2 / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
const defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
class Tooltip extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width: width2, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width2;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width2 - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColor = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject$1(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width: width2, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width2 - topRight, y);
    ctx.quadraticCurveTo(x + width2, y, x + width2, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width2, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width2, y + height, x + width2 - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
}
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
const addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
const validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
class CategoryScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
}
class LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
const log10Floor = (v) => Math.floor(log10(v));
const changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
class LogarithmicScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
}
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray$2(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem(scale, index2, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left,
    top: y,
    right: left + size.w,
    bottom: y + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i = 0; i < valueCount; i++) {
    itemOpts.padding = padding[i];
    itemOpts.size = labelSizes[i];
    const item = createPointLabelItem(scale, i, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h3, angle) {
  if (angle === 90 || angle === 270) {
    y -= h3 / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h3;
  }
  return y;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const item = scale._pointLabelItems[i];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
class RadialLinearScale extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h3 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h3 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h3) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width2;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width2 = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width2 / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width2 + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
}
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
const UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map2, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map2[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map2 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map2[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
}
class TimeScale extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
}
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a, b) => a - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
}
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
const registerables = [
  controllers,
  elements,
  plugins,
  scales
];
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$f = Object.prototype;
var hasOwnProperty$c = objectProto$f.hasOwnProperty;
var nativeObjectToString$1 = objectProto$f.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$e = Object.prototype;
var nativeObjectToString = objectProto$e.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isArray = Array.isArray;
var isArray$1 = isArray;
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$d = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap$1 = getNative(root$1, "WeakMap");
var WeakMap$2 = WeakMap$1;
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function copyArray(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$1 = defineProperty;
function arrayEach(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$c = Object.prototype;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$a.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var objectProto$b = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$b;
  return value === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$6 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$6 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$7.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$4.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function arrayPush(array, values) {
  var index2 = -1, length = values.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values[index2];
  }
  return array;
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$4 = Object.prototype;
var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};
var getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}
var DataView = getNative(root$1, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var mapTag$5 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$5 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$5 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$5 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$5;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$5;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$3.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var Uint8Array2 = root$1.Uint8Array;
var Uint8Array$1 = Uint8Array2;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$2:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$4:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$2:
      return cloneRegExp(object);
    case setTag$4:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
var mapTag$3 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$3;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;
var setTag$3 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$3;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet$1 = isSet;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$2] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$2] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray$1(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var mapTag = "[object Map]", setTag = "[object Set]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) && (isArray$1(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer$1(value) || isTypedArray$1(value) || isArguments$1(value))) {
    return !value.length;
  }
  var tag = getTag$1(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function pascalCase(str) {
  return (str.match(/[a-zA-Z0-9]+/g) || []).map((w) => `${w.charAt(0).toUpperCase()}${w.slice(1)}`).join("");
}
var defineChartComponent = (chartName, chartType) => {
  const propsDefs = {
    chartData: { type: Object, required: true },
    options: { type: Object, required: false },
    chartId: { default: chartName, type: String },
    width: { default: 400, type: Number },
    height: { default: 400, type: Number },
    cssClasses: { type: String, default: "" },
    styles: { type: Object },
    plugins: { type: Array, default: () => [] },
    onLabelsUpdate: { type: Function },
    onChartUpdate: { type: Function },
    onChartDestroy: { type: Function },
    onChartRender: { type: Function }
  };
  const componentName = pascalCase(chartName);
  return defineComponent({
    name: componentName,
    props: propsDefs,
    emits: {
      "labels:update": () => true,
      "chart:update": (chartInstance) => true,
      "chart:destroy": () => true,
      "chart:render": (chartInstance) => true
    },
    setup(props, { emit, expose }) {
      const canvasRef = ref(null);
      const canvasId = `${props.chartId}`;
      let chartInstance = shallowRef(null);
      watch(() => props.chartData, watchHandler, { deep: true });
      watch(() => props.options, (newOptions) => {
        if (chartInstance.value && newOptions) {
          chartInstance.value.options = cloneDeep(newOptions);
          handleChartUpdate();
        }
      }, { deep: true });
      function watchHandler(newData) {
        if (chartInstance.value) {
          let chart = chartInstance.value;
          if (!isEqual(newData.labels, chartInstance.value.data.labels)) {
            chart.data.labels = newData.labels;
            handleLabelsUpdate();
          }
          if (!isEqual(newData.datasets, chartInstance.value.data.datasets)) {
            newData.datasets.forEach((dataset, index2) => {
              var _a, _b;
              if (!isEmpty(dataset)) {
                const oldData = cloneDeep(chart.data);
                const oldDatasetKeys = Object.keys((_b = (_a = oldData.datasets) == null ? void 0 : _a[index2]) != null ? _b : {});
                const newDatasetKeys = Object.keys(dataset);
                const deletionKeys = oldDatasetKeys.filter((key) => {
                  return key !== "_meta" && newDatasetKeys.indexOf(key) === -1;
                });
                deletionKeys.forEach((deletionKey) => {
                  if (chart.data.datasets[index2]) {
                    delete chart.data.datasets[index2][deletionKey];
                  }
                });
                for (const attribute in dataset) {
                  const attrValue = cloneDeep(dataset[attribute]);
                  let datasetItem = chart.data.datasets[index2];
                  if (!datasetItem) {
                    chart.data.datasets[index2] = {};
                  }
                  if (dataset.hasOwnProperty(attribute) && attrValue != null && chart) {
                    chart.data.datasets[index2][attribute] = attrValue;
                  }
                }
              } else {
                chart.data.datasets = [];
              }
            });
          }
          handleChartUpdate();
        } else {
          if (chartInstance.value) {
            handleChartDestroy();
          }
          renderChart();
        }
      }
      function renderChart() {
        if (canvasRef.value) {
          chartInstance.value = new Chart(canvasRef.value, {
            data: cloneDeep(props.chartData),
            type: chartType,
            options: cloneDeep(props.options),
            plugins: props.plugins
          });
          handleChartRender();
        } else {
          console.error(`Error on component ${componentName}, canvas cannot be rendered. Check if the render appends server-side`);
        }
      }
      function handleLabelsUpdate() {
        emit("labels:update");
        props.onLabelsUpdate && props.onLabelsUpdate();
      }
      function handleChartRender() {
        if (chartInstance.value) {
          emit("chart:render", chartInstance.value);
          props.onChartRender && props.onChartRender(chartInstance.value);
        }
      }
      function handleChartUpdate() {
        if (chartInstance.value) {
          chartInstance.value.update();
          emit("chart:update", chartInstance.value);
          props.onChartUpdate && props.onChartUpdate(chartInstance.value);
        }
      }
      function handleChartDestroy() {
        chartInstance.value && chartInstance.value.destroy();
        emit("chart:destroy");
        props.onChartDestroy && props.onChartDestroy();
      }
      onMounted(renderChart);
      onBeforeUnmount(() => {
        if (chartInstance.value) {
          chartInstance.value.destroy();
        }
      });
      expose({
        canvasRef,
        renderChart,
        chartInstance,
        canvasId,
        update: handleChartUpdate
      });
      return () => h("div", {
        style: __spreadProps(__spreadValues({
          maxWidth: "100%"
        }, props.styles), {
          position: "relative"
        }),
        class: props.cssClasses
      }, [
        h("canvas", {
          style: {
            maxWidth: "100%",
            maxHeight: "100%"
          },
          id: canvasId,
          width: props.width,
          height: props.height,
          ref: canvasRef
        })
      ]);
    }
  });
};
var BarChart = defineChartComponent("bar-chart", "bar");
defineChartComponent("doughnut-chart", "doughnut");
defineChartComponent("line-chart", "line");
var PieChart = defineChartComponent("pie-chart", "pie");
defineChartComponent("polar-chart", "polarArea");
defineChartComponent("radar-chart", "radar");
defineChartComponent("bubble-chart", "bubble");
defineChartComponent("scatter-chart", "scatter");
Chart.register(...registerables);
const _sfc_main = defineComponent({
  name: "IndexPage",
  components: { BarChart, PieChart },
  props: {
    accounts: {
      type: Object,
      default: () => ({})
    },
    chartElectric: {
      type: Object,
      default: () => ({})
    },
    chartGas: {
      type: Object,
      default: () => ({})
    },
    meterElectric: {
      type: Array,
      default: () => []
    },
    meterGas: {
      type: Array,
      default: () => []
    },
    round: {
      type: Boolean,
      default: false
    },
    isLoading: {
      type: Boolean,
      default: false
    },
    goalType: {
      type: String,
      default: "medium"
    },
    goal: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const toFixed = computed(() => {
      if (props.round) {
        return 2;
      } else {
        return 0;
      }
    });
    const data = ref(null);
    const progressElectric = ref(0);
    const progressGas = ref(0);
    const optionsElectric = ref({
      responsive: true,
      plugins: {
        legend: {
          display: false
        }
      },
      elements: {
        bar: {
          borderRadius: 10
        }
      },
      scales: {
        y: {
          ticks: {
            display: false
          },
          grid: {
            display: false
          }
        },
        x: {
          ticks: {
            autoSkip: true,
            maxRotation: 0,
            minRotation: 0
          }
        }
      }
    });
    const optionsGas = ref({
      responsive: true,
      plugins: {
        legend: {
          display: false
        }
      },
      elements: {
        bar: {
          borderRadius: 10
        }
      },
      scales: {
        y: {
          ticks: {
            display: false
          },
          grid: {
            display: false
          }
        },
        x: {
          ticks: {
            autoSkip: true,
            maxRotation: 0,
            minRotation: 0
          }
        }
      }
    });
    const totalElectric = computed(() => {
      return props.meterElectric.reduce((acc, curr) => {
        return acc + curr.consumption;
      }, 0);
    });
    const largestElectric = computed(() => {
      return Math.max(...props.meterElectric.map((item) => item.consumption));
    });
    const totalGas = computed(() => {
      return props.meterGas.reduce((acc, curr) => {
        return acc + curr.consumption;
      }, 0);
    });
    const largestGas = computed(() => {
      return Math.max(...props.meterGas.map((item) => item.consumption));
    });
    const goalElectric = ref(null);
    const goalGas = ref(null);
    const percentTotalElectric = ref(null);
    const percentGoalElectric = ref(null);
    const percentTotalGas = ref(null);
    const percentGoalGas = ref(null);
    watchEffect(() => {
      goalElectric.value = props.goal[props.goalType].electric / 365;
      goalGas.value = props.goal[props.goalType].gas / 365;
      progressElectric.value = props.meterElectric.length / 24;
      progressGas.value = props.meterGas.length / 24;
      percentTotalElectric.value = totalElectric.value / goalElectric.value * 100;
      percentGoalElectric.value = totalElectric.value > goalElectric.value ? 0 : 100 - percentTotalElectric.value;
      percentTotalGas.value = totalGas.value / goalGas.value * 100;
      percentGoalGas.value = totalGas.value > goalGas.value ? 0 : 100 - percentTotalGas.value;
      data.value = {
        labels: ["Electric", "Gas"],
        datasets: [
          {
            data: [percentTotalElectric, percentGoalElectric],
            backgroundColor: ["#FCE94F", "#0E012E"],
            borderWidth: 3,
            borderRadius: totalElectric.value > goalElectric.value ? 0 : Number.MAX_VALUE,
            borderColor: "#0E012E"
          },
          {
            data: [percentTotalGas, percentGoalGas],
            backgroundColor: ["#729FCF", "#0E012E"],
            borderWidth: 3,
            borderRadius: totalGas.value > goalGas.value ? 0 : Number.MAX_VALUE,
            borderColor: "#0E012E"
          }
        ]
      };
    });
    const options = {
      responsive: true,
      cutout: "30%",
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          enabled: false
        }
      }
    };
    return {
      data,
      options,
      optionsElectric,
      optionsGas,
      totalElectric,
      totalGas,
      largestElectric,
      largestGas,
      toFixed,
      goalElectric,
      goalGas,
      percentTotalElectric,
      percentGoalElectric,
      percentTotalGas,
      percentGoalGas,
      progressElectric,
      progressGas
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "flex items-center justify-center full-height full-width",
  style: { "height": "50vh !important" }
};
const _hoisted_2 = { style: { "display": "none" } };
const _hoisted_3 = { class: "widget widget-goal" };
const _hoisted_4 = {
  key: 1,
  class: "widget widget-elec"
};
const _hoisted_5 = /* @__PURE__ */ createBaseVNode("h2", null, "\u26A1 Electric", -1);
const _hoisted_6 = { class: "total" };
const _hoisted_7 = /* @__PURE__ */ createBaseVNode("small", null, "kWh", -1);
const _hoisted_8 = { class: "chart" };
const _hoisted_9 = {
  key: 0,
  class: "top"
};
const _hoisted_10 = /* @__PURE__ */ createBaseVNode("small", null, "kWh", -1);
const _hoisted_11 = {
  key: 1,
  class: "top"
};
const _hoisted_12 = /* @__PURE__ */ createBaseVNode("small", null, "kWh", -1);
const _hoisted_13 = { class: "footer" };
const _hoisted_14 = /* @__PURE__ */ createBaseVNode("small", null, "kWh", -1);
const _hoisted_15 = { class: "flex items-center q-gutter-x-sm" };
const _hoisted_16 = {
  key: 2,
  class: "widget widget-gas"
};
const _hoisted_17 = /* @__PURE__ */ createBaseVNode("h2", null, "\u{1F525} Gas", -1);
const _hoisted_18 = { class: "total" };
const _hoisted_19 = /* @__PURE__ */ createBaseVNode("small", null, [
  /* @__PURE__ */ createTextVNode("m"),
  /* @__PURE__ */ createBaseVNode("sup", null, "3")
], -1);
const _hoisted_20 = { class: "chart" };
const _hoisted_21 = {
  key: 0,
  class: "top"
};
const _hoisted_22 = /* @__PURE__ */ createBaseVNode("small", null, [
  /* @__PURE__ */ createTextVNode("m"),
  /* @__PURE__ */ createBaseVNode("sup", null, "3")
], -1);
const _hoisted_23 = {
  key: 1,
  class: "top"
};
const _hoisted_24 = /* @__PURE__ */ createBaseVNode("small", null, [
  /* @__PURE__ */ createTextVNode("m"),
  /* @__PURE__ */ createBaseVNode("sup", null, "3")
], -1);
const _hoisted_25 = { class: "footer" };
const _hoisted_26 = /* @__PURE__ */ createBaseVNode("small", null, [
  /* @__PURE__ */ createTextVNode("m"),
  /* @__PURE__ */ createBaseVNode("sup", null, "3")
], -1);
const _hoisted_27 = { class: "flex items-center q-gutter-x-sm" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PieChart = resolveComponent("PieChart");
  const _component_BarChart = resolveComponent("BarChart");
  return openBlock(), createBlock(QPage, { class: "q-px-lg" }, {
    default: withCtx(() => [
      _ctx.isLoading ? (openBlock(), createElementBlock("div", _hoisted_1, [
        createVNode(QSpinnerIos, {
          color: "primary",
          size: "2em"
        })
      ])) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_2, toDisplayString(_ctx.goal[_ctx.goalType]), 1),
      createBaseVNode("div", _hoisted_3, [
        createVNode(_component_PieChart, {
          chartData: _ctx.data,
          options: _ctx.options
        }, null, 8, ["chartData", "options"])
      ]),
      _ctx.totalElectric ? (openBlock(), createElementBlock("div", _hoisted_4, [
        _hoisted_5,
        createBaseVNode("p", _hoisted_6, [
          createTextVNode(toDisplayString(_ctx.totalElectric.toFixed(_ctx.toFixed)) + "/" + toDisplayString(_ctx.goalElectric.toFixed(_ctx.toFixed)), 1),
          _hoisted_7
        ]),
        createBaseVNode("div", _hoisted_8, [
          _ctx.largestElectric ? (openBlock(), createElementBlock("p", _hoisted_9, [
            createTextVNode(toDisplayString(_ctx.largestElectric.toFixed(_ctx.toFixed)), 1),
            _hoisted_10
          ])) : (openBlock(), createElementBlock("p", _hoisted_11, [
            createTextVNode("0.00"),
            _hoisted_12
          ])),
          createVNode(_component_BarChart, {
            chartData: _ctx.chartElectric,
            options: _ctx.optionsElectric
          }, null, 8, ["chartData", "options"])
        ]),
        createBaseVNode("div", _hoisted_13, [
          createBaseVNode("p", null, [
            createTextVNode("Total " + toDisplayString(_ctx.totalElectric.toFixed(_ctx.toFixed)), 1),
            _hoisted_14
          ]),
          createBaseVNode("div", _hoisted_15, [
            createVNode(QLinearProgress, {
              size: "8px",
              rounded: "",
              value: _ctx.progressElectric,
              color: "green",
              "track-color": "red"
            }, null, 8, ["value"]),
            _ctx.progressElectric === 0 ? (openBlock(), createBlock(QIcon, {
              key: 0,
              name: "wifi_off",
              size: "18px",
              color: "red"
            })) : _ctx.progressElectric > 0 && _ctx.progressElectric <= 0.5 ? (openBlock(), createBlock(QIcon, {
              key: 1,
              name: "wifi",
              size: "18px",
              color: "yellow"
            })) : (openBlock(), createBlock(QIcon, {
              key: 2,
              name: "wifi",
              size: "18px",
              color: "green"
            }))
          ])
        ])
      ])) : createCommentVNode("", true),
      _ctx.totalElectric ? (openBlock(), createElementBlock("div", _hoisted_16, [
        _hoisted_17,
        createBaseVNode("p", _hoisted_18, [
          createTextVNode(toDisplayString(_ctx.totalGas.toFixed(_ctx.toFixed)) + "/" + toDisplayString(_ctx.goalGas.toFixed(_ctx.toFixed)), 1),
          _hoisted_19
        ]),
        createBaseVNode("div", _hoisted_20, [
          _ctx.largestGas > 0 ? (openBlock(), createElementBlock("p", _hoisted_21, [
            createTextVNode(toDisplayString(_ctx.largestGas.toFixed(_ctx.toFixed)), 1),
            _hoisted_22
          ])) : (openBlock(), createElementBlock("p", _hoisted_23, [
            createTextVNode(" 0.00"),
            _hoisted_24
          ])),
          createVNode(_component_BarChart, {
            chartData: _ctx.chartGas,
            options: _ctx.optionsGas
          }, null, 8, ["chartData", "options"])
        ]),
        createBaseVNode("div", _hoisted_25, [
          createBaseVNode("p", null, [
            createTextVNode(" Total " + toDisplayString(_ctx.totalGas.toFixed(_ctx.toFixed)), 1),
            _hoisted_26
          ]),
          createBaseVNode("div", _hoisted_27, [
            createVNode(QLinearProgress, {
              size: "8px",
              rounded: "",
              value: _ctx.progressGas,
              color: "green",
              "track-color": "red"
            }, null, 8, ["value"]),
            _ctx.progressGas === 0 ? (openBlock(), createBlock(QIcon, {
              key: 0,
              name: "wifi_off",
              size: "18px",
              color: "red"
            })) : _ctx.progressGas > 0 && _ctx.progressGas <= 0.5 ? (openBlock(), createBlock(QIcon, {
              key: 1,
              name: "wifi",
              size: "18px",
              color: "yellow"
            })) : (openBlock(), createBlock(QIcon, {
              key: 2,
              name: "wifi",
              size: "18px",
              color: "green"
            }))
          ])
        ])
      ])) : createCommentVNode("", true)
    ]),
    _: 1
  });
}
var IndexPage = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "IndexPage.vue"]]);
export { IndexPage as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5kZXhQYWdlLjQzZmFhZDY2LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcXVhc2FyL3NyYy9jb21wb25lbnRzL3NwaW5uZXIvUVNwaW5uZXJJb3MuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcXVhc2FyL3NyYy9jb21wb25lbnRzL2xpbmVhci1wcm9ncmVzcy9RTGluZWFyUHJvZ3Jlc3MuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcXVhc2FyL3NyYy9jb21wb25lbnRzL3BhZ2UvUVBhZ2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGt1cmtsZS9jb2xvci9kaXN0L2NvbG9yLmVzbS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NodW5rcy9oZWxwZXJzLnNlZ21lbnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaGFydC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29yZUpzRGF0YS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzTWFza2VkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYXRpdmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRWYWx1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1dlYWtNYXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ3JlYXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weUFycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZGVmaW5lUHJvcGVydHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUVhY2guanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnblZhbHVlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lcS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnblZhbHVlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weU9iamVjdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXNJbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzSW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXNJbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hDbGVhci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hEZWxldGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoR2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaEhhcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hTZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NvY0luZGV4T2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVHZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVIYXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19MaXN0Q2FjaGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19NYXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXlhYmxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWFwRGF0YS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVHZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwQ2FjaGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVB1c2guanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0NsZWFyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tTZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TdGFjay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQXNzaWduSW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZUJ1ZmZlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5RmlsdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRTeW1ib2xzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weVN5bWJvbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRTeW1ib2xzSW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5U3ltYm9sc0luLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldEFsbEtleXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0QWxsS2V5c0luLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19Qcm9taXNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VGFnLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19VaW50OEFycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lRGF0YVZpZXcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVJlZ0V4cC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lU3ltYm9sLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVUeXBlZEFycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lQnlUYWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVPYmplY3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNNYXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTWFwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzU2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1NldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDbG9uZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY2xvbmVEZWVwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVBZGQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUhhcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldENhY2hlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTb21lLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FjaGVIYXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEFycmF5cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcFRvQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb0FycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxCeVRhZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VxdWFsT2JqZWN0cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0VtcHR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0VxdWFsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1jaGFydC0zL2Rpc3QvaW5kZXguanMiLCIuLi8uLi8uLi9zcmMvcGFnZXMvSW5kZXhQYWdlLnZ1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoIH0gZnJvbSAndnVlJ1xuXG5pbXBvcnQgdXNlU3Bpbm5lciwgeyB1c2VTcGlubmVyUHJvcHMgfSBmcm9tICcuL3VzZS1zcGlubmVyLmpzJ1xuXG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnQgfSBmcm9tICcuLi8uLi91dGlscy9wcml2YXRlL2NyZWF0ZS5qcydcblxuY29uc3Qgc3ZnID0gW1xuICBoKCdnJywge1xuICAgICdzdHJva2Utd2lkdGgnOiAnNCcsXG4gICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJ1xuICB9LCBbXG4gICAgaCgnbGluZScsIHtcbiAgICAgIHkxOiAnMTcnLFxuICAgICAgeTI6ICcyOScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMzIsMzIpIHJvdGF0ZSgxODApJ1xuICAgIH0sIFtcbiAgICAgIGgoJ2FuaW1hdGUnLCB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdzdHJva2Utb3BhY2l0eScsXG4gICAgICAgIGR1cjogJzc1MG1zJyxcbiAgICAgICAgdmFsdWVzOiAnMTsuODU7Ljc7LjY1Oy41NTsuNDU7LjM1Oy4yNTsuMTU7LjE7MDsxJyxcbiAgICAgICAgcmVwZWF0Q291bnQ6ICdpbmRlZmluaXRlJ1xuICAgICAgfSlcbiAgICBdKSxcbiAgICBoKCdsaW5lJywge1xuICAgICAgeTE6ICcxNycsXG4gICAgICB5MjogJzI5JyxcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgzMiwzMikgcm90YXRlKDIxMCknXG4gICAgfSwgW1xuICAgICAgaCgnYW5pbWF0ZScsIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgZHVyOiAnNzUwbXMnLFxuICAgICAgICB2YWx1ZXM6ICcwOzE7Ljg1Oy43Oy42NTsuNTU7LjQ1Oy4zNTsuMjU7LjE1Oy4xOzAnLFxuICAgICAgICByZXBlYXRDb3VudDogJ2luZGVmaW5pdGUnXG4gICAgICB9KVxuICAgIF0pLFxuICAgIGgoJ2xpbmUnLCB7XG4gICAgICB5MTogJzE3JyxcbiAgICAgIHkyOiAnMjknLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDMyLDMyKSByb3RhdGUoMjQwKSdcbiAgICB9LCBbXG4gICAgICBoKCdhbmltYXRlJywge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgICBkdXI6ICc3NTBtcycsXG4gICAgICAgIHZhbHVlczogJy4xOzA7MTsuODU7Ljc7LjY1Oy41NTsuNDU7LjM1Oy4yNTsuMTU7LjEnLFxuICAgICAgICByZXBlYXRDb3VudDogJ2luZGVmaW5pdGUnXG4gICAgICB9KVxuICAgIF0pLFxuICAgIGgoJ2xpbmUnLCB7XG4gICAgICB5MTogJzE3JyxcbiAgICAgIHkyOiAnMjknLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDMyLDMyKSByb3RhdGUoMjcwKSdcbiAgICB9LCBbXG4gICAgICBoKCdhbmltYXRlJywge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgICBkdXI6ICc3NTBtcycsXG4gICAgICAgIHZhbHVlczogJy4xNTsuMTswOzE7Ljg1Oy43Oy42NTsuNTU7LjQ1Oy4zNTsuMjU7LjE1JyxcbiAgICAgICAgcmVwZWF0Q291bnQ6ICdpbmRlZmluaXRlJ1xuICAgICAgfSlcbiAgICBdKSxcbiAgICBoKCdsaW5lJywge1xuICAgICAgeTE6ICcxNycsXG4gICAgICB5MjogJzI5JyxcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgzMiwzMikgcm90YXRlKDMwMCknXG4gICAgfSwgW1xuICAgICAgaCgnYW5pbWF0ZScsIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgZHVyOiAnNzUwbXMnLFxuICAgICAgICB2YWx1ZXM6ICcuMjU7LjE1Oy4xOzA7MTsuODU7Ljc7LjY1Oy41NTsuNDU7LjM1Oy4yNScsXG4gICAgICAgIHJlcGVhdENvdW50OiAnaW5kZWZpbml0ZSdcbiAgICAgIH0pXG4gICAgXSksXG4gICAgaCgnbGluZScsIHtcbiAgICAgIHkxOiAnMTcnLFxuICAgICAgeTI6ICcyOScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMzIsMzIpIHJvdGF0ZSgzMzApJ1xuICAgIH0sIFtcbiAgICAgIGgoJ2FuaW1hdGUnLCB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdzdHJva2Utb3BhY2l0eScsXG4gICAgICAgIGR1cjogJzc1MG1zJyxcbiAgICAgICAgdmFsdWVzOiAnLjM1Oy4yNTsuMTU7LjE7MDsxOy44NTsuNzsuNjU7LjU1Oy40NTsuMzUnLFxuICAgICAgICByZXBlYXRDb3VudDogJ2luZGVmaW5pdGUnXG4gICAgICB9KVxuICAgIF0pLFxuICAgIGgoJ2xpbmUnLCB7XG4gICAgICB5MTogJzE3JyxcbiAgICAgIHkyOiAnMjknLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDMyLDMyKSByb3RhdGUoMCknXG4gICAgfSwgW1xuICAgICAgaCgnYW5pbWF0ZScsIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgZHVyOiAnNzUwbXMnLFxuICAgICAgICB2YWx1ZXM6ICcuNDU7LjM1Oy4yNTsuMTU7LjE7MDsxOy44NTsuNzsuNjU7LjU1Oy40NScsXG4gICAgICAgIHJlcGVhdENvdW50OiAnaW5kZWZpbml0ZSdcbiAgICAgIH0pXG4gICAgXSksXG4gICAgaCgnbGluZScsIHtcbiAgICAgIHkxOiAnMTcnLFxuICAgICAgeTI6ICcyOScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMzIsMzIpIHJvdGF0ZSgzMCknXG4gICAgfSwgW1xuICAgICAgaCgnYW5pbWF0ZScsIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgZHVyOiAnNzUwbXMnLFxuICAgICAgICB2YWx1ZXM6ICcuNTU7LjQ1Oy4zNTsuMjU7LjE1Oy4xOzA7MTsuODU7Ljc7LjY1Oy41NScsXG4gICAgICAgIHJlcGVhdENvdW50OiAnaW5kZWZpbml0ZSdcbiAgICAgIH0pXG4gICAgXSksXG4gICAgaCgnbGluZScsIHtcbiAgICAgIHkxOiAnMTcnLFxuICAgICAgeTI6ICcyOScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMzIsMzIpIHJvdGF0ZSg2MCknXG4gICAgfSwgW1xuICAgICAgaCgnYW5pbWF0ZScsIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgZHVyOiAnNzUwbXMnLFxuICAgICAgICB2YWx1ZXM6ICcuNjU7LjU1Oy40NTsuMzU7LjI1Oy4xNTsuMTswOzE7Ljg1Oy43Oy42NScsXG4gICAgICAgIHJlcGVhdENvdW50OiAnaW5kZWZpbml0ZSdcbiAgICAgIH0pXG4gICAgXSksXG4gICAgaCgnbGluZScsIHtcbiAgICAgIHkxOiAnMTcnLFxuICAgICAgeTI6ICcyOScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMzIsMzIpIHJvdGF0ZSg5MCknXG4gICAgfSwgW1xuICAgICAgaCgnYW5pbWF0ZScsIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgZHVyOiAnNzUwbXMnLFxuICAgICAgICB2YWx1ZXM6ICcuNzsuNjU7LjU1Oy40NTsuMzU7LjI1Oy4xNTsuMTswOzE7Ljg1Oy43JyxcbiAgICAgICAgcmVwZWF0Q291bnQ6ICdpbmRlZmluaXRlJ1xuICAgICAgfSlcbiAgICBdKSxcbiAgICBoKCdsaW5lJywge1xuICAgICAgeTE6ICcxNycsXG4gICAgICB5MjogJzI5JyxcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgzMiwzMikgcm90YXRlKDEyMCknXG4gICAgfSwgW1xuICAgICAgaCgnYW5pbWF0ZScsIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgZHVyOiAnNzUwbXMnLFxuICAgICAgICB2YWx1ZXM6ICcuODU7Ljc7LjY1Oy41NTsuNDU7LjM1Oy4yNTsuMTU7LjE7MDsxOy44NScsXG4gICAgICAgIHJlcGVhdENvdW50OiAnaW5kZWZpbml0ZSdcbiAgICAgIH0pXG4gICAgXSksXG4gICAgaCgnbGluZScsIHtcbiAgICAgIHkxOiAnMTcnLFxuICAgICAgeTI6ICcyOScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMzIsMzIpIHJvdGF0ZSgxNTApJ1xuICAgIH0sIFtcbiAgICAgIGgoJ2FuaW1hdGUnLCB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdzdHJva2Utb3BhY2l0eScsXG4gICAgICAgIGR1cjogJzc1MG1zJyxcbiAgICAgICAgdmFsdWVzOiAnMTsuODU7Ljc7LjY1Oy41NTsuNDU7LjM1Oy4yNTsuMTU7LjE7MDsxJyxcbiAgICAgICAgcmVwZWF0Q291bnQ6ICdpbmRlZmluaXRlJ1xuICAgICAgfSlcbiAgICBdKVxuICBdKVxuXVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDb21wb25lbnQoe1xuICBuYW1lOiAnUVNwaW5uZXJJb3MnLFxuXG4gIHByb3BzOiB1c2VTcGlubmVyUHJvcHMsXG5cbiAgc2V0dXAgKHByb3BzKSB7XG4gICAgY29uc3QgeyBjU2l6ZSwgY2xhc3NlcyB9ID0gdXNlU3Bpbm5lcihwcm9wcylcblxuICAgIHJldHVybiAoKSA9PiBoKCdzdmcnLCB7XG4gICAgICBjbGFzczogY2xhc3Nlcy52YWx1ZSxcbiAgICAgIHdpZHRoOiBjU2l6ZS52YWx1ZSxcbiAgICAgIGhlaWdodDogY1NpemUudmFsdWUsXG4gICAgICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICB2aWV3Qm94OiAnMCAwIDY0IDY0J1xuICAgIH0sIHN2ZylcbiAgfVxufSlcbiIsImltcG9ydCB7IGgsIGNvbXB1dGVkLCBnZXRDdXJyZW50SW5zdGFuY2UgfSBmcm9tICd2dWUnXG5cbmltcG9ydCB1c2VEYXJrLCB7IHVzZURhcmtQcm9wcyB9IGZyb20gJy4uLy4uL2NvbXBvc2FibGVzL3ByaXZhdGUvdXNlLWRhcmsuanMnXG5pbXBvcnQgdXNlU2l6ZSwgeyB1c2VTaXplUHJvcHMgfSBmcm9tICcuLi8uLi9jb21wb3NhYmxlcy9wcml2YXRlL3VzZS1zaXplLmpzJ1xuXG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnQgfSBmcm9tICcuLi8uLi91dGlscy9wcml2YXRlL2NyZWF0ZS5qcydcbmltcG9ydCB7IGhNZXJnZVNsb3QgfSBmcm9tICcuLi8uLi91dGlscy9wcml2YXRlL3JlbmRlci5qcydcblxuY29uc3QgZGVmYXVsdFNpemVzID0ge1xuICB4czogMixcbiAgc206IDQsXG4gIG1kOiA2LFxuICBsZzogMTAsXG4gIHhsOiAxNFxufVxuXG5mdW5jdGlvbiB3aWR0aCAodmFsLCByZXZlcnNlLCAkcSkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogcmV2ZXJzZSA9PT0gdHJ1ZVxuICAgICAgPyBgdHJhbnNsYXRlWCgkeyAkcS5sYW5nLnJ0bCA9PT0gdHJ1ZSA/ICctJyA6ICcnIH0xMDAlKSBzY2FsZTNkKCR7IC12YWwgfSwxLDEpYFxuICAgICAgOiBgc2NhbGUzZCgkeyB2YWwgfSwxLDEpYFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUNvbXBvbmVudCh7XG4gIG5hbWU6ICdRTGluZWFyUHJvZ3Jlc3MnLFxuXG4gIHByb3BzOiB7XG4gICAgLi4udXNlRGFya1Byb3BzLFxuICAgIC4uLnVzZVNpemVQcm9wcyxcblxuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcbiAgICBidWZmZXI6IE51bWJlcixcblxuICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgdHJhY2tDb2xvcjogU3RyaW5nLFxuXG4gICAgcmV2ZXJzZTogQm9vbGVhbixcbiAgICBzdHJpcGU6IEJvb2xlYW4sXG4gICAgaW5kZXRlcm1pbmF0ZTogQm9vbGVhbixcbiAgICBxdWVyeTogQm9vbGVhbixcbiAgICByb3VuZGVkOiBCb29sZWFuLFxuXG4gICAgYW5pbWF0aW9uU3BlZWQ6IHtcbiAgICAgIHR5cGU6IFsgU3RyaW5nLCBOdW1iZXIgXSxcbiAgICAgIGRlZmF1bHQ6IDIxMDBcbiAgICB9LFxuXG4gICAgaW5zdGFudEZlZWRiYWNrOiBCb29sZWFuXG4gIH0sXG5cbiAgc2V0dXAgKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCB7IHByb3h5IH0gPSBnZXRDdXJyZW50SW5zdGFuY2UoKVxuICAgIGNvbnN0IGlzRGFyayA9IHVzZURhcmsocHJvcHMsIHByb3h5LiRxKVxuICAgIGNvbnN0IHNpemVTdHlsZSA9IHVzZVNpemUocHJvcHMsIGRlZmF1bHRTaXplcylcblxuICAgIGNvbnN0IG1vdGlvbiA9IGNvbXB1dGVkKCgpID0+IHByb3BzLmluZGV0ZXJtaW5hdGUgPT09IHRydWUgfHwgcHJvcHMucXVlcnkgPT09IHRydWUpXG4gICAgY29uc3Qgd2lkdGhSZXZlcnNlID0gY29tcHV0ZWQoKCkgPT4gcHJvcHMucmV2ZXJzZSAhPT0gcHJvcHMucXVlcnkpXG4gICAgY29uc3Qgc3R5bGUgPSBjb21wdXRlZCgoKSA9PiAoe1xuICAgICAgLi4uKHNpemVTdHlsZS52YWx1ZSAhPT0gbnVsbCA/IHNpemVTdHlsZS52YWx1ZSA6IHt9KSxcbiAgICAgICctLXEtbGluZWFyLXByb2dyZXNzLXNwZWVkJzogYCR7IHByb3BzLmFuaW1hdGlvblNwZWVkIH1tc2BcbiAgICB9KSlcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjb21wdXRlZCgoKSA9PlxuICAgICAgJ3EtbGluZWFyLXByb2dyZXNzJ1xuICAgICAgKyAocHJvcHMuY29sb3IgIT09IHZvaWQgMCA/IGAgdGV4dC0keyBwcm9wcy5jb2xvciB9YCA6ICcnKVxuICAgICAgKyAocHJvcHMucmV2ZXJzZSA9PT0gdHJ1ZSB8fCBwcm9wcy5xdWVyeSA9PT0gdHJ1ZSA/ICcgcS1saW5lYXItcHJvZ3Jlc3MtLXJldmVyc2UnIDogJycpXG4gICAgICArIChwcm9wcy5yb3VuZGVkID09PSB0cnVlID8gJyByb3VuZGVkLWJvcmRlcnMnIDogJycpXG4gICAgKVxuXG4gICAgY29uc3QgdHJhY2tTdHlsZSA9IGNvbXB1dGVkKCgpID0+IHdpZHRoKHByb3BzLmJ1ZmZlciAhPT0gdm9pZCAwID8gcHJvcHMuYnVmZmVyIDogMSwgd2lkdGhSZXZlcnNlLnZhbHVlLCBwcm94eS4kcSkpXG4gICAgY29uc3QgdHJhbnNpdGlvblN1ZmZpeCA9IGNvbXB1dGVkKCgpID0+IGB3aXRoJHsgcHJvcHMuaW5zdGFudEZlZWRiYWNrID09PSB0cnVlID8gJ291dCcgOiAnJyB9LXRyYW5zaXRpb25gKVxuXG4gICAgY29uc3QgdHJhY2tDbGFzcyA9IGNvbXB1dGVkKCgpID0+XG4gICAgICAncS1saW5lYXItcHJvZ3Jlc3NfX3RyYWNrIGFic29sdXRlLWZ1bGwnXG4gICAgICArIGAgcS1saW5lYXItcHJvZ3Jlc3NfX3RyYWNrLS0keyB0cmFuc2l0aW9uU3VmZml4LnZhbHVlIH1gXG4gICAgICArIGAgcS1saW5lYXItcHJvZ3Jlc3NfX3RyYWNrLS0keyBpc0RhcmsudmFsdWUgPT09IHRydWUgPyAnZGFyaycgOiAnbGlnaHQnIH1gXG4gICAgICArIChwcm9wcy50cmFja0NvbG9yICE9PSB2b2lkIDAgPyBgIGJnLSR7IHByb3BzLnRyYWNrQ29sb3IgfWAgOiAnJylcbiAgICApXG5cbiAgICBjb25zdCBtb2RlbFN0eWxlID0gY29tcHV0ZWQoKCkgPT4gd2lkdGgobW90aW9uLnZhbHVlID09PSB0cnVlID8gMSA6IHByb3BzLnZhbHVlLCB3aWR0aFJldmVyc2UudmFsdWUsIHByb3h5LiRxKSlcbiAgICBjb25zdCBtb2RlbENsYXNzID0gY29tcHV0ZWQoKCkgPT5cbiAgICAgICdxLWxpbmVhci1wcm9ncmVzc19fbW9kZWwgYWJzb2x1dGUtZnVsbCdcbiAgICAgICsgYCBxLWxpbmVhci1wcm9ncmVzc19fbW9kZWwtLSR7IHRyYW5zaXRpb25TdWZmaXgudmFsdWUgfWBcbiAgICAgICsgYCBxLWxpbmVhci1wcm9ncmVzc19fbW9kZWwtLSR7IG1vdGlvbi52YWx1ZSA9PT0gdHJ1ZSA/ICdpbicgOiAnJyB9ZGV0ZXJtaW5hdGVgXG4gICAgKVxuXG4gICAgY29uc3Qgc3RyaXBlU3R5bGUgPSBjb21wdXRlZCgoKSA9PiAoeyB3aWR0aDogYCR7IHByb3BzLnZhbHVlICogMTAwIH0lYCB9KSlcbiAgICBjb25zdCBzdHJpcGVDbGFzcyA9IGNvbXB1dGVkKCgpID0+XG4gICAgICBgcS1saW5lYXItcHJvZ3Jlc3NfX3N0cmlwZSBhYnNvbHV0ZS0keyBwcm9wcy5yZXZlcnNlID09PSB0cnVlID8gJ3JpZ2h0JyA6ICdsZWZ0JyB9YFxuICAgICAgKyBgIHEtbGluZWFyLXByb2dyZXNzX19zdHJpcGUtLSR7IHRyYW5zaXRpb25TdWZmaXgudmFsdWUgfWBcbiAgICApXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGQgPSBbXG4gICAgICAgIGgoJ2RpdicsIHtcbiAgICAgICAgICBjbGFzczogdHJhY2tDbGFzcy52YWx1ZSxcbiAgICAgICAgICBzdHlsZTogdHJhY2tTdHlsZS52YWx1ZVxuICAgICAgICB9KSxcblxuICAgICAgICBoKCdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6IG1vZGVsQ2xhc3MudmFsdWUsXG4gICAgICAgICAgc3R5bGU6IG1vZGVsU3R5bGUudmFsdWVcbiAgICAgICAgfSlcbiAgICAgIF1cblxuICAgICAgcHJvcHMuc3RyaXBlID09PSB0cnVlICYmIG1vdGlvbi52YWx1ZSA9PT0gZmFsc2UgJiYgY2hpbGQucHVzaChcbiAgICAgICAgaCgnZGl2Jywge1xuICAgICAgICAgIGNsYXNzOiBzdHJpcGVDbGFzcy52YWx1ZSxcbiAgICAgICAgICBzdHlsZTogc3RyaXBlU3R5bGUudmFsdWVcbiAgICAgICAgfSlcbiAgICAgIClcblxuICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMudmFsdWUsXG4gICAgICAgIHN0eWxlOiBzdHlsZS52YWx1ZSxcbiAgICAgICAgcm9sZTogJ3Byb2dyZXNzYmFyJyxcbiAgICAgICAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAgICAgICAnYXJpYS12YWx1ZW1heCc6IDEsXG4gICAgICAgICdhcmlhLXZhbHVlbm93JzogcHJvcHMuaW5kZXRlcm1pbmF0ZSA9PT0gdHJ1ZVxuICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgOiBwcm9wcy52YWx1ZVxuICAgICAgfSwgaE1lcmdlU2xvdChzbG90cy5kZWZhdWx0LCBjaGlsZCkpXG4gICAgfVxuICB9XG59KVxuIiwiaW1wb3J0IHsgaCwgY29tcHV0ZWQsIGluamVjdCwgZ2V0Q3VycmVudEluc3RhbmNlIH0gZnJvbSAndnVlJ1xuXG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnQgfSBmcm9tICcuLi8uLi91dGlscy9wcml2YXRlL2NyZWF0ZS5qcydcbmltcG9ydCB7IGhTbG90IH0gZnJvbSAnLi4vLi4vdXRpbHMvcHJpdmF0ZS9yZW5kZXIuanMnXG5pbXBvcnQgeyBwYWdlQ29udGFpbmVyS2V5LCBsYXlvdXRLZXksIGVtcHR5UmVuZGVyRm4gfSBmcm9tICcuLi8uLi91dGlscy9wcml2YXRlL3N5bWJvbHMuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUNvbXBvbmVudCh7XG4gIG5hbWU6ICdRUGFnZScsXG5cbiAgcHJvcHM6IHtcbiAgICBwYWRkaW5nOiBCb29sZWFuLFxuICAgIHN0eWxlRm46IEZ1bmN0aW9uXG4gIH0sXG5cbiAgc2V0dXAgKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCB7IHByb3h5OiB7ICRxIH0gfSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpXG5cbiAgICBjb25zdCAkbGF5b3V0ID0gaW5qZWN0KGxheW91dEtleSwgZW1wdHlSZW5kZXJGbilcbiAgICBpZiAoJGxheW91dCA9PT0gZW1wdHlSZW5kZXJGbikge1xuICAgICAgY29uc29sZS5lcnJvcignUVBhZ2UgbmVlZHMgdG8gYmUgYSBkZWVwIGNoaWxkIG9mIFFMYXlvdXQnKVxuICAgICAgcmV0dXJuIGVtcHR5UmVuZGVyRm5cbiAgICB9XG5cbiAgICBjb25zdCAkcGFnZUNvbnRhaW5lciA9IGluamVjdChwYWdlQ29udGFpbmVyS2V5LCBlbXB0eVJlbmRlckZuKVxuICAgIGlmICgkcGFnZUNvbnRhaW5lciA9PT0gZW1wdHlSZW5kZXJGbikge1xuICAgICAgY29uc29sZS5lcnJvcignUVBhZ2UgbmVlZHMgdG8gYmUgY2hpbGQgb2YgUVBhZ2VDb250YWluZXInKVxuICAgICAgcmV0dXJuIGVtcHR5UmVuZGVyRm5cbiAgICB9XG5cbiAgICBjb25zdCBzdHlsZSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGNvbnN0IG9mZnNldFxuICAgICAgICA9ICgkbGF5b3V0LmhlYWRlci5zcGFjZSA9PT0gdHJ1ZSA/ICRsYXlvdXQuaGVhZGVyLnNpemUgOiAwKVxuICAgICAgICArICgkbGF5b3V0LmZvb3Rlci5zcGFjZSA9PT0gdHJ1ZSA/ICRsYXlvdXQuZm9vdGVyLnNpemUgOiAwKVxuXG4gICAgICBpZiAodHlwZW9mIHByb3BzLnN0eWxlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gJGxheW91dC5pc0NvbnRhaW5lci52YWx1ZSA9PT0gdHJ1ZVxuICAgICAgICAgID8gJGxheW91dC5jb250YWluZXJIZWlnaHQudmFsdWVcbiAgICAgICAgICA6ICRxLnNjcmVlbi5oZWlnaHRcblxuICAgICAgICByZXR1cm4gcHJvcHMuc3R5bGVGbihvZmZzZXQsIGhlaWdodClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluSGVpZ2h0OiAkbGF5b3V0LmlzQ29udGFpbmVyLnZhbHVlID09PSB0cnVlXG4gICAgICAgICAgPyAoJGxheW91dC5jb250YWluZXJIZWlnaHQudmFsdWUgLSBvZmZzZXQpICsgJ3B4J1xuICAgICAgICAgIDogKFxuICAgICAgICAgICAgICAkcS5zY3JlZW4uaGVpZ2h0ID09PSAwXG4gICAgICAgICAgICAgICAgPyAob2Zmc2V0ICE9PSAwID8gYGNhbGMoMTAwdmggLSAkeyBvZmZzZXQgfXB4KWAgOiAnMTAwdmgnKVxuICAgICAgICAgICAgICAgIDogKCRxLnNjcmVlbi5oZWlnaHQgLSBvZmZzZXQpICsgJ3B4J1xuICAgICAgICAgICAgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBjbGFzc2VzID0gY29tcHV0ZWQoKCkgPT5cbiAgICAgIGBxLXBhZ2UkeyBwcm9wcy5wYWRkaW5nID09PSB0cnVlID8gJyBxLWxheW91dC1wYWRkaW5nJyA6ICcnIH1gXG4gICAgKVxuXG4gICAgcmV0dXJuICgpID0+IGgoJ21haW4nLCB7XG4gICAgICBjbGFzczogY2xhc3Nlcy52YWx1ZSxcbiAgICAgIHN0eWxlOiBzdHlsZS52YWx1ZVxuICAgIH0sIGhTbG90KHNsb3RzLmRlZmF1bHQpKVxuICB9XG59KVxuIiwiLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjMuMlxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDIzIEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiByb3VuZCh2KSB7XG4gIHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpLCAwLCAxMDApO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuICByZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuICBsZXQgaTtcbiAgaWYgKHcgKyBiID4gMSkge1xuICAgIGkgPSAxIC8gKHcgKyBiKTtcbiAgICB3ICo9IGk7XG4gICAgYiAqPSBpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByZ2JbaV0gKj0gMSAtIHcgLSBiO1xuICAgIHJnYltpXSArPSB3O1xuICB9XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpIHtcbiAgaWYgKHIgPT09IG1heCkge1xuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xuICB9XG4gIGlmIChnID09PSBtYXgpIHtcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xuICB9XG4gIHJldHVybiAociAtIGcpIC8gZCArIDQ7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcbiAgY29uc3QgcmFuZ2UgPSAyNTU7XG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcbiAgY29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuICBjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgbGV0IGgsIHMsIGQ7XG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIGggPSBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpO1xuICAgIGggPSBoICogNjAgKyAwLjU7XG4gIH1cbiAgcmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGEpXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcbiAgICAgIDogZihhLCBiLCBjKVxuICApLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG4gIHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcbiAgcmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuICByZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcbiAgcmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuICBjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCB2O1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bNV0gIT09IHYpIHtcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuICB9XG4gIGNvbnN0IGggPSBodWUoK21bMl0pO1xuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuICBjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuICBpZiAobVsxXSA9PT0gJ2h3YicpIHtcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG4gICAgdiA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICB2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcjogdlswXSxcbiAgICBnOiB2WzFdLFxuICAgIGI6IHZbMl0sXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuICB2YXIgaCA9IHJnYjJoc2wodik7XG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG4gIGggPSBoc2wycmdiKGgpO1xuICB2LnIgPSBoWzBdO1xuICB2LmcgPSBoWzFdO1xuICB2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcbiAgaWYgKCF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuICBjb25zdCBoID0gYVswXTtcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcbiAgY29uc3QgbCA9IG4ycChhWzJdKTtcbiAgcmV0dXJuIHYuYSA8IDI1NVxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG4gICAgOiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuXG5jb25zdCBtYXAgPSB7XG4gIHg6ICdkYXJrJyxcbiAgWjogJ2xpZ2h0JyxcbiAgWTogJ3JlJyxcbiAgWDogJ2JsdScsXG4gIFc6ICdncicsXG4gIFY6ICdtZWRpdW0nLFxuICBVOiAnc2xhdGUnLFxuICBBOiAnZWUnLFxuICBUOiAnb2wnLFxuICBTOiAnb3InLFxuICBCOiAncmEnLFxuICBDOiAnbGF0ZWcnLFxuICBEOiAnaWdodHMnLFxuICBSOiAnaW4nLFxuICBROiAndHVycXVvaXMnLFxuICBFOiAnaGknLFxuICBQOiAncm8nLFxuICBPOiAnYWwnLFxuICBOOiAnbGUnLFxuICBNOiAnZGUnLFxuICBMOiAneWVsbG8nLFxuICBGOiAnZW4nLFxuICBLOiAnY2gnLFxuICBHOiAnYXJrcycsXG4gIEg6ICdlYScsXG4gIEk6ICdpZ2h0ZycsXG4gIEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuICBPaWNlWGU6ICdmMGY4ZmYnLFxuICBhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG4gIGFxdWE6ICdmZmZmJyxcbiAgYXF1YW1hclJlOiAnN2ZmZmQ0JyxcbiAgYXp1WTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwJyxcbiAgYmxhbktlZE9tb25kOiAnZmZlYmNkJyxcbiAgWGU6ICdmZicsXG4gIFhldmlUZXQ6ICc4YTJiZTInLFxuICBiUHduOiAnYTUyYTJhJyxcbiAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgY2FNdFhlOiAnNWY5ZWEwJyxcbiAgS2FydFl1c2U6ICc3ZmZmMDAnLFxuICBLb2NUYXRlOiAnZDI2OTFlJyxcbiAgY1NPOiAnZmY3ZjUwJyxcbiAgY1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuICBjU25zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICdmZmZmJyxcbiAgeFhlOiAnOGInLFxuICB4Y3lhbjogJzhiOGInLFxuICB4Z1RNblBkOiAnYjg4NjBiJyxcbiAgeFdheTogJ2E5YTlhOScsXG4gIHhnWUY6ICc2NDAwJyxcbiAgeGdZeTogJ2E5YTlhOScsXG4gIHhraGFraTogJ2JkYjc2YicsXG4gIHhtYWdGdGE6ICc4YjAwOGInLFxuICB4VGl2ZWdZRjogJzU1NmIyZicsXG4gIHhTYW5nZTogJ2ZmOGMwMCcsXG4gIHhTY0VkOiAnOTkzMmNjJyxcbiAgeFlkOiAnOGIwMDAwJyxcbiAgeHNPbW9uOiAnZTk5NjdhJyxcbiAgeHNIZ1lGOiAnOGZiYzhmJyxcbiAgeFVYZTogJzQ4M2Q4YicsXG4gIHhVV2F5OiAnMmY0ZjRmJyxcbiAgeFVnWXk6ICcyZjRmNGYnLFxuICB4UWU6ICdjZWQxJyxcbiAgeHZpVGV0OiAnOTQwMGQzJyxcbiAgZEFwcFJrOiAnZmYxNDkzJyxcbiAgZEFwc2t5WGU6ICdiZmZmJyxcbiAgZGltV2F5OiAnNjk2OTY5JyxcbiAgZGltZ1l5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyWGU6ICcxZTkwZmYnLFxuICBmaVlicmljazogJ2IyMjIyMicsXG4gIGZsU093RXRlOiAnZmZmYWYwJyxcbiAgZm9Zc3RXQW46ICcyMjhiMjInLFxuICBmdUtzaWE6ICdmZjAwZmYnLFxuICBnYVJzYlNvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3RXRlOiAnZjhmOGZmJyxcbiAgZ1RkOiAnZmZkNzAwJyxcbiAgZ1RNblBkOiAnZGFhNTIwJyxcbiAgV2F5OiAnODA4MDgwJyxcbiAgZ1lGOiAnODAwMCcsXG4gIGdZRkx3OiAnYWRmZjJmJyxcbiAgZ1l5OiAnODA4MDgwJyxcbiAgaG9uZXlNdzogJ2YwZmZmMCcsXG4gIGhvdHBSazogJ2ZmNjliNCcsXG4gIFJkaWFuWWQ6ICdjZDVjNWMnLFxuICBSZGlnbzogJzRiMDA4MicsXG4gIGl2U3k6ICdmZmZmZjAnLFxuICBraGFraTogJ2YwZTY4YycsXG4gIGxhdkZNcjogJ2U2ZTZmYScsXG4gIGxhdkZNclhzaDogJ2ZmZjBmNScsXG4gIGxhd25nWUY6ICc3Y2ZjMDAnLFxuICBObW9uY0VmZm9uOiAnZmZmYWNkJyxcbiAgWlhlOiAnYWRkOGU2JyxcbiAgWmNTTzogJ2YwODA4MCcsXG4gIFpjeWFuOiAnZTBmZmZmJyxcbiAgWmdUTW5QZEx3OiAnZmFmYWQyJyxcbiAgWldheTogJ2QzZDNkMycsXG4gIFpnWUY6ICc5MGVlOTAnLFxuICBaZ1l5OiAnZDNkM2QzJyxcbiAgWnBSazogJ2ZmYjZjMScsXG4gIFpzT21vbjogJ2ZmYTA3YScsXG4gIFpzSGdZRjogJzIwYjJhYScsXG4gIFpza3lYZTogJzg3Y2VmYScsXG4gIFpVV2F5OiAnNzc4ODk5JyxcbiAgWlVnWXk6ICc3Nzg4OTknLFxuICBac3RBbFhlOiAnYjBjNGRlJyxcbiAgWkx3OiAnZmZmZmUwJyxcbiAgbGltZTogJ2ZmMDAnLFxuICBsaW1lZ1lGOiAnMzJjZDMyJyxcbiAgbFJGOiAnZmFmMGU2JyxcbiAgbWFnRnRhOiAnZmYwMGZmJyxcbiAgbWFQb246ICc4MDAwMDAnLFxuICBWYXF1YW1hclJlOiAnNjZjZGFhJyxcbiAgVlhlOiAnY2QnLFxuICBWU2NFZDogJ2JhNTVkMycsXG4gIFZwdXJwTjogJzkzNzBkYicsXG4gIFZzSGdZRjogJzNjYjM3MScsXG4gIFZVWGU6ICc3YjY4ZWUnLFxuICBWc3ByUmdnWUY6ICdmYTlhJyxcbiAgVlFlOiAnNDhkMWNjJyxcbiAgVnZpVGV0WWQ6ICdjNzE1ODUnLFxuICBtaWRuaWdodFhlOiAnMTkxOTcwJyxcbiAgbVJ0Y1lhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5UHNlOiAnZmZlNGUxJyxcbiAgbW9jY2FzUjogJ2ZmZTRiNScsXG4gIG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnODAnLFxuICBUZGxhY2U6ICdmZGY1ZTYnLFxuICBUaXZlOiAnODA4MDAwJyxcbiAgVGl2ZWRCYjogJzZiOGUyMycsXG4gIFNhbmdlOiAnZmZhNTAwJyxcbiAgU2FuZ2VZZDogJ2ZmNDUwMCcsXG4gIFNjRWQ6ICdkYTcwZDYnLFxuICBwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuICBwT2VnWUY6ICc5OGZiOTgnLFxuICBwT2VRZTogJ2FmZWVlZScsXG4gIHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuICBwYXBheWF3RXA6ICdmZmVmZDUnLFxuICBwSEtwdWZmOiAnZmZkYWI5JyxcbiAgcGVydTogJ2NkODUzZicsXG4gIHBSazogJ2ZmYzBjYicsXG4gIHBsdW06ICdkZGEwZGQnLFxuICBwb3dNclhlOiAnYjBlMGU2JyxcbiAgcHVycE46ICc4MDAwODAnLFxuICBZYmVjY2FwdXJwTjogJzY2MzM5OScsXG4gIFlkOiAnZmYwMDAwJyxcbiAgUHN5YnJvd246ICdiYzhmOGYnLFxuICBQeU9YZTogJzQxNjllMScsXG4gIHNhZGROYlB3bjogJzhiNDUxMycsXG4gIHNPbW9uOiAnZmE4MDcyJyxcbiAgc2FuZHliUHduOiAnZjRhNDYwJyxcbiAgc0hnWUY6ICcyZThiNTcnLFxuICBzSHNoZWxsOiAnZmZmNWVlJyxcbiAgc2lGbmE6ICdhMDUyMmQnLFxuICBzaWx2ZXI6ICdjMGMwYzAnLFxuICBza3lYZTogJzg3Y2VlYicsXG4gIFVYZTogJzZhNWFjZCcsXG4gIFVXYXk6ICc3MDgwOTAnLFxuICBVZ1l5OiAnNzA4MDkwJyxcbiAgc25vdzogJ2ZmZmFmYScsXG4gIHNwclJnZ1lGOiAnZmY3ZicsXG4gIHN0QWxYZTogJzQ2ODJiNCcsXG4gIHRhbjogJ2QyYjQ4YycsXG4gIHRlTzogJzgwODAnLFxuICB0RXN0TjogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIFFlOiAnNDBlMGQwJyxcbiAgdmlUZXQ6ICdlZTgyZWUnLFxuICBKSHQ6ICdmNWRlYjMnLFxuICB3RXRlOiAnZmZmZmZmJyxcbiAgd0V0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgTHc6ICdmZmZmMDAnLFxuICBMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cblxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs3XSAhPT0gcikge1xuICAgIGNvbnN0IHYgPSArbVs3XTtcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xuICB9XG4gIHIgPSArbVsxXTtcbiAgZyA9ICttWzNdO1xuICBiID0gK21bNV07XG4gIHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IGxpbShyLCAwLCAyNTUpKTtcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xuICBiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBsaW0oYiwgMCwgMjU1KSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHYgJiYgKFxuICAgIHYuYSA8IDI1NVxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG4gICAgICA6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG4gICk7XG59XG5cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5leHBvcnQgeyBDb2xvciwgYjJuLCBiMnAsIGluZGV4X2VzbSBhcyBkZWZhdWx0LCBoZXhQYXJzZSwgaGV4U3RyaW5nLCBoc2wycmdiLCBoc2xTdHJpbmcsIGhzdjJyZ2IsIGh1ZVBhcnNlLCBod2IycmdiLCBsaW0sIG4yYiwgbjJwLCBuYW1lUGFyc2UsIHAyYiwgcmdiMmhzbCwgcmdiUGFyc2UsIHJnYlN0cmluZywgcm90YXRlLCByb3VuZCB9O1xuIiwiLyohXG4gKiBDaGFydC5qcyB2NC40LjBcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMyBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJ0BrdXJrbGUvY29sb3InO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVyc1xuICovIC8qKlxuICogQW4gZW1wdHkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIGZvciBvcHRpb25hbCBjYWxsYmFjay5cbiAqLyBmdW5jdGlvbiBub29wKCkge1xuLyogbm9vcCAqLyB9XG4vKipcbiAqIFJldHVybnMgYSB1bmlxdWUgaWQsIHNlcXVlbnRpYWxseSBnZW5lcmF0ZWQgZnJvbSBhIGdsb2JhbCB2YXJpYWJsZS5cbiAqLyBjb25zdCB1aWQgPSAoKCk9PntcbiAgICBsZXQgaWQgPSAwO1xuICAgIHJldHVybiAoKT0+aWQrKztcbn0pKCk7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovIGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWYodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgKGluY2x1ZGluZyB0eXBlZCBhcnJheXMpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBmdW5jdGlvblxuICovIGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnNsaWNlKC02KSA9PT0gJ0FycmF5XScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHNpbmNlIDIuNy4wXG4gKi8gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXG4gKiBAcGFyYW0gdmFsdWUgIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKi8gZnVuY3Rpb24gaXNOdW1iZXJGaW5pdGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG59XG4vKipcbiAqIFJldHVybnMgYHZhbHVlYCBpZiBmaW5pdGUsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgbm90IGZpbml0ZS5cbiAqLyBmdW5jdGlvbiBmaW5pdGVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICovIGZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlLCBkaW1lbnNpb24pPT50eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgPyBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCA6ICt2YWx1ZSAvIGRpbWVuc2lvbjtcbmNvbnN0IHRvRGltZW5zaW9uID0gKHZhbHVlLCBkaW1lbnNpb24pPT50eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgPyBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvbiA6ICt2YWx1ZTtcbi8qKlxuICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgcmV0dXJuZWQgYnkgYGZuYC4gSWYgYGZuYCBpcyBub3QgYSBmdW5jdGlvbiwgdGhpcyBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB3aXRoIHdoaWNoIGBmbmAgc2hvdWxkIGJlIGNhbGxlZC5cbiAqIEBwYXJhbSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuICovIGZ1bmN0aW9uIGNhbGxiYWNrKGZuLCBhcmdzLCB0aGlzQXJnKSB7XG4gICAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlYWNoKGxvb3BhYmxlLCBmbiwgdGhpc0FyZywgcmV2ZXJzZSkge1xuICAgIGxldCBpLCBsZW4sIGtleXM7XG4gICAgaWYgKGlzQXJyYXkobG9vcGFibGUpKSB7XG4gICAgICAgIGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcbiAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICAgIGZvcihpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICAgICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChsb29wYWJsZSkpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGxvb3BhYmxlKTtcbiAgICAgICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVba2V5c1tpXV0sIGtleXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBhMSAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9lbGVtZW50c0VxdWFsKGEwLCBhMSkge1xuICAgIGxldCBpLCBpbGVuLCB2MCwgdjE7XG4gICAgaWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IoaSA9IDAsIGlsZW4gPSBhMC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICB2MCA9IGEwW2ldO1xuICAgICAgICB2MSA9IGExW2ldO1xuICAgICAgICBpZiAodjAuZGF0YXNldEluZGV4ICE9PSB2MS5kYXRhc2V0SW5kZXggfHwgdjAuaW5kZXggIT09IHYxLmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFJldHVybnMgYSBkZWVwIGNvcHkgb2YgYHNvdXJjZWAgd2l0aG91dCBrZWVwaW5nIHJlZmVyZW5jZXMgb24gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICogQHBhcmFtIHNvdXJjZSAtIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqLyBmdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IGtsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICBmb3IoOyBrIDwga2xlbjsgKytrKXtcbiAgICAgICAgICAgIHRhcmdldFtrZXlzW2tdXSA9IGNsb25lKHNvdXJjZVtrZXlzW2tdXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ19fcHJvdG9fXycsXG4gICAgICAgICdwcm90b3R5cGUnLFxuICAgICAgICAnY29uc3RydWN0b3InXG4gICAgXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXG4gKiBOb3RlKFNCKTogYWxzbyB1c2VkIGJ5IG1lcmdlQ29uZmlnIGFuZCBtZXJnZVNjYWxlQ29uZmlnIGFzIGZhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gICAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBpc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbXG4gICAgICAgIHNvdXJjZVxuICAgIF07XG4gICAgY29uc3QgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICAgIGxldCBjdXJyZW50O1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBjdXJyZW50ID0gc291cmNlc1tpXTtcbiAgICAgICAgaWYgKCFpc09iamVjdChjdXJyZW50KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cnJlbnQpO1xuICAgICAgICBmb3IobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spe1xuICAgICAgICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgY3VycmVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG1lcmdlSWYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgcmV0dXJuIG1lcmdlKHRhcmdldCwgc291cmNlLCB7XG4gICAgICAgIG1lcmdlcjogX21lcmdlcklmXG4gICAgfSk7XG59XG4vKipcbiAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX21lcmdlcklmKGtleSwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gICAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gICAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICAgIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfZGVwcmVjYXRlZChzY29wZSwgdmFsdWUsIHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgKyAnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgICB9XG59XG4vLyByZXNvbHZlT2JqZWN0S2V5IHJlc29sdmVyIGNhY2hlXG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gICAgLy8gQ2hhcnQuaGVscGVycy5jb3JlIHJlc29sdmVPYmplY3RLZXkgc2hvdWxkIHJlc29sdmUgZW1wdHkga2V5IHRvIHJvb3Qgb2JqZWN0XG4gICAgJyc6ICh2KT0+dixcbiAgICAvLyBkZWZhdWx0IHJlc29sdmVyc1xuICAgIHg6IChvKT0+by54LFxuICAgIHk6IChvKT0+by55XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9zcGxpdEtleShrZXkpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBsZXQgdG1wID0gJyc7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKXtcbiAgICAgICAgdG1wICs9IHBhcnQ7XG4gICAgICAgIGlmICh0bXAuZW5kc1dpdGgoJ1xcXFwnKSkge1xuICAgICAgICAgICAgdG1wID0gdG1wLnNsaWNlKDAsIC0xKSArICcuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleXMucHVzaCh0bXApO1xuICAgICAgICAgICAgdG1wID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSB7XG4gICAgY29uc3Qga2V5cyA9IF9zcGxpdEtleShrZXkpO1xuICAgIHJldHVybiAob2JqKT0+e1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cyl7XG4gICAgICAgICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IG9iaiAmJiBvYmpba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSkge1xuICAgIGNvbnN0IHJlc29sdmVyID0ga2V5UmVzb2x2ZXJzW2tleV0gfHwgKGtleVJlc29sdmVyc1trZXldID0gX2dldEtleVJlc29sdmVyKGtleSkpO1xuICAgIHJldHVybiByZXNvbHZlcihvYmopO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5jb25zdCBkZWZpbmVkID0gKHZhbHVlKT0+dHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpPT50eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzExMjg4NTUvY29tcGFyaW5nLWVjbWE2LXNldHMtZm9yLWVxdWFsaXR5IzMxMTI5Mzg0XG5jb25zdCBzZXRzRXF1YWwgPSAoYSwgYik9PntcbiAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSl7XG4gICAgICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIEBwYXJhbSBlIC0gVGhlIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZSkge1xuICAgIHJldHVybiBlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAnY29udGV4dG1lbnUnO1xufVxuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm1hdGhcbiAqIEBuYW1lc3BhY2VcbiAqLyBjb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBUQVUgPSAyICogUEk7XG5jb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5jb25zdCBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xuY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5jb25zdCBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcbmNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcbmNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBhbG1vc3RFcXVhbHMoeCwgeSwgZXBzaWxvbikge1xuICAgIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuICovIGZ1bmN0aW9uIG5pY2VOdW0ocmFuZ2UpIHtcbiAgICBjb25zdCByb3VuZGVkUmFuZ2UgPSBNYXRoLnJvdW5kKHJhbmdlKTtcbiAgICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gICAgY29uc3QgbmljZVJhbmdlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAocmFuZ2UpKSk7XG4gICAgY29uc3QgZnJhY3Rpb24gPSByYW5nZSAvIG5pY2VSYW5nZTtcbiAgICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgICByZXR1cm4gbmljZUZyYWN0aW9uICogbmljZVJhbmdlO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZhY3RvcnMgc29ydGVkIGZyb20gMSB0byBzcXJ0KHZhbHVlKVxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfZmFjdG9yaXplKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XG4gICAgbGV0IGk7XG4gICAgZm9yKGkgPSAxOyBpIDwgc3FydDsgaSsrKXtcbiAgICAgICAgaWYgKHZhbHVlICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSAvIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHNxcnQpO1xuICAgIH1cbiAgICByZXN1bHQuc29ydCgoYSwgYik9PmEgLSBiKS5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5mdW5jdGlvbiBhbG1vc3RXaG9sZSh4LCBlcHNpbG9uKSB7XG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG4gICAgcmV0dXJuIHJvdW5kZWQgLSBlcHNpbG9uIDw9IHggJiYgcm91bmRlZCArIGVwc2lsb24gPj0geDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfc2V0TWluQW5kTWF4QnlLZXkoYXJyYXksIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gICAgZm9yKGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKXtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpXVtwcm9wZXJ0eV07XG4gICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqICgxODAgLyBQSSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogaS5lLiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgb2YgdGhlIHZhbHVlIG9mIHRoaXMgTnVtYmVyLlxuICogQHBhcmFtIHggLSBBIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9kZWNpbWFsUGxhY2VzKHgpIHtcbiAgICBpZiAoIWlzTnVtYmVyRmluaXRlKHgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGUgPSAxO1xuICAgIGxldCBwID0gMDtcbiAgICB3aGlsZShNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpe1xuICAgICAgICBlICo9IDEwO1xuICAgICAgICBwKys7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLy8gR2V0cyB0aGUgYW5nbGUgZnJvbSB2ZXJ0aWNhbCB1cHJpZ2h0IHRvIHRoZSBwb2ludCBhYm91dCBhIGNlbnRyZS5cbmZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KGNlbnRyZVBvaW50LCBhbmdsZVBvaW50KSB7XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG4gICAgY29uc3QgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG4gICAgaWYgKGFuZ2xlIDwgLTAuNSAqIFBJKSB7XG4gICAgICAgIGFuZ2xlICs9IFRBVTsgLy8gbWFrZSBzdXJlIHRoZSByZXR1cm5lZCBhbmdsZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgKC1QSS8yLCAzUEkvMl1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYW5nbGUsXG4gICAgICAgIGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MSwgcHQyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cbi8qKlxuICogU2hvcnRlc3QgZGlzdGFuY2UgYmV0d2VlbiBhbmdsZXMsIGluIGVpdGhlciBkaXJlY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9hbmdsZURpZmYoYSwgYikge1xuICAgIHJldHVybiAoYSAtIGIgKyBQSVRBVSkgJSBUQVUgLSBQSTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGFuZ2xlIHRvIGJlIGJldHdlZW4gMCBhbmQgMipQSVxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfbm9ybWFsaXplQW5nbGUoYSkge1xuICAgIHJldHVybiAoYSAlIFRBVSArIFRBVSkgJSBUQVU7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnQsIGVuZCwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlKSB7XG4gICAgY29uc3QgYSA9IF9ub3JtYWxpemVBbmdsZShhbmdsZSk7XG4gICAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICAgIGNvbnN0IGFuZ2xlVG9TdGFydCA9IF9ub3JtYWxpemVBbmdsZShzIC0gYSk7XG4gICAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gICAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgICBjb25zdCBlbmRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBlKTtcbiAgICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlIHx8IGFuZ2xlVG9TdGFydCA+IGFuZ2xlVG9FbmQgJiYgc3RhcnRUb0FuZ2xlIDwgZW5kVG9BbmdsZTtcbn1cbi8qKlxuICogTGltaXQgYHZhbHVlYCBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gbWluXG4gKiBAcGFyYW0gbWF4XG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbn1cbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gc3RhcnRcbiAqIEBwYXJhbSBlbmRcbiAqIEBwYXJhbSBbZXBzaWxvbl1cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZSwgc3RhcnQsIGVuZCwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgICByZXR1cm4gdmFsdWUgPj0gTWF0aC5taW4oc3RhcnQsIGVuZCkgLSBlcHNpbG9uICYmIHZhbHVlIDw9IE1hdGgubWF4KHN0YXJ0LCBlbmQpICsgZXBzaWxvbjtcbn1cblxuZnVuY3Rpb24gX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGNtcCkge1xuICAgIGNtcCA9IGNtcCB8fCAoKGluZGV4KT0+dGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICAgIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gICAgbGV0IGxvID0gMDtcbiAgICBsZXQgbWlkO1xuICAgIHdoaWxlKGhpIC0gbG8gPiAxKXtcbiAgICAgICAgbWlkID0gbG8gKyBoaSA+PiAxO1xuICAgICAgICBpZiAoY21wKG1pZCkpIHtcbiAgICAgICAgICAgIGxvID0gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG8sXG4gICAgICAgIGhpXG4gICAgfTtcbn1cbi8qKlxuICogQmluYXJ5IHNlYXJjaFxuICogQHBhcmFtIHRhYmxlIC0gdGhlIHRhYmxlIHNlYXJjaC4gbXVzdCBiZSBzb3J0ZWQhXG4gKiBAcGFyYW0ga2V5IC0gcHJvcGVydHkgbmFtZSBmb3IgdGhlIHZhbHVlIGluIGVhY2ggZW50cnlcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSBsYXN0IC0gbG9va3VwIGxhc3QgaW5kZXhcbiAqIEBwcml2YXRlXG4gKi8gY29uc3QgX2xvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlLCBsYXN0KT0+X2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3QgPyAoaW5kZXgpPT57XG4gICAgICAgIGNvbnN0IHRpID0gdGFibGVbaW5kZXhdW2tleV07XG4gICAgICAgIHJldHVybiB0aSA8IHZhbHVlIHx8IHRpID09PSB2YWx1ZSAmJiB0YWJsZVtpbmRleCArIDFdW2tleV0gPT09IHZhbHVlO1xuICAgIH0gOiAoaW5kZXgpPT50YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcbi8qKlxuICogUmV2ZXJzZSBiaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSBrZXkgLSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgdmFsdWUgaW4gZWFjaCBlbnRyeVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHByaXZhdGVcbiAqLyBjb25zdCBfcmxvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlKT0+X2xvb2t1cCh0YWJsZSwgdmFsdWUsIChpbmRleCk9PnRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcbi8qKlxuICogUmV0dXJuIHN1YnNldCBvZiBgdmFsdWVzYCBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCBpbmNsdXNpdmUuXG4gKiBWYWx1ZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gc29ydGVkIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlcyAtIHNvcnRlZCBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSBtaW4gLSBtaW4gdmFsdWVcbiAqIEBwYXJhbSBtYXggLSBtYXggdmFsdWVcbiAqLyBmdW5jdGlvbiBfZmlsdGVyQmV0d2Vlbih2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gdmFsdWVzLmxlbmd0aDtcbiAgICB3aGlsZShzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKXtcbiAgICAgICAgc3RhcnQrKztcbiAgICB9XG4gICAgd2hpbGUoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KXtcbiAgICAgICAgZW5kLS07XG4gICAgfVxuICAgIHJldHVybiBzdGFydCA+IDAgfHwgZW5kIDwgdmFsdWVzLmxlbmd0aCA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKSA6IHZhbHVlcztcbn1cbmNvbnN0IGFycmF5RXZlbnRzID0gW1xuICAgICdwdXNoJyxcbiAgICAncG9wJyxcbiAgICAnc2hpZnQnLFxuICAgICdzcGxpY2UnLFxuICAgICd1bnNoaWZ0J1xuXTtcbmZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICAgIGlmIChhcnJheS5fY2hhcnRqcykge1xuICAgICAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBsaXN0ZW5lcnM6IFtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lclxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgICAgICBjb25zdCBiYXNlID0gYXJyYXlba2V5XTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWUgKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5mb3JFYWNoKChvYmplY3QpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHN0dWIgPSBhcnJheS5fY2hhcnRqcztcbiAgICBpZiAoIXN0dWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICAgIH0pO1xuICAgIGRlbGV0ZSBhcnJheS5fY2hhcnRqcztcbn1cbi8qKlxuICogQHBhcmFtIGl0ZW1zXG4gKi8gZnVuY3Rpb24gX2FycmF5VW5pcXVlKGl0ZW1zKSB7XG4gICAgY29uc3Qgc2V0ID0gbmV3IFNldChpdGVtcyk7XG4gICAgaWYgKHNldC5zaXplID09PSBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuXG5mdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KSB7XG4gICAgcmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcbn1cbi8qKlxuKiBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbFxuKi8gY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbn0oKTtcbi8qKlxuICogVGhyb3R0bGVzIGNhbGxpbmcgYGZuYCBvbmNlIHBlciBhbmltYXRpb24gZnJhbWVcbiAqIExhdGVzdCBhcmd1bWVudHMgYXJlIHVzZWQgb24gdGhlIGFjdHVhbCBjYWxsXG4gKi8gZnVuY3Rpb24gdGhyb3R0bGVkKGZuLCB0aGlzQXJnKSB7XG4gICAgbGV0IGFyZ3NUb1VzZSA9IFtdO1xuICAgIGxldCB0aWNraW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gU2F2ZSB0aGUgYXJncyBmb3IgdXNlIGxhdGVyXG4gICAgICAgIGFyZ3NUb1VzZSA9IGFyZ3M7XG4gICAgICAgIGlmICghdGlja2luZykge1xuICAgICAgICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKT0+e1xuICAgICAgICAgICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmdzVG9Vc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBEZWJvdW5jZXMgY2FsbGluZyBgZm5gIGZvciBgZGVsYXlgIG1zXG4gKi8gZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXksIGFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzICdzdGFydCcgdG8gJ2xlZnQnLCAnZW5kJyB0byAncmlnaHQnIGFuZCBvdGhlcnMgdG8gJ2NlbnRlcidcbiAqIEBwcml2YXRlXG4gKi8gY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduKT0+YWxpZ24gPT09ICdzdGFydCcgPyAnbGVmdCcgOiBhbGlnbiA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG4vKipcbiAqIFJldHVybnMgYHN0YXJ0YCwgYGVuZGAgb3IgYChzdGFydCArIGVuZCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGNlbnRlcmBcbiAqIEBwcml2YXRlXG4gKi8gY29uc3QgX2FsaWduU3RhcnRFbmQgPSAoYWxpZ24sIHN0YXJ0LCBlbmQpPT5hbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG4vKipcbiAqIFJldHVybnMgYGxlZnRgLCBgcmlnaHRgIG9yIGAobGVmdCArIHJpZ2h0KSAvIDJgIGRlcGVuZGluZyBvbiBgYWxpZ25gLiBEZWZhdWx0cyB0byBgbGVmdGBcbiAqIEBwcml2YXRlXG4gKi8gY29uc3QgX3RleHRYID0gKGFsaWduLCBsZWZ0LCByaWdodCwgcnRsKT0+e1xuICAgIGNvbnN0IGNoZWNrID0gcnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcbi8qKlxuICogUmV0dXJuIHN0YXJ0IGFuZCBjb3VudCBvZiB2aXNpYmxlIHBvaW50cy5cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBjb3VudCA9IHBvaW50Q291bnQ7XG4gICAgaWYgKG1ldGEuX3NvcnRlZCkge1xuICAgICAgICBjb25zdCB7IGlTY2FsZSAsIF9wYXJzZWQgIH0gPSBtZXRhO1xuICAgICAgICBjb25zdCBheGlzID0gaVNjYWxlLmF4aXM7XG4gICAgICAgIGNvbnN0IHsgbWluICwgbWF4ICwgbWluRGVmaW5lZCAsIG1heERlZmluZWQgIH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICAgICAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShNYXRoLm1pbigvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgYXhpcywgbWluKS5sbywgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIGZpeCB0eXBlcyBvbiBfbG9va3VwQnlLZXlcbiAgICAgICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyksIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShNYXRoLm1heCgvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCwgdHJ1ZSkuaGkgKyAxLCAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gZml4IHR5cGVzIG9uIF9sb29rdXBCeUtleVxuICAgICAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCksIHRydWUpLmhpICsgMSksIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGNvdW50XG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzY2FsZSByYW5nZXMgaGF2ZSBjaGFuZ2VkLlxuICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGEuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gICAgY29uc3QgeyB4U2NhbGUgLCB5U2NhbGUgLCBfc2NhbGVSYW5nZXMgIH0gPSBtZXRhO1xuICAgIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICAgICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICAgICAgeG1heDogeFNjYWxlLm1heCxcbiAgICAgICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICAgICAgeW1heDogeVNjYWxlLm1heFxuICAgIH07XG4gICAgaWYgKCFfc2NhbGVSYW5nZXMpIHtcbiAgICAgICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gX3NjYWxlUmFuZ2VzLnhtaW4gIT09IHhTY2FsZS5taW4gfHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXggfHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW4gfHwgX3NjYWxlUmFuZ2VzLnltYXggIT09IHlTY2FsZS5tYXg7XG4gICAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbmNvbnN0IGF0RWRnZSA9ICh0KT0+dCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQsIHMsIHApPT4tKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodCwgcywgcCk9Pk1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApICsgMTtcbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnMuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nLmVmZmVjdHNcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cbiAqLyBjb25zdCBlZmZlY3RzID0ge1xuICAgIGxpbmVhcjogKHQpPT50LFxuICAgIGVhc2VJblF1YWQ6ICh0KT0+dCAqIHQsXG4gICAgZWFzZU91dFF1YWQ6ICh0KT0+LXQgKiAodCAtIDIpLFxuICAgIGVhc2VJbk91dFF1YWQ6ICh0KT0+KHQgLz0gMC41KSA8IDEgPyAwLjUgKiB0ICogdCA6IC0wLjUgKiAoLS10ICogKHQgLSAyKSAtIDEpLFxuICAgIGVhc2VJbkN1YmljOiAodCk9PnQgKiB0ICogdCxcbiAgICBlYXNlT3V0Q3ViaWM6ICh0KT0+KHQgLT0gMSkgKiB0ICogdCArIDEsXG4gICAgZWFzZUluT3V0Q3ViaWM6ICh0KT0+KHQgLz0gMC41KSA8IDEgPyAwLjUgKiB0ICogdCAqIHQgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuICAgIGVhc2VJblF1YXJ0OiAodCk9PnQgKiB0ICogdCAqIHQsXG4gICAgZWFzZU91dFF1YXJ0OiAodCk9Pi0oKHQgLT0gMSkgKiB0ICogdCAqIHQgLSAxKSxcbiAgICBlYXNlSW5PdXRRdWFydDogKHQpPT4odCAvPSAwLjUpIDwgMSA/IDAuNSAqIHQgKiB0ICogdCAqIHQgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG4gICAgZWFzZUluUXVpbnQ6ICh0KT0+dCAqIHQgKiB0ICogdCAqIHQsXG4gICAgZWFzZU91dFF1aW50OiAodCk9Pih0IC09IDEpICogdCAqIHQgKiB0ICogdCArIDEsXG4gICAgZWFzZUluT3V0UXVpbnQ6ICh0KT0+KHQgLz0gMC41KSA8IDEgPyAwLjUgKiB0ICogdCAqIHQgKiB0ICogdCA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcbiAgICBlYXNlSW5TaW5lOiAodCk9Pi1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxuICAgIGVhc2VPdXRTaW5lOiAodCk9Pk1hdGguc2luKHQgKiBIQUxGX1BJKSxcbiAgICBlYXNlSW5PdXRTaW5lOiAodCk9Pi0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuICAgIGVhc2VJbkV4cG86ICh0KT0+dCA9PT0gMCA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuICAgIGVhc2VPdXRFeHBvOiAodCk9PnQgPT09IDEgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcbiAgICBlYXNlSW5PdXRFeHBvOiAodCk9PmF0RWRnZSh0KSA/IHQgOiB0IDwgMC41ID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSkgOiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqICh0ICogMiAtIDEpKSArIDIpLFxuICAgIGVhc2VJbkNpcmM6ICh0KT0+dCA+PSAxID8gdCA6IC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSxcbiAgICBlYXNlT3V0Q2lyYzogKHQpPT5NYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG4gICAgZWFzZUluT3V0Q2lyYzogKHQpPT4odCAvPSAwLjUpIDwgMSA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcbiAgICBlYXNlSW5FbGFzdGljOiAodCk9PmF0RWRnZSh0KSA/IHQgOiBlbGFzdGljSW4odCwgMC4wNzUsIDAuMyksXG4gICAgZWFzZU91dEVsYXN0aWM6ICh0KT0+YXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG4gICAgZWFzZUluT3V0RWxhc3RpYyAodCkge1xuICAgICAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgICAgICBjb25zdCBwID0gMC40NTtcbiAgICAgICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOiB0IDwgMC41ID8gMC41ICogZWxhc3RpY0luKHQgKiAyLCBzLCBwKSA6IDAuNSArIDAuNSAqIGVsYXN0aWNPdXQodCAqIDIgLSAxLCBzLCBwKTtcbiAgICB9LFxuICAgIGVhc2VJbkJhY2sgKHQpIHtcbiAgICAgICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICAgIH0sXG4gICAgZWFzZU91dEJhY2sgKHQpIHtcbiAgICAgICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiAodCAtPSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRCYWNrICh0KSB7XG4gICAgICAgIGxldCBzID0gMS43MDE1ODtcbiAgICAgICAgaWYgKCh0IC89IDAuNSkgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKCgocyAqPSAxLjUyNSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9IDEuNTI1KSArIDEpICogdCArIHMpICsgMik7XG4gICAgfSxcbiAgICBlYXNlSW5Cb3VuY2U6ICh0KT0+MSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG4gICAgZWFzZU91dEJvdW5jZSAodCkge1xuICAgICAgICBjb25zdCBtID0gNy41NjI1O1xuICAgICAgICBjb25zdCBkID0gMi43NTtcbiAgICAgICAgaWYgKHQgPCAxIC8gZCkge1xuICAgICAgICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA8IDIgLyBkKSB7XG4gICAgICAgICAgICByZXR1cm4gbSAqICh0IC09IDEuNSAvIGQpICogdCArIDAuNzU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPCAyLjUgLyBkKSB7XG4gICAgICAgICAgICByZXR1cm4gbSAqICh0IC09IDIuMjUgLyBkKSAqIHQgKyAwLjkzNzU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0gKiAodCAtPSAyLjYyNSAvIGQpICogdCArIDAuOTg0Mzc1O1xuICAgIH0sXG4gICAgZWFzZUluT3V0Qm91bmNlOiAodCk9PnQgPCAwLjUgPyBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjUgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNVxufTtcblxuZnVuY3Rpb24gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpID8gdmFsdWUgOiBuZXcgQ29sb3IodmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZSkge1xuICAgIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogbmV3IENvbG9yKHZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxuXG5jb25zdCBudW1iZXJzID0gW1xuICAgICd4JyxcbiAgICAneScsXG4gICAgJ2JvcmRlcldpZHRoJyxcbiAgICAncmFkaXVzJyxcbiAgICAndGVuc2lvbidcbl07XG5jb25zdCBjb2xvcnMgPSBbXG4gICAgJ2NvbG9yJyxcbiAgICAnYm9yZGVyQ29sb3InLFxuICAgICdiYWNrZ3JvdW5kQ29sb3InXG5dO1xuZnVuY3Rpb24gYXBwbHlBbmltYXRpb25zRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgICAgICAgZGVsYXk6IHVuZGVmaW5lZCxcbiAgICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgICAgIGZuOiB1bmRlZmluZWQsXG4gICAgICAgIGZyb206IHVuZGVmaW5lZCxcbiAgICAgICAgbG9vcDogdW5kZWZpbmVkLFxuICAgICAgICB0bzogdW5kZWZpbmVkLFxuICAgICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICAgICAgICBfZmFsbGJhY2s6IGZhbHNlLFxuICAgICAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICAgICAgX3NjcmlwdGFibGU6IChuYW1lKT0+bmFtZSAhPT0gJ29uUHJvZ3Jlc3MnICYmIG5hbWUgIT09ICdvbkNvbXBsZXRlJyAmJiBuYW1lICE9PSAnZm4nXG4gICAgfSk7XG4gICAgZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyczoge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBudW1iZXJzXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9ucycsIHtcbiAgICAgICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJ1xuICAgIH0pO1xuICAgIGRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDQwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXNpemU6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3c6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoaWRlOiB7XG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgICAgICAgICAgICAgZm46ICh2KT0+diB8IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlMYXlvdXRzRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgICBkZWZhdWx0cy5zZXQoJ2xheW91dCcsIHtcbiAgICAgICAgYXV0b1BhZGRpbmc6IHRydWUsXG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICAgIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWZvcm1hdHRlcikge1xuICAgICAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICAgICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlcjtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW0sIGxvY2FsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cblxuY29uc3QgZm9ybWF0dGVycyA9IHtcbiB2YWx1ZXMgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/ICB2YWx1ZSA6ICcnICsgdmFsdWU7XG4gICAgfSxcbiBudW1lcmljICh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgICAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGU7XG4gICAgICAgIGxldCBub3RhdGlvbjtcbiAgICAgICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlO1xuICAgICAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdLnZhbHVlKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgICAgICAgIGlmIChtYXhUaWNrIDwgMWUtNCB8fCBtYXhUaWNrID4gMWUrMTUpIHtcbiAgICAgICAgICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbHRhID0gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuICAgICAgICBjb25zdCBudW1EZWNpbWFsID0gaXNOYU4obG9nRGVsdGEpID8gMSA6IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSksIDIwKSwgMCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBub3RhdGlvbixcbiAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCxcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgICB9LFxuIGxvZ2FyaXRobWljICh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgICAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tzW2luZGV4XS5zaWduaWZpY2FuZCB8fCB0aWNrVmFsdWUgLyBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSk7XG4gICAgICAgIGlmIChbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMixcbiAgICAgICAgICAgIDMsXG4gICAgICAgICAgICA1LFxuICAgICAgICAgICAgMTAsXG4gICAgICAgICAgICAxNVxuICAgICAgICBdLmluY2x1ZGVzKHJlbWFpbikgfHwgaW5kZXggPiAwLjggKiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWVyaWMuY2FsbCh0aGlzLCB0aWNrVmFsdWUsIGluZGV4LCB0aWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKSB7XG4gICAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgICAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbHRhO1xufVxuIHZhciBUaWNrcyA9IHtcbiAgICBmb3JtYXR0ZXJzXG59O1xuXG5mdW5jdGlvbiBhcHBseVNjYWxlRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgICBkZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBmYWxzZSxcbiAgICAgICAgYmVnaW5BdFplcm86IGZhbHNlLFxuIGJvdW5kczogJ3RpY2tzJyxcbiAgICAgICAgY2xpcDogdHJ1ZSxcbiBncmFjZTogMCxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcbiAgICAgICAgICAgIGRyYXdUaWNrczogdHJ1ZSxcbiAgICAgICAgICAgIHRpY2tMZW5ndGg6IDgsXG4gICAgICAgICAgICB0aWNrV2lkdGg6IChfY3R4LCBvcHRpb25zKT0+b3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICAgICAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKT0+b3B0aW9ucy5jb2xvcixcbiAgICAgICAgICAgIG9mZnNldDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgYm9yZGVyOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgZGFzaDogW10sXG4gICAgICAgICAgICBkYXNoT2Zmc2V0OiAwLjAsXG4gICAgICAgICAgICB3aWR0aDogMVxuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgICB0b3A6IDQsXG4gICAgICAgICAgICAgICAgYm90dG9tOiA0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgICAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgICAgICAgIG1pcnJvcjogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgICAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgICAgICAgICAgcGFkZGluZzogMyxcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgICAgICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICAgICAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuICAgICAgICAgICAgbWlub3I6IHt9LFxuICAgICAgICAgICAgbWFqb3I6IHt9LFxuICAgICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgY3Jvc3NBbGlnbjogJ25lYXInLFxuICAgICAgICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6IGZhbHNlLFxuICAgICAgICAgICAgYmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgICAgICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGlja3MnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG4gICAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gICAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmJvcmRlcicsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbiAgICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGl0bGUnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlJywge1xuICAgICAgICBfZmFsbGJhY2s6IGZhbHNlLFxuICAgICAgICBfc2NyaXB0YWJsZTogKG5hbWUpPT4hbmFtZS5zdGFydHNXaXRoKCdiZWZvcmUnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdhZnRlcicpICYmIG5hbWUgIT09ICdjYWxsYmFjaycgJiYgbmFtZSAhPT0gJ3BhcnNlcicsXG4gICAgICAgIF9pbmRleGFibGU6IChuYW1lKT0+bmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2Rhc2gnXG4gICAgfSk7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlcycsIHtcbiAgICAgICAgX2ZhbGxiYWNrOiAnc2NhbGUnXG4gICAgfSk7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICAgICAgICBfc2NyaXB0YWJsZTogKG5hbWUpPT5uYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxuICAgICAgICBfaW5kZXhhYmxlOiAobmFtZSk9Pm5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnXG4gICAgfSk7XG59XG5cbmNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gZnVuY3Rpb24gZ2V0U2NvcGUkMShub2RlLCBrZXkpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgIGZvcihsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSl7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgICAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlJDEocm9vdCwgc2NvcGUpLCB2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCAnJyksIHNjb3BlKTtcbn1cbiBjbGFzcyBEZWZhdWx0cyB7XG4gICAgY29uc3RydWN0b3IoX2Rlc2NyaXB0b3JzLCBfYXBwbGllcnMpe1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgICAgICB0aGlzLmNvbG9yID0gJyM2NjYnO1xuICAgICAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KT0+Y29udGV4dC5jaGFydC5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAgICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICdtb3VzZW91dCcsXG4gICAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgJ3RvdWNobW92ZSdcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5mb250ID0ge1xuICAgICAgICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgICAgICAgIHdlaWdodDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhvdmVyID0ge307XG4gICAgICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKT0+Z2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIHRoaXMuaG92ZXJCb3JkZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpPT5nZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgICAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKT0+Z2V0SG92ZXJDb2xvcihvcHRpb25zLmNvbG9yKTtcbiAgICAgICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICAgICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICAgICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgICAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICAgICAgdGhpcy5yZXNwb25zaXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5zaG93TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlc2NyaWJlKF9kZXNjcmlwdG9ycyk7XG4gICAgICAgIHRoaXMuYXBwbHkoX2FwcGxpZXJzKTtcbiAgICB9XG4gc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgICB9XG4gZ2V0KHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgICB9XG4gZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgICB9XG4gICAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gICAgfVxuIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICAgICAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgICAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICAgICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW25hbWVdOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXNbcHJpdmF0ZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBseShhcHBsaWVycykge1xuICAgICAgICBhcHBsaWVycy5mb3JFYWNoKChhcHBseSk9PmFwcGx5KHRoaXMpKTtcbiAgICB9XG59XG52YXIgZGVmYXVsdHMgPSAvKiAjX19QVVJFX18gKi8gbmV3IERlZmF1bHRzKHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpPT4hbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIF9pbmRleGFibGU6IChuYW1lKT0+bmFtZSAhPT0gJ2V2ZW50cycsXG4gICAgaG92ZXI6IHtcbiAgICAgICAgX2ZhbGxiYWNrOiAnaW50ZXJhY3Rpb24nXG4gICAgfSxcbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgICAgIF9pbmRleGFibGU6IGZhbHNlXG4gICAgfVxufSwgW1xuICAgIGFwcGx5QW5pbWF0aW9uc0RlZmF1bHRzLFxuICAgIGFwcGx5TGF5b3V0c0RlZmF1bHRzLFxuICAgIGFwcGx5U2NhbGVEZWZhdWx0c1xuXSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgb2JqZWN0IGludG8gYSBDU1MgZm9udCBzdHJpbmcuXG4gKiBAcGFyYW0gZm9udCAtIEEgZm9udCBvYmplY3QuXG4gKiBAcmV0dXJuIFRoZSBDU1MgZm9udCBzdHJpbmcuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udCkge1xuICAgIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJykgKyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKSArIGZvbnQuc2l6ZSArICdweCAnICsgZm9udC5mYW1pbHk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuICAgIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gICAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICAgICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgICAgIGdjLnB1c2goc3RyaW5nKTtcbiAgICB9XG4gICAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICAgICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIGxvbmdlc3Q7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIF9sb25nZXN0VGV4dChjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG4gICAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgICBsZXQgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuICAgIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG4gICAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICAgICAgZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcbiAgICAgICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgICAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgICBsZXQgaSwgaiwgamxlbiwgdGhpbmcsIG5lc3RlZFRoaW5nO1xuICAgIGZvcihpID0gMDsgaSA8IGlsZW47IGkrKyl7XG4gICAgICAgIHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcbiAgICAgICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KHRoaW5nKSkge1xuICAgICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cbiAgICAgICAgICAgIGZvcihqID0gMCwgamxlbiA9IHRoaW5nLmxlbmd0aDsgaiA8IGpsZW47IGorKyl7XG4gICAgICAgICAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgICAgICAgICBpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheShuZXN0ZWRUaGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGdjTGVuOyBpKyspe1xuICAgICAgICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgfVxuICAgIHJldHVybiBsb25nZXN0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuICogQHBhcmFtIGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuICogQHBhcmFtIHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cbiAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIHdpZHRoKSB7XG4gICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuICAgIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuLyoqXG4gKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMuXG4gKi8gZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpIHtcbiAgICBjdHggPSBjdHggfHwgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICAvLyBjYW52YXMud2lkdGggYW5kIGNhbnZhcy5oZWlnaHQgZG8gbm90IGNvbnNpZGVyIHRoZSBjYW52YXMgdHJhbnNmb3JtLFxuICAgIC8vIHdoaWxlIGNsZWFyUmVjdCBkb2VzXG4gICAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB4LCB5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIGRyYXdQb2ludExlZ2VuZChjdHgsIG9wdGlvbnMsIHgsIHksIG51bGwpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIGRyYXdQb2ludExlZ2VuZChjdHgsIG9wdGlvbnMsIHgsIHksIHcpIHtcbiAgICBsZXQgdHlwZSwgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgY29ybmVyUmFkaXVzLCB3aWR0aCwgeE9mZnNldFcsIHlPZmZzZXRXO1xuICAgIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbjtcbiAgICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG4gICAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHJhZCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIHN3aXRjaChzdHlsZSl7XG4gICAgICAgIC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAodykge1xuICAgICAgICAgICAgICAgIGN0eC5lbGxpcHNlKHgsIHksIHcgLyAyLCByYWRpdXMsIDAsIDAsIFRBVSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBUQVUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgICAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogcmFkaXVzO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICAgICAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZWN0Um91bmRlZCc6XG4gICAgICAgICAgICAvLyBOT1RFOiB0aGUgcm91bmRlZCByZWN0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgdG8gdXNlIGBhcmNgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgIC8vIGBxdWFkcmF0aWNDdXJ2ZVRvYCBzaW5jZSBpdCBnZW5lcmF0ZXMgYmV0dGVyIHJlc3VsdHMgd2hlbiByZWN0IGlzXG4gICAgICAgICAgICAvLyBhbG1vc3QgYSBjaXJjbGUuIDAuNTE2IChpbnN0ZWFkIG9mIDAuNSkgcHJvZHVjZXMgcmVzdWx0cyB3aXRoIHZpc3VhbGx5XG4gICAgICAgICAgICAvLyBjbG9zZXIgcHJvcG9ydGlvbiB0byB0aGUgcHJldmlvdXMgaW1wbCBhbmQgaXQgaXMgaW5zY3JpYmVkIGluIHRoZVxuICAgICAgICAgICAgLy8gY2lyY2xlIHdpdGggYHJhZGl1c2AuIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGUgZm9sbG93aW5nIFBSczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81NTk3XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTg1OFxuICAgICAgICAgICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgICAgICAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuICAgICAgICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgICAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgICAgICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqICh3ID8gdyAvIDIgLSBjb3JuZXJSYWRpdXMgOiBzaXplKTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG4gICAgICAgICAgICBjdHguYXJjKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZWN0JzpcbiAgICAgICAgICAgIGlmICghcm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogc2l6ZTtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCh4IC0gd2lkdGgsIHkgLSBzaXplLCAyICogd2lkdGgsIDIgKiBzaXplKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovIGNhc2UgJ3JlY3RSb3QnOlxuICAgICAgICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICAgICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgICAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICAgICAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovIGNhc2UgJ2Nyb3NzJzpcbiAgICAgICAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgICAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdGFyJzpcbiAgICAgICAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgICAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgICAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgICAgICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICAgICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgICAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgICAgeE9mZnNldCA9IHcgPyB3IC8gMiA6IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkYXNoJzpcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyksIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGN0eC5maWxsKCk7XG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0gYXJlYSAtIFRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSBtYXJnaW4gLSBhbGxvd2VkIG1hcmdpblxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfaXNQb2ludEluQXJlYShwb2ludCwgYXJlYSwgbWFyZ2luKSB7XG4gICAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTsgLy8gbWFyZ2luIC0gZGVmYXVsdCBpcyB0byBtYXRjaCByb3VuZGVkIGRlY2ltYWxzXG4gICAgcmV0dXJuICFhcmVhIHx8IHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiYgcG9pbnQueSA+IGFyZWEudG9wIC0gbWFyZ2luICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIG1hcmdpbjtcbn1cbmZ1bmN0aW9uIGNsaXBBcmVhKGN0eCwgYXJlYSkge1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICAgIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB1bmNsaXBBcmVhKGN0eCkge1xuICAgIGN0eC5yZXN0b3JlKCk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX3N0ZXBwZWRMaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwLCBtb2RlKSB7XG4gICAgaWYgKCFwcmV2aW91cykge1xuICAgICAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgY29uc3QgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcbiAgICAgICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgICAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgICB9XG4gICAgY3R4LmJlemllckN1cnZlVG8oZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LCBmbGlwID8gcHJldmlvdXMuY3AxeSA6IHByZXZpb3VzLmNwMnksIGZsaXAgPyB0YXJnZXQuY3AyeCA6IHRhcmdldC5jcDF4LCBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSwgdGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMudHJhbnNsYXRpb24pIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgICB9XG4gICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMucm90YXRpb24pKSB7XG4gICAgICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gICAgfVxuICAgIGlmIChvcHRzLmNvbG9yKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xuICAgIH1cbiAgICBpZiAob3B0cy50ZXh0QWxpZ24pIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICAgIH1cbiAgICBpZiAob3B0cy50ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpIHtcbiAgICBpZiAob3B0cy5zdHJpa2V0aHJvdWdoIHx8IG9wdHMudW5kZXJsaW5lKSB7XG4gICAgICAgIC8qKlxuICAgICAqIE5vdyB0aGF0IElFMTEgc3VwcG9ydCBoYXMgYmVlbiBkcm9wcGVkLCB3ZSBjYW4gdXNlIG1vcmVcbiAgICAgKiBvZiB0aGUgVGV4dE1ldHJpY3Mgb2JqZWN0LiBUaGUgYWN0dWFsIGJvdW5kaW5nIGJveGVzXG4gICAgICogYXJlIHVuZmxhZ2dlZCBpbiBDaHJvbWUsIEZpcmVmb3gsIEVkZ2UsIGFuZCBTYWZhcmkgc28gdGhleVxuICAgICAqIGNhbiBiZSBzYWZlbHkgdXNlZC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRNZXRyaWNzI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgICAqLyBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgICAgICBjb25zdCBsZWZ0ID0geCAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgICAgICBjb25zdCByaWdodCA9IHggKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XG4gICAgICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgICBjb25zdCBib3R0b20gPSB5ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgICAgIGNvbnN0IHlEZWNvcmF0aW9uID0gb3B0cy5zdHJpa2V0aHJvdWdoID8gKHRvcCArIGJvdHRvbSkgLyAyIDogYm90dG9tO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLmRlY29yYXRpb25XaWR0aCB8fCAyO1xuICAgICAgICBjdHgubW92ZVRvKGxlZnQsIHlEZWNvcmF0aW9uKTtcbiAgICAgICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZHJhd0JhY2tkcm9wKGN0eCwgb3B0cykge1xuICAgIGNvbnN0IG9sZENvbG9yID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgICBjdHguZmlsbFJlY3Qob3B0cy5sZWZ0LCBvcHRzLnRvcCwgb3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvbGRDb2xvcjtcbn1cbi8qKlxuICogUmVuZGVyIHRleHQgb250byB0aGUgY2FudmFzXG4gKi8gZnVuY3Rpb24gcmVuZGVyVGV4dChjdHgsIHRleHQsIHgsIHksIGZvbnQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbXG4gICAgICAgIHRleHRcbiAgICBdO1xuICAgIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICAgIGxldCBpLCBsaW5lO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgICBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cyk7XG4gICAgZm9yKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICBsaW5lID0gbGluZXNbaV07XG4gICAgICAgIGlmIChvcHRzLmJhY2tkcm9wKSB7XG4gICAgICAgICAgICBkcmF3QmFja2Ryb3AoY3R4LCBvcHRzLmJhY2tkcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdHMuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5zdHJva2VXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICAgICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG4gICAgICAgIHkgKz0gTnVtYmVyKGZvbnQubGluZUhlaWdodCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG59XG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0gcmVjdCAtIEJvdW5kaW5nIHJlY3RcbiAqLyBmdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gICAgY29uc3QgeyB4ICwgeSAsIHcgLCBoICwgcmFkaXVzICB9ID0gcmVjdDtcbiAgICAvLyB0b3AgbGVmdCBhcmNcbiAgICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgMS41ICogUEksIFBJLCB0cnVlKTtcbiAgICAvLyBsaW5lIGZyb20gdG9wIGxlZnQgdG8gYm90dG9tIGxlZnRcbiAgICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuICAgIC8vIGJvdHRvbSBsZWZ0IGFyY1xuICAgIGN0eC5hcmMoeCArIHJhZGl1cy5ib3R0b21MZWZ0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0LCByYWRpdXMuYm90dG9tTGVmdCwgUEksIEhBTEZfUEksIHRydWUpO1xuICAgIC8vIGxpbmUgZnJvbSBib3R0b20gbGVmdCB0byBib3R0b20gcmlnaHRcbiAgICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG4gICAgLy8gYm90dG9tIHJpZ2h0IGFyY1xuICAgIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuICAgIC8vIGxpbmUgZnJvbSBib3R0b20gcmlnaHQgdG8gdG9wIHJpZ2h0XG4gICAgY3R4LmxpbmVUbyh4ICsgdywgeSArIHJhZGl1cy50b3BSaWdodCk7XG4gICAgLy8gdG9wIHJpZ2h0IGFyY1xuICAgIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuICAgIC8vIGxpbmUgZnJvbSB0b3AgcmlnaHQgdG8gdG9wIGxlZnRcbiAgICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC87XG5jb25zdCBGT05UX1NUWUxFID0gL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC87XG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm9wdGlvbnNcbiAqIEBuYW1lc3BhY2VcbiAqLyAvKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBsaW5lIGhlaWdodCBgdmFsdWVgIGluIHBpeGVscyBmb3IgYSBzcGVjaWZpYyBmb250IGBzaXplYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBsaW5lSGVpZ2h0IHRvIHBhcnNlIChlZy4gMS42LCAnMTRweCcsICc3NSUnLCAnMS42ZW0nKS5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cbiAqIEByZXR1cm5zIFRoZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgaW4gcGl4ZWxzIChzaXplICogMS4yIGlmIHZhbHVlIGlzIGludmFsaWQpLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGluZS1oZWlnaHRcbiAqIEBzaW5jZSAyLjcuMFxuICovIGZ1bmN0aW9uIHRvTGluZUhlaWdodCh2YWx1ZSwgc2l6ZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgICAgICByZXR1cm4gc2l6ZSAqIDEuMjtcbiAgICB9XG4gICAgdmFsdWUgPSArbWF0Y2hlc1syXTtcbiAgICBzd2l0Y2gobWF0Y2hlc1szXSl7XG4gICAgICAgIGNhc2UgJ3B4JzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cbmNvbnN0IG51bWJlck9yWmVybyA9ICh2KT0+K3YgfHwgMDtcbmZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBwcm9wcykge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGNvbnN0IG9ialByb3BzID0gaXNPYmplY3QocHJvcHMpO1xuICAgIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICAgIGNvbnN0IHJlYWQgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmpQcm9wcyA/IChwcm9wKT0+dmFsdWVPckRlZmF1bHQodmFsdWVbcHJvcF0sIHZhbHVlW3Byb3BzW3Byb3BdXSkgOiAocHJvcCk9PnZhbHVlW3Byb3BdIDogKCk9PnZhbHVlO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKXtcbiAgICAgICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvKHJlYWQocHJvcCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIFRSQkwgb2JqZWN0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpXG4gKiBAc2luY2UgMy4wLjBcbiAqLyBmdW5jdGlvbiB0b1RSQkwodmFsdWUpIHtcbiAgICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHtcbiAgICAgICAgdG9wOiAneScsXG4gICAgICAgIHJpZ2h0OiAneCcsXG4gICAgICAgIGJvdHRvbTogJ3knLFxuICAgICAgICBsZWZ0OiAneCdcbiAgICB9KTtcbn1cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIGNvcm5lcnMgb2JqZWN0IChzaW1pbGFyIHdpdGggY3NzIGJvcmRlci1yYWRpdXMpLlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29ybmVyIGNvbXBvbmVudHMsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiBAcmV0dXJucyBUaGUgVFJCTCBjb3JuZXIgdmFsdWVzICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpXG4gKiBAc2luY2UgMy4wLjBcbiAqLyBmdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbXG4gICAgICAgICd0b3BMZWZ0JyxcbiAgICAgICAgJ3RvcFJpZ2h0JyxcbiAgICAgICAgJ2JvdHRvbUxlZnQnLFxuICAgICAgICAnYm90dG9tUmlnaHQnXG4gICAgXSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgcGFkZGluZyBvYmplY3Qgd2l0aCBwcmUtY29tcHV0ZWQgd2lkdGgvaGVpZ2h0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXG4gKiBAc2luY2UgMi43LjBcbiAqLyBmdW5jdGlvbiB0b1BhZGRpbmcodmFsdWUpIHtcbiAgICBjb25zdCBvYmogPSB0b1RSQkwodmFsdWUpO1xuICAgIG9iai53aWR0aCA9IG9iai5sZWZ0ICsgb2JqLnJpZ2h0O1xuICAgIG9iai5oZWlnaHQgPSBvYmoudG9wICsgb2JqLmJvdHRvbTtcbiAgICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBQYXJzZXMgZm9udCBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb250IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmb250IG9wdGlvbnMgdG8gYmUgcGFyc2VkLlxuICogQHBhcmFtIGZhbGxiYWNrIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmYWxsYmFjayBmb250IG9wdGlvbnMuXG4gKiBAcmV0dXJuIFRoZSBmb250IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gdG9Gb250KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250O1xuICAgIGxldCBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zaXplLCBmYWxsYmFjay5zaXplKTtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gICAgfVxuICAgIGxldCBzdHlsZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc3R5bGUsIGZhbGxiYWNrLnN0eWxlKTtcbiAgICBpZiAoc3R5bGUgJiYgISgnJyArIHN0eWxlKS5tYXRjaChGT05UX1NUWUxFKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHN0eWxlICsgJ1wiJyk7XG4gICAgICAgIHN0eWxlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBmb250ID0ge1xuICAgICAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxuICAgICAgICBsaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBmYWxsYmFjay5saW5lSGVpZ2h0KSwgc2l6ZSksXG4gICAgICAgIHNpemUsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICB3ZWlnaHQ6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMud2VpZ2h0LCBmYWxsYmFjay53ZWlnaHQpLFxuICAgICAgICBzdHJpbmc6ICcnXG4gICAgfTtcbiAgICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgICByZXR1cm4gZm9udDtcbn1cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBnaXZlbiBgaW5wdXRzYCBzZXF1ZW50aWFsbHkgYW5kIHJldHVybnMgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWUuXG4gKiBAcGFyYW0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxuICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cbiAqIEBwYXJhbSBpbmRleCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGFuIGFycmF5LCB0aGUgdmFsdWVcbiAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5mbyAtIG9iamVjdCB0byByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgcmVzb2x1dGlvbiBpblxuICogQHBhcmFtIGluZm8uY2FjaGVhYmxlIC0gV2lsbCBiZSBzZXQgdG8gYGZhbHNlYCBpZiBvcHRpb24gaXMgbm90IGNhY2hlYWJsZS5cbiAqIEBzaW5jZSAyLjcuMFxuICovIGZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzLCBjb250ZXh0LCBpbmRleCwgaW5mbykge1xuICAgIGxldCBjYWNoZWFibGUgPSB0cnVlO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgICBmb3IoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgdmFsdWUgPSBpbnB1dHNbaV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcbiAgICAgICAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgICAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XG4gICAgICAgICAgICAgICAgaW5mby5jYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIG1pbm1heFxuICogQHBhcmFtIGdyYWNlXG4gKiBAcGFyYW0gYmVnaW5BdFplcm9cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heCwgZ3JhY2UsIGJlZ2luQXRaZXJvKSB7XG4gICAgY29uc3QgeyBtaW4gLCBtYXggIH0gPSBtaW5tYXg7XG4gICAgY29uc3QgY2hhbmdlID0gdG9EaW1lbnNpb24oZ3JhY2UsIChtYXggLSBtaW4pIC8gMik7XG4gICAgY29uc3Qga2VlcFplcm8gPSAodmFsdWUsIGFkZCk9PmJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjoga2VlcFplcm8obWluLCAtTWF0aC5hYnMoY2hhbmdlKSksXG4gICAgICAgIG1heDoga2VlcFplcm8obWF4LCBjaGFuZ2UpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dCwgY29udGV4dCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCksIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm94eSBmb3IgcmVzb2x2aW5nIHJhdyB2YWx1ZXMgZm9yIG9wdGlvbnMuXG4gKiBAcGFyYW0gc2NvcGVzIC0gVGhlIG9wdGlvbiBzY29wZXMgdG8gbG9vayBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyXG4gKiBAcGFyYW0gcHJlZml4ZXMgLSBUaGUgcHJlZml4ZXMgZm9yIHZhbHVlcywgaW4gcmVzb2x1dGlvbiBvcmRlci5cbiAqIEBwYXJhbSByb290U2NvcGVzIC0gVGhlIHJvb3Qgb3B0aW9uIHNjb3Blc1xuICogQHBhcmFtIGZhbGxiYWNrIC0gUGFyZW50IHNjb3BlcyBmYWxsYmFja1xuICogQHBhcmFtIGdldFRhcmdldCAtIGNhbGxiYWNrIGZvciBnZXR0aW5nIHRoZSB0YXJnZXQgZm9yIGNoYW5nZWQgdmFsdWVzXG4gKiBAcmV0dXJucyBQcm94eVxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyA9IFtcbiAgICAnJ1xuXSwgcm9vdFNjb3BlcywgZmFsbGJhY2ssIGdldFRhcmdldCA9ICgpPT5zY29wZXNbMF0pIHtcbiAgICBjb25zdCBmaW5hbFJvb3RTY29wZXMgPSByb290U2NvcGVzIHx8IHNjb3BlcztcbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZSA9IHtcbiAgICAgICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdPYmplY3QnLFxuICAgICAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgICAgICBfc2NvcGVzOiBzY29wZXMsXG4gICAgICAgIF9yb290U2NvcGVzOiBmaW5hbFJvb3RTY29wZXMsXG4gICAgICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICAgICAgb3ZlcnJpZGU6IChzY29wZSk9Pl9jcmVhdGVSZXNvbHZlcihbXG4gICAgICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICAgICAgLi4uc2NvcGVzXG4gICAgICAgICAgICBdLCBwcmVmaXhlcywgZmluYWxSb290U2NvcGVzLCBmYWxsYmFjaylcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICAgICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqLyBkZWxldGVQcm9wZXJ0eSAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICAgICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdOyAvLyByZW1vdmUgZnJvbSB0b3AgbGV2ZWwgc2NvcGVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqLyBnZXQgKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLCAoKT0+X3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqLyBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovIGdldFByb3RvdHlwZU9mICgpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHNjb3Blc1swXSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICAqLyBoYXMgKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovIG93bktleXMgKHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3Igc2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovIHNldCAodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc3RvcmFnZVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gdG9wIGxldmVsIHNjb3BlICsgY2FjaGVcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7IC8vIHJlbW92ZSBjYWNoZWQga2V5c1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBQcm94eSBmb3IgcmVzb2x2aW5nIG9wdGlvbiB2YWx1ZXMgd2l0aCBjb250ZXh0LlxuICogQHBhcmFtIHByb3h5IC0gVGhlIFByb3h5IHJldHVybmVkIGJ5IGBfY3JlYXRlUmVzb2x2ZXJgXG4gKiBAcGFyYW0gY29udGV4dCAtIENvbnRleHQgb2JqZWN0IGZvciBzY3JpcHRhYmxlL2luZGV4YWJsZSBvcHRpb25zXG4gKiBAcGFyYW0gc3ViUHJveHkgLSBUaGUgcHJveHkgcHJvdmlkZWQgZm9yIHNjcmlwdGFibGUgb3B0aW9uc1xuICogQHBhcmFtIGRlc2NyaXB0b3JEZWZhdWx0cyAtIERlZmF1bHRzIGZvciBkZXNjcmlwdG9yc1xuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfYXR0YWNoQ29udGV4dChwcm94eSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICAgIGNvbnN0IGNhY2hlID0ge1xuICAgICAgICBfY2FjaGVhYmxlOiBmYWxzZSxcbiAgICAgICAgX3Byb3h5OiBwcm94eSxcbiAgICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIF9zdWJQcm94eTogc3ViUHJveHksXG4gICAgICAgIF9zdGFjazogbmV3IFNldCgpLFxuICAgICAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICAgICAgc2V0Q29udGV4dDogKGN0eCk9Pl9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgICAgICBvdmVycmlkZTogKHNjb3BlKT0+X2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgICAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBkZWxldGUgb3BlcmF0b3IuXG4gICAgICovIGRlbGV0ZVByb3BlcnR5ICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICAgICAgICBkZWxldGUgcHJveHlbcHJvcF07IC8vIHJlbW92ZSBmcm9tIHByb3h5XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi8gZ2V0ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsICgpPT5fcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLlxuICAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgICovIGdldE93blByb3BlcnR5RGVzY3JpcHRvciAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Ll9kZXNjcmlwdG9ycy5hbGxLZXlzID8gUmVmbGVjdC5oYXMocHJveHksIHByb3ApID8ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9IDogdW5kZWZpbmVkIDogUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJveHksIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZi5cbiAgICAgKi8gZ2V0UHJvdG90eXBlT2YgKCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJveHkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi8gaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovIG93bktleXMgKCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwcm94eSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3Igc2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovIHNldCAodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgcHJveHlbcHJvcF0gPSB2YWx1ZTsgLy8gc2V0IHRvIHByb3h5XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfZGVzY3JpcHRvcnMocHJveHksIGRlZmF1bHRzID0ge1xuICAgIHNjcmlwdGFibGU6IHRydWUsXG4gICAgaW5kZXhhYmxlOiB0cnVlXG59KSB7XG4gICAgY29uc3QgeyBfc2NyaXB0YWJsZSA9ZGVmYXVsdHMuc2NyaXB0YWJsZSAsIF9pbmRleGFibGUgPWRlZmF1bHRzLmluZGV4YWJsZSAsIF9hbGxLZXlzID1kZWZhdWx0cy5hbGxLZXlzICB9ID0gcHJveHk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxsS2V5czogX2FsbEtleXMsXG4gICAgICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgICAgICBpbmRleGFibGU6IF9pbmRleGFibGUsXG4gICAgICAgIGlzU2NyaXB0YWJsZTogaXNGdW5jdGlvbihfc2NyaXB0YWJsZSkgPyBfc2NyaXB0YWJsZSA6ICgpPT5fc2NyaXB0YWJsZSxcbiAgICAgICAgaXNJbmRleGFibGU6IGlzRnVuY3Rpb24oX2luZGV4YWJsZSkgPyBfaW5kZXhhYmxlIDogKCk9Pl9pbmRleGFibGVcbiAgICB9O1xufVxuY29uc3QgcmVhZEtleSA9IChwcmVmaXgsIG5hbWUpPT5wcmVmaXggPyBwcmVmaXggKyBfY2FwaXRhbGl6ZShuYW1lKSA6IG5hbWU7XG5jb25zdCBuZWVkc1N1YlJlc29sdmVyID0gKHByb3AsIHZhbHVlKT0+aXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG5mdW5jdGlvbiBfY2FjaGVkKHRhcmdldCwgcHJvcCwgcmVzb2x2ZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHJlc29sdmUoKTtcbiAgICAvLyBjYWNoZSB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICBjb25zdCB7IF9wcm94eSAsIF9jb250ZXh0ICwgX3N1YlByb3h5ICwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9ycyAgfSA9IHRhcmdldDtcbiAgICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07IC8vIHJlc29sdmUgZnJvbSBwcm94eVxuICAgIC8vIHJlc29sdmUgd2l0aCBjb250ZXh0XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpICYmIGRlc2NyaXB0b3JzLmlzU2NyaXB0YWJsZShwcm9wKSkge1xuICAgICAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGRlc2NyaXB0b3JzLmlzSW5kZXhhYmxlKTtcbiAgICB9XG4gICAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgICAgIC8vIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhbiBvYmplY3QsIGNyZWF0ZSBhIHN1YiByZXNvbHZlciBmb3IgaXRcbiAgICAgICAgdmFsdWUgPSBfYXR0YWNoQ29udGV4dCh2YWx1ZSwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIGdldFZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKSB7XG4gICAgY29uc3QgeyBfcHJveHkgLCBfY29udGV4dCAsIF9zdWJQcm94eSAsIF9zdGFjayAgfSA9IHRhcmdldDtcbiAgICBpZiAoX3N0YWNrLmhhcyhwcm9wKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICAgIH1cbiAgICBfc3RhY2suYWRkKHByb3ApO1xuICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICAgIF9zdGFjay5kZWxldGUocHJvcCk7XG4gICAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgICAgIC8vIFdoZW4gc2NyaXB0YWJsZSBvcHRpb24gcmV0dXJucyBhbiBvYmplY3QsIGNyZWF0ZSBhIHJlc29sdmVyIG9uIHRoYXQuXG4gICAgICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGlzSW5kZXhhYmxlKSB7XG4gICAgY29uc3QgeyBfcHJveHkgLCBfY29udGV4dCAsIF9zdWJQcm94eSAsIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnMgIH0gPSB0YXJnZXQ7XG4gICAgaWYgKHR5cGVvZiBfY29udGV4dC5pbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNJbmRleGFibGUocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlWzBdKSkge1xuICAgICAgICAvLyBBcnJheSBvZiBvYmplY3RzLCByZXR1cm4gYXJyYXkgb3IgcmVzb2x2ZXJzXG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgICAgICBjb25zdCBzY29wZXMgPSBfcHJveHkuX3Njb3Blcy5maWx0ZXIoKHMpPT5zICE9PSBhcnIpO1xuICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKXtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKGZhbGxiYWNrLCBwcm9wLCB2YWx1ZSkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrKHByb3AsIHZhbHVlKSA6IGZhbGxiYWNrO1xufVxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5LCBwYXJlbnQpPT5rZXkgPT09IHRydWUgPyBwYXJlbnQgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gYWRkU2NvcGVzKHNldCwgcGFyZW50U2NvcGVzLCBrZXksIHBhcmVudEZhbGxiYWNrLCB2YWx1ZSkge1xuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcyl7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgIHNldC5hZGQoc2NvcGUpO1xuICAgICAgICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgYSBuZXcgX2ZhbGxiYWNrLCByZXR1cm4gdGhhdC5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZmFsbGJhY2sgd2lsbCByZXN1bWUgdG8gdGhhdCBuZXcgc2NvcGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNjb3BlID09PSBmYWxzZSAmJiB0eXBlb2YgcGFyZW50RmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGtleSAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGBmYWxzZWAgcmVzdWx0cyB0byBgZmFsc2VgLCB3aGVuIGZhbGxpbmcgYmFjayB0byBkaWZmZXJlbnQga2V5LlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUgYGludGVyYWN0aW9uYCBmcm9tIGBob3ZlcmAgb3IgYHBsdWdpbnMudG9vbHRpcGAgYW5kIGBhbmltYXRpb25gIGZyb20gYGFuaW1hdGlvbnNgXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVTdWJSZXNvbHZlcihwYXJlbnRTY29wZXMsIHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICAgIGNvbnN0IHJvb3RTY29wZXMgPSByZXNvbHZlci5fcm9vdFNjb3BlcztcbiAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgICBjb25zdCBhbGxTY29wZXMgPSBbXG4gICAgICAgIC4uLnBhcmVudFNjb3BlcyxcbiAgICAgICAgLi4ucm9vdFNjb3Blc1xuICAgIF07XG4gICAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICAgIHNldC5hZGQodmFsdWUpO1xuICAgIGxldCBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBwcm9wLCBmYWxsYmFjayB8fCBwcm9wLCB2YWx1ZSk7XG4gICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAgICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlUmVzb2x2ZXIoQXJyYXkuZnJvbShzZXQpLCBbXG4gICAgICAgICcnXG4gICAgXSwgcm9vdFNjb3BlcywgZmFsbGJhY2ssICgpPT5zdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKSB7XG4gICAgd2hpbGUoa2V5KXtcbiAgICAgICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gICAgaWYgKCEocHJvcCBpbiBwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gRm9yIGFycmF5IG9mIG9iamVjdHMsIHRoZSBvYmplY3QgaXMgdXNlZCB0byBzdG9yZSB1cGRhdGVkIHZhbHVlc1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQgfHwge307XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCBwcm94eSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcyl7XG4gICAgICAgIHZhbHVlID0gX3Jlc29sdmUocmVhZEtleShwcmVmaXgsIHByb3ApLCBzY29wZXMpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpID8gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBwcm94eSwgcHJvcCwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBfcmVzb2x2ZShrZXksIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKXtcbiAgICAgICAgaWYgKCFzY29wZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KSB7XG4gICAgbGV0IGtleXMgPSB0YXJnZXQuX2tleXM7XG4gICAgaWYgKCFrZXlzKSB7XG4gICAgICAgIGtleXMgPSB0YXJnZXQuX2tleXMgPSByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXModGFyZ2V0Ll9zY29wZXMpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXMpIHtcbiAgICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpe1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY29wZSkuZmlsdGVyKChrKT0+IWsuc3RhcnRzV2l0aCgnXycpKSl7XG4gICAgICAgICAgICBzZXQuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cbmZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7IGlTY2FsZSAgfSA9IG1ldGE7XG4gICAgY29uc3QgeyBrZXkgPSdyJyAgfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgICAgICByOiBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCBrZXkpLCBpbmRleClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbn1cblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuY29uc3QgZ2V0UG9pbnQgPSAocG9pbnRzLCBpKT0+aSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXMpPT5pbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbmZ1bmN0aW9uIHNwbGluZUN1cnZlKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG4gICAgLy8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXG4gICAgLy8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcbiAgICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgICBjb25zdCBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG4gICAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICAgIGNvbnN0IGQxMiA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhuZXh0LCBjdXJyZW50KTtcbiAgICBsZXQgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG4gICAgbGV0IHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuICAgIC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcbiAgICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgICBzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcbiAgICBjb25zdCBmYSA9IHQgKiBzMDE7IC8vIHNjYWxpbmcgZmFjdG9yIGZvciB0cmlhbmdsZSBUYVxuICAgIGNvbnN0IGZiID0gdCAqIHMxMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmV2aW91czoge1xuICAgICAgICAgICAgeDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICAgICAgICB5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgICAgICB9LFxuICAgICAgICBuZXh0OiB7XG4gICAgICAgICAgICB4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgICAgICAgIHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBBZGp1c3QgdGFuZ2VudHMgdG8gZW5zdXJlIG1vbm90b25pYyBwcm9wZXJ0aWVzXG4gKi8gZnVuY3Rpb24gbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKSB7XG4gICAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICBsZXQgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZSwgcG9pbnRDdXJyZW50O1xuICAgIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKXtcbiAgICAgICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICAgICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgICAgICBpZiAoIXBvaW50Q3VycmVudCB8fCAhcG9pbnRBZnRlcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICAgICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICAgICAgYmV0YUsgPSBtS1tpICsgMV0gLyBkZWx0YUtbaV07XG4gICAgICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgICAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcbiAgICAgICAgbUtbaV0gPSBhbHBoYUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICAgICAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gICAgfVxufVxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyA9ICd4Jykge1xuICAgIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICAgIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgbGV0IGRlbHRhLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICAgIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpe1xuICAgICAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICAgICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICAgICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgICAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaVBpeGVsID0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgICAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgICAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgICAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgICAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICAgICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgICAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgICAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcbiAqIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcbiAqIGJldHdlZW4gdGhlIGRhdGFzZXQgZGlzY3JldGUgcG9pbnRzIGR1ZSB0byB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cbiAqLyBmdW5jdGlvbiBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzID0gJ3gnKSB7XG4gICAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gICAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBkZWx0YUsgPSBBcnJheShwb2ludHNMZW4pLmZpbGwoMCk7XG4gICAgY29uc3QgbUsgPSBBcnJheShwb2ludHNMZW4pO1xuICAgIC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuICAgIGxldCBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICAgIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgICBmb3IoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSl7XG4gICAgICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgICAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgICAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG4gICAgICAgICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldIDogIXBvaW50QWZ0ZXIgPyBkZWx0YUtbaSAtIDFdIDogc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pID8gMCA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gICAgfVxuICAgIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG4gICAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSkge1xuICAgIGxldCBpLCBpbGVuLCBwb2ludCwgaW5BcmVhLCBpbkFyZWFQcmV2O1xuICAgIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgICBmb3IoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgaW5BcmVhUHJldiA9IGluQXJlYTtcbiAgICAgICAgaW5BcmVhID0gaW5BcmVhTmV4dDtcbiAgICAgICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICAgICAgaWYgKCFpbkFyZWEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICBpZiAoaW5BcmVhUHJldikge1xuICAgICAgICAgICAgcG9pbnQuY3AxeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgICAgICAgcG9pbnQuY3AxeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICAgICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICAgICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMocG9pbnRzLCBvcHRpb25zLCBhcmVhLCBsb29wLCBpbmRleEF4aXMpIHtcbiAgICBsZXQgaSwgaWxlbiwgcG9pbnQsIGNvbnRyb2xQb2ludHM7XG4gICAgLy8gT25seSBjb25zaWRlciBwb2ludHMgdGhhdCBhcmUgZHJhd24gaW4gY2FzZSB0aGUgc3BhbkdhcHMgb3B0aW9uIGlzIHVzZWRcbiAgICBpZiAob3B0aW9ucy5zcGFuR2Fwcykge1xuICAgICAgICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKChwdCk9PiFwdC5za2lwKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgICAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgY29udHJvbFBvaW50cyA9IHNwbGluZUN1cnZlKHByZXYsIHBvaW50LCBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSwgb3B0aW9ucy50ZW5zaW9uKTtcbiAgICAgICAgICAgIHBvaW50LmNwMXggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XG4gICAgICAgICAgICBwb2ludC5jcDF5ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuICAgICAgICAgICAgcG9pbnQuY3AyeCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuICAgICAgICAgICAgcG9pbnQuY3AyeSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuICAgICAgICAgICAgcHJldiA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xuICAgICAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgICB9XG59XG5cbi8qKlxuICogTm90ZTogdHlwZWRlZnMgYXJlIGF1dG8tZXhwb3J0ZWQsIHNvIHVzZSBhIG1hZGUtdXAgYGRvbWAgbmFtZXNwYWNlIHdoZXJlXG4gKiBuZWNlc3NhcnkgdG8gYXZvaWQgZHVwbGljYXRlcyB3aXRoIGBleHBvcnQgKiBmcm9tICcuL2hlbHBlcnNgOyBzZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDYwMTFcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBkb20uQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKi8gLyoqXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlKSB7XG4gICAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnQ7XG59XG4vKipcbiAqIGNvbnZlcnQgbWF4LXdpZHRoL21heC1oZWlnaHQgdmFsdWVzIHRoYXQgbWF5IGJlIHBlcmNlbnRhZ2VzIGludG8gYSBudW1iZXJcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gcGFyc2VNYXhTdHlsZShzdHlsZVZhbHVlLCBub2RlLCBwYXJlbnRQcm9wZXJ0eSkge1xuICAgIGxldCB2YWx1ZUluUGl4ZWxzO1xuICAgIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKHN0eWxlVmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gcGVyY2VudGFnZSAqIHNpemUgaW4gZGltZW5zaW9uXG4gICAgICAgICAgICB2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQpPT5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cbmNvbnN0IHBvc2l0aW9ucyA9IFtcbiAgICAndG9wJyxcbiAgICAncmlnaHQnLFxuICAgICdib3R0b20nLFxuICAgICdsZWZ0J1xuXTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZXMsIHN0eWxlLCBzdWZmaXgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgNDsgaSsrKXtcbiAgICAgICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgICAgICByZXN1bHRbcG9zXSA9IHBhcnNlRmxvYXQoc3R5bGVzW3N0eWxlICsgJy0nICsgcG9zICsgc3VmZml4XSkgfHwgMDtcbiAgICB9XG4gICAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gICAgcmVzdWx0LmhlaWdodCA9IHJlc3VsdC50b3AgKyByZXN1bHQuYm90dG9tO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCB1c2VPZmZzZXRQb3MgPSAoeCwgeSwgdGFyZ2V0KT0+KHggPiAwIHx8IHkgPiAwKSAmJiAoIXRhcmdldCB8fCAhdGFyZ2V0LnNoYWRvd1Jvb3QpO1xuLyoqXG4gKiBAcGFyYW0gZVxuICogQHBhcmFtIGNhbnZhc1xuICogQHJldHVybnMgQ2FudmFzIHBvc2l0aW9uXG4gKi8gZnVuY3Rpb24gZ2V0Q2FudmFzUG9zaXRpb24oZSwgY2FudmFzKSB7XG4gICAgY29uc3QgdG91Y2hlcyA9IGUudG91Y2hlcztcbiAgICBjb25zdCBzb3VyY2UgPSB0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID8gdG91Y2hlc1swXSA6IGU7XG4gICAgY29uc3QgeyBvZmZzZXRYICwgb2Zmc2V0WSAgfSA9IHNvdXJjZTtcbiAgICBsZXQgYm94ID0gZmFsc2U7XG4gICAgbGV0IHgsIHk7XG4gICAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICAgICAgeCA9IG9mZnNldFg7XG4gICAgICAgIHkgPSBvZmZzZXRZO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICAgIGJveCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGJveFxuICAgIH07XG59XG4vKipcbiAqIEdldHMgYW4gZXZlbnQncyB4LCB5IGNvb3JkaW5hdGVzLCByZWxhdGl2ZSB0byB0aGUgY2hhcnQgYXJlYVxuICogQHBhcmFtIGV2ZW50XG4gKiBAcGFyYW0gY2hhcnRcbiAqIEByZXR1cm5zIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50XG4gKi8gZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpIHtcbiAgICBpZiAoJ25hdGl2ZScgaW4gZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBjb25zdCB7IGNhbnZhcyAsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICB9ID0gY2hhcnQ7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gICAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgIGNvbnN0IHsgeCAsIHkgLCBib3ggIH0gPSBnZXRDYW52YXNQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gcGFkZGluZ3MubGVmdCArIChib3ggJiYgYm9yZGVycy5sZWZ0KTtcbiAgICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG4gICAgbGV0IHsgd2lkdGggLCBoZWlnaHQgIH0gPSBjaGFydDtcbiAgICBpZiAoYm9yZGVyQm94KSB7XG4gICAgICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICAgICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBNYXRoLnJvdW5kKCh4IC0geE9mZnNldCkgLyB3aWR0aCAqIGNhbnZhcy53aWR0aCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKSxcbiAgICAgICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCkge1xuICAgIGxldCBtYXhXaWR0aCwgbWF4SGVpZ2h0O1xuICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyB0aGlzIGlzIHRoZSBib3JkZXIgYm94IG9mIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyQm9yZGVyID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJQYWRkaW5nID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAncGFkZGluZycpO1xuICAgICAgICAgICAgd2lkdGggPSByZWN0LndpZHRoIC0gY29udGFpbmVyUGFkZGluZy53aWR0aCAtIGNvbnRhaW5lckJvcmRlci53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gY29udGFpbmVyUGFkZGluZy5oZWlnaHQgLSBjb250YWluZXJCb3JkZXIuaGVpZ2h0O1xuICAgICAgICAgICAgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heFdpZHRoLCBjb250YWluZXIsICdjbGllbnRXaWR0aCcpO1xuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhIZWlnaHQsIGNvbnRhaW5lciwgJ2NsaWVudEhlaWdodCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIG1heFdpZHRoOiBtYXhXaWR0aCB8fCBJTkZJTklUWSxcbiAgICAgICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfHwgSU5GSU5JVFlcbiAgICB9O1xufVxuY29uc3Qgcm91bmQxID0gKHYpPT5NYXRoLnJvdW5kKHYgKiAxMCkgLyAxMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICAgIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4V2lkdGgsIGNhbnZhcywgJ2NsaWVudFdpZHRoJykgfHwgSU5GSU5JVFk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICAgIGxldCB7IHdpZHRoICwgaGVpZ2h0ICB9ID0gY29udGFpbmVyU2l6ZTtcbiAgICBpZiAoc3R5bGUuYm94U2l6aW5nID09PSAnY29udGVudC1ib3gnKSB7XG4gICAgICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICAgICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICAgIH1cbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gbWFyZ2lucy53aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyB3aWR0aCAvIGFzcGVjdFJhdGlvIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICAgIHdpZHRoID0gcm91bmQxKE1hdGgubWluKHdpZHRoLCBtYXhXaWR0aCwgY29udGFpbmVyU2l6ZS5tYXhXaWR0aCkpO1xuICAgIGhlaWdodCA9IHJvdW5kMShNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCwgY29udGFpbmVyU2l6ZS5tYXhIZWlnaHQpKTtcbiAgICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDY1OVxuICAgICAgICAvLyBJZiB0aGUgY2FudmFzIGhhcyB3aWR0aCwgYnV0IG5vIGhlaWdodCwgZGVmYXVsdCB0byBhc3BlY3RSYXRpbyBvZiAyIChjYW52YXMgZGVmYXVsdClcbiAgICAgICAgaGVpZ2h0ID0gcm91bmQxKHdpZHRoIC8gMik7XG4gICAgfVxuICAgIGNvbnN0IG1haW50YWluSGVpZ2h0ID0gYmJXaWR0aCAhPT0gdW5kZWZpbmVkIHx8IGJiSGVpZ2h0ICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1haW50YWluSGVpZ2h0ICYmIGFzcGVjdFJhdGlvICYmIGNvbnRhaW5lclNpemUuaGVpZ2h0ICYmIGhlaWdodCA+IGNvbnRhaW5lclNpemUuaGVpZ2h0KSB7XG4gICAgICAgIGhlaWdodCA9IGNvbnRhaW5lclNpemUuaGVpZ2h0O1xuICAgICAgICB3aWR0aCA9IHJvdW5kMShNYXRoLmZsb29yKGhlaWdodCAqIGFzcGVjdFJhdGlvKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICB9O1xufVxuLyoqXG4gKiBAcGFyYW0gY2hhcnRcbiAqIEBwYXJhbSBmb3JjZVJhdGlvXG4gKiBAcGFyYW0gZm9yY2VTdHlsZVxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY2FudmFzIGNvbnRleHQgc2l6ZSBvciB0cmFuc2Zvcm1hdGlvbiBoYXMgY2hhbmdlZC5cbiAqLyBmdW5jdGlvbiByZXRpbmFTY2FsZShjaGFydCwgZm9yY2VSYXRpbywgZm9yY2VTdHlsZSkge1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8IDE7XG4gICAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgICBjaGFydC5oZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCk7XG4gICAgY2hhcnQud2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoKTtcbiAgICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gICAgLy8gSWYgbm8gc3R5bGUgaGFzIGJlZW4gc2V0IG9uIHRoZSBjYW52YXMsIHRoZSByZW5kZXIgc2l6ZSBpcyB1c2VkIGFzIGRpc3BsYXkgc2l6ZSxcbiAgICAvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxuICAgIGlmIChjYW52YXMuc3R5bGUgJiYgKGZvcmNlU3R5bGUgfHwgIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpIHtcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NoYXJ0LndpZHRofXB4YDtcbiAgICB9XG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRldmljZUhlaWdodCB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgICAgIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRldmljZUhlaWdodDtcbiAgICAgICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgICAgIGNoYXJ0LmN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIERldGVjdHMgc3VwcG9ydCBmb3Igb3B0aW9ucyBvYmplY3QgYXJndW1lbnQgaW4gYWRkRXZlbnRMaXN0ZW5lci5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcbiAqIEBwcml2YXRlXG4gKi8gY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGdldCBwYXNzaXZlICgpIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgICB9XG4gICAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59KCk7XG4vKipcbiAqIFRoZSBcInVzZWRcIiBzaXplIGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiBhIGRpbWVuc2lvbiBwcm9wZXJ0eSBhZnRlciBhbGwgY2FsY3VsYXRpb25zIGhhdmVcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXG4gKiBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgbm90IGV4cHJlc3NlZCBpbiBwaXhlbHMuIFRoYXQgY2FuIGhhcHBlbiBpbiBzb21lIGNhc2VzIHdoZXJlXG4gKiBgZWxlbWVudGAgaGFzIGEgc2l6ZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGFuZCB0aGlzIGxhc3Qgb25lIGlzIG5vdCB5ZXQgZGlzcGxheWVkLFxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqIEByZXR1cm5zIFNpemUgaW4gcGl4ZWxzIG9yIHVuZGVmaW5lZCBpZiB1bmtub3duLlxuICovIGZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgICByZXR1cm4gbWF0Y2hlcyA/ICttYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX3BvaW50SW5MaW5lKHAxLCBwMiwgdCwgbW9kZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICAgICAgeTogcDEueSArIHQgKiAocDIueSAtIHAxLnkpXG4gICAgfTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfc3RlcHBlZEludGVycG9sYXRpb24ocDEsIHAyLCB0LCBtb2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgICAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueSA6IG1vZGUgPT09ICdhZnRlcicgPyB0IDwgMSA/IHAxLnkgOiBwMi55IDogdCA+IDAgPyBwMi55IDogcDEueVxuICAgIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2JlemllckludGVycG9sYXRpb24ocDEsIHAyLCB0LCBtb2RlKSB7XG4gICAgY29uc3QgY3AxID0ge1xuICAgICAgICB4OiBwMS5jcDJ4LFxuICAgICAgICB5OiBwMS5jcDJ5XG4gICAgfTtcbiAgICBjb25zdCBjcDIgPSB7XG4gICAgICAgIHg6IHAyLmNwMXgsXG4gICAgICAgIHk6IHAyLmNwMXlcbiAgICB9O1xuICAgIGNvbnN0IGEgPSBfcG9pbnRJbkxpbmUocDEsIGNwMSwgdCk7XG4gICAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gICAgY29uc3QgYyA9IF9wb2ludEluTGluZShjcDIsIHAyLCB0KTtcbiAgICBjb25zdCBkID0gX3BvaW50SW5MaW5lKGEsIGIsIHQpO1xuICAgIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gICAgcmV0dXJuIF9wb2ludEluTGluZShkLCBlLCB0KTtcbn1cblxuY29uc3QgZ2V0UmlnaHRUb0xlZnRBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFgsIHdpZHRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFdpZHRoICh3KSB7XG4gICAgICAgICAgICB3aWR0aCA9IHc7XG4gICAgICAgIH0sXG4gICAgICAgIHRleHRBbGlnbiAoYWxpZ24pIHtcbiAgICAgICAgICAgIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICB9LFxuICAgICAgICB4UGx1cyAoeCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB4IC0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGxlZnRGb3JMdHIgKHgsIGl0ZW1XaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHggLSBpdGVtV2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9LFxuICAgICAgICBzZXRXaWR0aCAodykge30sXG4gICAgICAgIHRleHRBbGlnbiAoYWxpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgICAgfSxcbiAgICAgICAgeFBsdXMgKHgsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBsZWZ0Rm9yTHRyICh4LCBfaXRlbVdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuZnVuY3Rpb24gZ2V0UnRsQWRhcHRlcihydGwsIHJlY3RYLCB3aWR0aCkge1xuICAgIHJldHVybiBydGwgPyBnZXRSaWdodFRvTGVmdEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldExlZnRUb1JpZ2h0QWRhcHRlcigpO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgZGlyZWN0aW9uKSB7XG4gICAgbGV0IHN0eWxlLCBvcmlnaW5hbDtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICAgICAgb3JpZ2luYWwgPSBbXG4gICAgICAgICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcbiAgICAgICAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpXG4gICAgICAgIF07XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBkaXJlY3Rpb24sICdpbXBvcnRhbnQnKTtcbiAgICAgICAgY3R4LnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcmlnaW5hbCkge1xuICAgIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBjdHgucHJldlRleHREaXJlY3Rpb247XG4gICAgICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZuKHByb3BlcnR5KSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiZXR3ZWVuOiBfYW5nbGVCZXR3ZWVuLFxuICAgICAgICAgICAgY29tcGFyZTogX2FuZ2xlRGlmZixcbiAgICAgICAgICAgIG5vcm1hbGl6ZTogX25vcm1hbGl6ZUFuZ2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGJldHdlZW46IF9pc0JldHdlZW4sXG4gICAgICAgIGNvbXBhcmU6IChhLCBiKT0+YSAtIGIsXG4gICAgICAgIG5vcm1hbGl6ZTogKHgpPT54XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoeyBzdGFydCAsIGVuZCAsIGNvdW50ICwgbG9vcCAsIHN0eWxlICB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0ICUgY291bnQsXG4gICAgICAgIGVuZDogZW5kICUgY291bnQsXG4gICAgICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICAgICAgc3R5bGVcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICAgIGNvbnN0IHsgcHJvcGVydHkgLCBzdGFydDogc3RhcnRCb3VuZCAsIGVuZDogZW5kQm91bmQgIH0gPSBib3VuZHM7XG4gICAgY29uc3QgeyBiZXR3ZWVuICwgbm9ybWFsaXplICB9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gICAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGxldCB7IHN0YXJ0ICwgZW5kICwgbG9vcCAgfSA9IHNlZ21lbnQ7XG4gICAgbGV0IGksIGlsZW47XG4gICAgaWYgKGxvb3ApIHtcbiAgICAgICAgc3RhcnQgKz0gY291bnQ7XG4gICAgICAgIGVuZCArPSBjb3VudDtcbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICAgICAgZW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgJT0gY291bnQ7XG4gICAgICAgIGVuZCAlPSBjb3VudDtcbiAgICB9XG4gICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIGVuZCArPSBjb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgbG9vcCxcbiAgICAgICAgc3R5bGU6IHNlZ21lbnQuc3R5bGVcbiAgICB9O1xufVxuIGZ1bmN0aW9uIF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2VnbWVudFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCB7IHByb3BlcnR5ICwgc3RhcnQ6IHN0YXJ0Qm91bmQgLCBlbmQ6IGVuZEJvdW5kICB9ID0gYm91bmRzO1xuICAgIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCB7IGNvbXBhcmUgLCBiZXR3ZWVuICwgbm9ybWFsaXplICB9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gICAgY29uc3QgeyBzdGFydCAsIGVuZCAsIGxvb3AgLCBzdHlsZSAgfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICAgIGxldCB2YWx1ZSwgcG9pbnQsIHByZXZWYWx1ZTtcbiAgICBjb25zdCBzdGFydElzQmVmb3JlID0gKCk9PmJldHdlZW4oc3RhcnRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSkgJiYgY29tcGFyZShzdGFydEJvdW5kLCBwcmV2VmFsdWUpICE9PSAwO1xuICAgIGNvbnN0IGVuZElzQmVmb3JlID0gKCk9PmNvbXBhcmUoZW5kQm91bmQsIHZhbHVlKSA9PT0gMCB8fCBiZXR3ZWVuKGVuZEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKTtcbiAgICBjb25zdCBzaG91bGRTdGFydCA9ICgpPT5pbnNpZGUgfHwgc3RhcnRJc0JlZm9yZSgpO1xuICAgIGNvbnN0IHNob3VsZFN0b3AgPSAoKT0+IWluc2lkZSB8fCBlbmRJc0JlZm9yZSgpO1xuICAgIGZvcihsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpe1xuICAgICAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBwcmV2VmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcbiAgICAgICAgaWYgKHN1YlN0YXJ0ID09PSBudWxsICYmIHNob3VsZFN0YXJ0KCkpIHtcbiAgICAgICAgICAgIHN1YlN0YXJ0ID0gY29tcGFyZSh2YWx1ZSwgc3RhcnRCb3VuZCkgPT09IDAgPyBpIDogcHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3ViU3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBpLFxuICAgICAgICAgICAgICAgIGxvb3AsXG4gICAgICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICAgICAgc3R5bGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHN1YlN0YXJ0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gaTtcbiAgICAgICAgcHJldlZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlmIChzdWJTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdWJTdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIGxvb3AsXG4gICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgIHN0eWxlXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiBmdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3Qgc3ViID0gX2JvdW5kU2VnbWVudChzZWdtZW50c1tpXSwgbGluZS5wb2ludHMsIGJvdW5kcyk7XG4gICAgICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4gZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gY291bnQgLSAxO1xuICAgIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgICAgICB3aGlsZShzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApe1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZShzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCl7XG4gICAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgIGlmIChsb29wKSB7XG4gICAgICAgIGVuZCArPSBzdGFydDtcbiAgICB9XG4gICAgd2hpbGUoZW5kID4gc3RhcnQgJiYgcG9pbnRzW2VuZCAlIGNvdW50XS5za2lwKXtcbiAgICAgICAgZW5kLS07XG4gICAgfVxuICAgIGVuZCAlPSBjb3VudDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kXG4gICAgfTtcbn1cbiBmdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICAgIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgbGFzdCA9IHN0YXJ0O1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBsZXQgZW5kO1xuICAgIGZvcihlbmQgPSBzdGFydCArIDE7IGVuZCA8PSBtYXg7ICsrZW5kKXtcbiAgICAgICAgY29uc3QgY3VyID0gcG9pbnRzW2VuZCAlIGNvdW50XTtcbiAgICAgICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICAgICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICAgICAgICAgIGxvb3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IChlbmQgLSAxKSAlIGNvdW50LFxuICAgICAgICAgICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBsYXN0ID0gY3VyLnN0b3AgPyBlbmQgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdCA9IGVuZDtcbiAgICAgICAgICAgIGlmIChwcmV2LnNraXApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gY3VyO1xuICAgIH1cbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICAgICAgICAgIGVuZDogbGFzdCAlIGNvdW50LFxuICAgICAgICAgICAgbG9vcFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiBmdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gICAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gICAgY29uc3Qgc3BhbkdhcHMgPSBsaW5lLm9wdGlvbnMuc3BhbkdhcHM7XG4gICAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGlmICghY291bnQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBsb29wID0gISFsaW5lLl9sb29wO1xuICAgIGNvbnN0IHsgc3RhcnQgLCBlbmQgIH0gPSBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpO1xuICAgIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IG1heCA9IGVuZCA8IHN0YXJ0ID8gZW5kICsgY291bnQgOiBlbmQ7XG4gICAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG4gZnVuY3Rpb24gc3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICAgIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgfVxuICAgIHJldHVybiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuIGZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0Q29udGV4dCA9IGxpbmUuX2NoYXJ0LmdldENvbnRleHQoKTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSByZWFkU3R5bGUobGluZS5vcHRpb25zKTtcbiAgICBjb25zdCB7IF9kYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCAsIG9wdGlvbnM6IHsgc3BhbkdhcHMgIH0gIH0gPSBsaW5lO1xuICAgIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgcHJldlN0eWxlID0gYmFzZVN0eWxlO1xuICAgIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGxldCBpID0gc3RhcnQ7XG4gICAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcbiAgICAgICAgY29uc3QgZGlyID0gc3BhbkdhcHMgPyAtMSA6IDE7XG4gICAgICAgIGlmIChzID09PSBlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcyArPSBjb3VudDtcbiAgICAgICAgd2hpbGUocG9pbnRzW3MgJSBjb3VudF0uc2tpcCl7XG4gICAgICAgICAgICBzIC09IGRpcjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShwb2ludHNbZSAlIGNvdW50XS5za2lwKXtcbiAgICAgICAgICAgIGUgKz0gZGlyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzICUgY291bnQsXG4gICAgICAgICAgICAgICAgZW5kOiBlICUgY291bnQsXG4gICAgICAgICAgICAgICAgbG9vcDogbCxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJldlN0eWxlID0gc3Q7XG4gICAgICAgICAgICBzdGFydCA9IGUgJSBjb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpe1xuICAgICAgICBzdGFydCA9IHNwYW5HYXBzID8gc3RhcnQgOiBzZWdtZW50LnN0YXJ0O1xuICAgICAgICBsZXQgcHJldiA9IHBvaW50c1tzdGFydCAlIGNvdW50XTtcbiAgICAgICAgbGV0IHN0eWxlO1xuICAgICAgICBmb3IoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IHB0ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgICAgICAgICBzdHlsZSA9IHJlYWRTdHlsZShzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0KGNyZWF0ZUNvbnRleHQoY2hhcnRDb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICAgICAgICAgIHAwOiBwcmV2LFxuICAgICAgICAgICAgICAgIHAxOiBwdCxcbiAgICAgICAgICAgICAgICBwMERhdGFJbmRleDogKGkgLSAxKSAlIGNvdW50LFxuICAgICAgICAgICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgICAgICAgICAgZGF0YXNldEluZGV4XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgaWYgKHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSkge1xuICAgICAgICAgICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHB0O1xuICAgICAgICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0IDwgaSAtIDEpIHtcbiAgICAgICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSB7XG4gICAgaWYgKCFwcmV2U3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZSA9IFtdO1xuICAgIGNvbnN0IHJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYWNoZS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZS5pbmRleE9mKHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHlsZSwgcmVwbGFjZXIpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2U3R5bGUsIHJlcGxhY2VyKTtcbn1cblxuZXhwb3J0IHsgdW5jbGlwQXJlYSBhcyAkLCBfcmxvb2t1cEJ5S2V5IGFzIEEsIF9sb29rdXBCeUtleSBhcyBCLCBfaXNQb2ludEluQXJlYSBhcyBDLCBnZXRBbmdsZUZyb21Qb2ludCBhcyBELCB0b1BhZGRpbmcgYXMgRSwgZWFjaCBhcyBGLCBnZXRNYXhpbXVtU2l6ZSBhcyBHLCBIQUxGX1BJIGFzIEgsIF9nZXRQYXJlbnROb2RlIGFzIEksIHJlYWRVc2VkU2l6ZSBhcyBKLCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIGFzIEssIHRocm90dGxlZCBhcyBMLCBfaXNEb21TdXBwb3J0ZWQgYXMgTSwgX2ZhY3Rvcml6ZSBhcyBOLCBmaW5pdGVPckRlZmF1bHQgYXMgTywgUEkgYXMgUCwgY2FsbGJhY2sgYXMgUSwgX2FkZEdyYWNlIGFzIFIsIF9saW1pdFZhbHVlIGFzIFMsIFRBVSBhcyBULCB0b0RlZ3JlZXMgYXMgVSwgX21lYXN1cmVUZXh0IGFzIFYsIF9pbnQxNlJhbmdlIGFzIFcsIF9hbGlnblBpeGVsIGFzIFgsIGNsaXBBcmVhIGFzIFksIHJlbmRlclRleHQgYXMgWiwgX2FycmF5VW5pcXVlIGFzIF8sIHJlc29sdmUgYXMgYSwgZm9udFN0cmluZyBhcyBhJCwgdG9Gb250IGFzIGEwLCBfdG9MZWZ0UmlnaHRDZW50ZXIgYXMgYTEsIF9hbGlnblN0YXJ0RW5kIGFzIGEyLCBvdmVycmlkZXMgYXMgYTMsIG1lcmdlIGFzIGE0LCBfY2FwaXRhbGl6ZSBhcyBhNSwgZGVzY3JpcHRvcnMgYXMgYTYsIGlzRnVuY3Rpb24gYXMgYTcsIF9hdHRhY2hDb250ZXh0IGFzIGE4LCBfY3JlYXRlUmVzb2x2ZXIgYXMgYTksIG92ZXJyaWRlVGV4dERpcmVjdGlvbiBhcyBhQSwgX3RleHRYIGFzIGFCLCByZXN0b3JlVGV4dERpcmVjdGlvbiBhcyBhQywgZHJhd1BvaW50TGVnZW5kIGFzIGFELCBkaXN0YW5jZUJldHdlZW5Qb2ludHMgYXMgYUUsIG5vb3AgYXMgYUYsIF9zZXRNaW5BbmRNYXhCeUtleSBhcyBhRywgbmljZU51bSBhcyBhSCwgYWxtb3N0V2hvbGUgYXMgYUksIGFsbW9zdEVxdWFscyBhcyBhSiwgX2RlY2ltYWxQbGFjZXMgYXMgYUssIFRpY2tzIGFzIGFMLCBsb2cxMCBhcyBhTSwgX2xvbmdlc3RUZXh0IGFzIGFOLCBfZmlsdGVyQmV0d2VlbiBhcyBhTywgX2xvb2t1cCBhcyBhUCwgaXNQYXR0ZXJuT3JHcmFkaWVudCBhcyBhUSwgZ2V0SG92ZXJDb2xvciBhcyBhUiwgY2xvbmUgYXMgYVMsIF9tZXJnZXIgYXMgYVQsIF9tZXJnZXJJZiBhcyBhVSwgX2RlcHJlY2F0ZWQgYXMgYVYsIF9zcGxpdEtleSBhcyBhVywgdG9Gb250U3RyaW5nIGFzIGFYLCBzcGxpbmVDdXJ2ZSBhcyBhWSwgc3BsaW5lQ3VydmVNb25vdG9uZSBhcyBhWiwgZ2V0U3R5bGUgYXMgYV8sIF9kZXNjcmlwdG9ycyBhcyBhYSwgbWVyZ2VJZiBhcyBhYiwgdWlkIGFzIGFjLCBkZWJvdW5jZSBhcyBhZCwgcmV0aW5hU2NhbGUgYXMgYWUsIGNsZWFyQ2FudmFzIGFzIGFmLCBzZXRzRXF1YWwgYXMgYWcsIF9lbGVtZW50c0VxdWFsIGFzIGFoLCBfaXNDbGlja0V2ZW50IGFzIGFpLCBfaXNCZXR3ZWVuIGFzIGFqLCBfcmVhZFZhbHVlVG9Qcm9wcyBhcyBhaywgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMgYXMgYWwsIF9jb21wdXRlU2VnbWVudHMgYXMgYW0sIF9ib3VuZFNlZ21lbnRzIGFzIGFuLCBfc3RlcHBlZEludGVycG9sYXRpb24gYXMgYW8sIF9iZXppZXJJbnRlcnBvbGF0aW9uIGFzIGFwLCBfcG9pbnRJbkxpbmUgYXMgYXEsIF9zdGVwcGVkTGluZVRvIGFzIGFyLCBfYmV6aWVyQ3VydmVUbyBhcyBhcywgZHJhd1BvaW50IGFzIGF0LCBhZGRSb3VuZGVkUmVjdFBhdGggYXMgYXUsIHRvVFJCTCBhcyBhdiwgdG9UUkJMQ29ybmVycyBhcyBhdywgX2JvdW5kU2VnbWVudCBhcyBheCwgX25vcm1hbGl6ZUFuZ2xlIGFzIGF5LCBnZXRSdGxBZGFwdGVyIGFzIGF6LCBpc0FycmF5IGFzIGIsIHRvTGluZUhlaWdodCBhcyBiMCwgUElUQVUgYXMgYjEsIElORklOSVRZIGFzIGIyLCBSQURfUEVSX0RFRyBhcyBiMywgUVVBUlRFUl9QSSBhcyBiNCwgVFdPX1RISVJEU19QSSBhcyBiNSwgX2FuZ2xlRGlmZiBhcyBiNiwgY29sb3IgYXMgYywgZGVmYXVsdHMgYXMgZCwgZWZmZWN0cyBhcyBlLCByZXNvbHZlT2JqZWN0S2V5IGFzIGYsIGlzTnVtYmVyRmluaXRlIGFzIGcsIGRlZmluZWQgYXMgaCwgaXNPYmplY3QgYXMgaSwgY3JlYXRlQ29udGV4dCBhcyBqLCBpc051bGxPclVuZGVmIGFzIGssIGxpc3RlbkFycmF5RXZlbnRzIGFzIGwsIHRvUGVyY2VudGFnZSBhcyBtLCB0b0RpbWVuc2lvbiBhcyBuLCBmb3JtYXROdW1iZXIgYXMgbywgX2FuZ2xlQmV0d2VlbiBhcyBwLCBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyBhcyBxLCByZXF1ZXN0QW5pbUZyYW1lIGFzIHIsIHNpZ24gYXMgcywgdG9SYWRpYW5zIGFzIHQsIHVubGlzdGVuQXJyYXlFdmVudHMgYXMgdSwgdmFsdWVPckRlZmF1bHQgYXMgdiwgX3NjYWxlUmFuZ2VzQ2hhbmdlZCBhcyB3LCBpc051bWJlciBhcyB4LCBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUgYXMgeSwgZ2V0UmVsYXRpdmVQb3NpdGlvbiBhcyB6IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLnNlZ21lbnQuanMubWFwXG4iLCIvKiFcbiAqIENoYXJ0LmpzIHY0LjQuMFxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIzIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVxdWVzdEFuaW1GcmFtZSwgYSBhcyByZXNvbHZlLCBlIGFzIGVmZmVjdHMsIGMgYXMgY29sb3IsIGkgYXMgaXNPYmplY3QsIGQgYXMgZGVmYXVsdHMsIGIgYXMgaXNBcnJheSwgdiBhcyB2YWx1ZU9yRGVmYXVsdCwgdSBhcyB1bmxpc3RlbkFycmF5RXZlbnRzLCBsIGFzIGxpc3RlbkFycmF5RXZlbnRzLCBmIGFzIHJlc29sdmVPYmplY3RLZXksIGcgYXMgaXNOdW1iZXJGaW5pdGUsIGggYXMgZGVmaW5lZCwgcyBhcyBzaWduLCBqIGFzIGNyZWF0ZUNvbnRleHQsIGsgYXMgaXNOdWxsT3JVbmRlZiwgXyBhcyBfYXJyYXlVbmlxdWUsIHQgYXMgdG9SYWRpYW5zLCBtIGFzIHRvUGVyY2VudGFnZSwgbiBhcyB0b0RpbWVuc2lvbiwgVCBhcyBUQVUsIG8gYXMgZm9ybWF0TnVtYmVyLCBwIGFzIF9hbmdsZUJldHdlZW4sIEggYXMgSEFMRl9QSSwgUCBhcyBQSSwgcSBhcyBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgdyBhcyBfc2NhbGVSYW5nZXNDaGFuZ2VkLCB4IGFzIGlzTnVtYmVyLCB5IGFzIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSwgeiBhcyBnZXRSZWxhdGl2ZVBvc2l0aW9uLCBBIGFzIF9ybG9va3VwQnlLZXksIEIgYXMgX2xvb2t1cEJ5S2V5LCBDIGFzIF9pc1BvaW50SW5BcmVhLCBEIGFzIGdldEFuZ2xlRnJvbVBvaW50LCBFIGFzIHRvUGFkZGluZywgRiBhcyBlYWNoLCBHIGFzIGdldE1heGltdW1TaXplLCBJIGFzIF9nZXRQYXJlbnROb2RlLCBKIGFzIHJlYWRVc2VkU2l6ZSwgSyBhcyBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLCBMIGFzIHRocm90dGxlZCwgTSBhcyBfaXNEb21TdXBwb3J0ZWQsIE4gYXMgX2ZhY3Rvcml6ZSwgTyBhcyBmaW5pdGVPckRlZmF1bHQsIFEgYXMgY2FsbGJhY2ssIFIgYXMgX2FkZEdyYWNlLCBTIGFzIF9saW1pdFZhbHVlLCBVIGFzIHRvRGVncmVlcywgViBhcyBfbWVhc3VyZVRleHQsIFcgYXMgX2ludDE2UmFuZ2UsIFggYXMgX2FsaWduUGl4ZWwsIFkgYXMgY2xpcEFyZWEsIFogYXMgcmVuZGVyVGV4dCwgJCBhcyB1bmNsaXBBcmVhLCBhMCBhcyB0b0ZvbnQsIGExIGFzIF90b0xlZnRSaWdodENlbnRlciwgYTIgYXMgX2FsaWduU3RhcnRFbmQsIGEzIGFzIG92ZXJyaWRlcywgYTQgYXMgbWVyZ2UsIGE1IGFzIF9jYXBpdGFsaXplLCBhNiBhcyBkZXNjcmlwdG9ycywgYTcgYXMgaXNGdW5jdGlvbiwgYTggYXMgX2F0dGFjaENvbnRleHQsIGE5IGFzIF9jcmVhdGVSZXNvbHZlciwgYWEgYXMgX2Rlc2NyaXB0b3JzLCBhYiBhcyBtZXJnZUlmLCBhYyBhcyB1aWQsIGFkIGFzIGRlYm91bmNlLCBhZSBhcyByZXRpbmFTY2FsZSwgYWYgYXMgY2xlYXJDYW52YXMsIGFnIGFzIHNldHNFcXVhbCwgYWggYXMgX2VsZW1lbnRzRXF1YWwsIGFpIGFzIF9pc0NsaWNrRXZlbnQsIGFqIGFzIF9pc0JldHdlZW4sIGFrIGFzIF9yZWFkVmFsdWVUb1Byb3BzLCBhbCBhcyBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cywgYW0gYXMgX2NvbXB1dGVTZWdtZW50cywgYW4gYXMgX2JvdW5kU2VnbWVudHMsIGFvIGFzIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiwgYXAgYXMgX2JlemllckludGVycG9sYXRpb24sIGFxIGFzIF9wb2ludEluTGluZSwgYXIgYXMgX3N0ZXBwZWRMaW5lVG8sIGFzIGFzIF9iZXppZXJDdXJ2ZVRvLCBhdCBhcyBkcmF3UG9pbnQsIGF1IGFzIGFkZFJvdW5kZWRSZWN0UGF0aCwgYXYgYXMgdG9UUkJMLCBhdyBhcyB0b1RSQkxDb3JuZXJzLCBheCBhcyBfYm91bmRTZWdtZW50LCBheSBhcyBfbm9ybWFsaXplQW5nbGUsIGF6IGFzIGdldFJ0bEFkYXB0ZXIsIGFBIGFzIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgYUIgYXMgX3RleHRYLCBhQyBhcyByZXN0b3JlVGV4dERpcmVjdGlvbiwgYUQgYXMgZHJhd1BvaW50TGVnZW5kLCBhRSBhcyBkaXN0YW5jZUJldHdlZW5Qb2ludHMsIGFGIGFzIG5vb3AsIGFHIGFzIF9zZXRNaW5BbmRNYXhCeUtleSwgYUggYXMgbmljZU51bSwgYUkgYXMgYWxtb3N0V2hvbGUsIGFKIGFzIGFsbW9zdEVxdWFscywgYUsgYXMgX2RlY2ltYWxQbGFjZXMsIGFMIGFzIFRpY2tzLCBhTSBhcyBsb2cxMCwgYU4gYXMgX2xvbmdlc3RUZXh0LCBhTyBhcyBfZmlsdGVyQmV0d2VlbiwgYVAgYXMgX2xvb2t1cCB9IGZyb20gJy4vY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5qcyc7XG5pbXBvcnQgJ0BrdXJrbGUvY29sb3InO1xuXG5jbGFzcyBBbmltYXRvciB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sYXN0RGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgICAgICBjb25zdCBudW1TdGVwcyA9IGFuaW1zLmR1cmF0aW9uO1xuICAgICAgICBjYWxsYmFja3MuZm9yRWFjaCgoZm4pPT5mbih7XG4gICAgICAgICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbDogYW5pbXMuaW5pdGlhbCxcbiAgICAgICAgICAgICAgICBudW1TdGVwcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4oZGF0ZSAtIGFuaW1zLnN0YXJ0LCBudW1TdGVwcylcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gX3JlZnJlc2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKT0+e1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gX3VwZGF0ZShkYXRlID0gRGF0ZS5ub3coKSkge1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gMDtcbiAgICAgICAgdGhpcy5fY2hhcnRzLmZvckVhY2goKGFuaW1zLCBjaGFydCk9PntcbiAgICAgICAgICAgIGlmICghYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICAgICAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCBkcmF3ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgICAgIGZvcig7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uX2FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbXMuZHVyYXRpb24gPSBpdGVtLl90b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpdGVtLnRpY2soZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgICAgICAgICAgY2hhcnQuZHJhdygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdwcm9ncmVzcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgYW5pbXMuaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuIF9nZXRBbmltcyhjaGFydCkge1xuICAgICAgICBjb25zdCBjaGFydHMgPSB0aGlzLl9jaGFydHM7XG4gICAgICAgIGxldCBhbmltcyA9IGNoYXJ0cy5nZXQoY2hhcnQpO1xuICAgICAgICBpZiAoIWFuaW1zKSB7XG4gICAgICAgICAgICBhbmltcyA9IHtcbiAgICAgICAgICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogW11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltcztcbiAgICB9XG4gbGlzdGVuKGNoYXJ0LCBldmVudCwgY2IpIHtcbiAgICAgICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLmxpc3RlbmVyc1tldmVudF0ucHVzaChjYik7XG4gICAgfVxuIGFkZChjaGFydCwgaXRlbXMpIHtcbiAgICAgICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICAgIH1cbiBoYXMoY2hhcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5sZW5ndGggPiAwO1xuICAgIH1cbiBzdGFydChjaGFydCkge1xuICAgICAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgICAgICBpZiAoIWFuaW1zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIGFuaW1zLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYW5pbXMuZHVyYXRpb24gPSBhbmltcy5pdGVtcy5yZWR1Y2UoKGFjYywgY3VyKT0+TWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICB9XG4gICAgcnVubmluZyhjaGFydCkge1xuICAgICAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgICAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gc3RvcChjaGFydCkge1xuICAgICAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgICAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvcig7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgIGl0ZW1zW2ldLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIERhdGUubm93KCksICdjb21wbGV0ZScpO1xuICAgIH1cbiByZW1vdmUoY2hhcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICAgIH1cbn1cbnZhciBhbmltYXRvciA9IC8qICNfX1BVUkVfXyAqLyBuZXcgQW5pbWF0b3IoKTtcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgICBib29sZWFuIChmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3IgPiAwLjUgPyB0byA6IGZyb207XG4gICAgfSxcbiBjb2xvciAoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgICAgICBjb25zdCBjMCA9IGNvbG9yKGZyb20gfHwgdHJhbnNwYXJlbnQpO1xuICAgICAgICBjb25zdCBjMSA9IGMwLnZhbGlkICYmIGNvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIGMxICYmIGMxLnZhbGlkID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpIDogdG87XG4gICAgfSxcbiAgICBudW1iZXIgKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcbiAgICB9XG59O1xuY2xhc3MgQW5pbWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihjZmcsIHRhcmdldCwgcHJvcCwgdG8pe1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgIHRvID0gcmVzb2x2ZShbXG4gICAgICAgICAgICBjZmcudG8sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgIGNmZy5mcm9tXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBmcm9tID0gcmVzb2x2ZShbXG4gICAgICAgICAgICBjZmcuZnJvbSxcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgIHRvXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICAgICAgdGhpcy5fZWFzaW5nID0gZWZmZWN0c1tjZmcuZWFzaW5nXSB8fCBlZmZlY3RzLmxpbmVhcjtcbiAgICAgICAgdGhpcy5fc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgKyAoY2ZnLmRlbGF5IHx8IDApKTtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLl90byA9IHRvO1xuICAgICAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdO1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbiA9IHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gZGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyZW1haW4sIGNmZy5kdXJhdGlvbikpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWwgKz0gZWxhcHNlZDtcbiAgICAgICAgICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgICAgICAgICAgdGhpcy5fdG8gPSByZXNvbHZlKFtcbiAgICAgICAgICAgICAgICBjZmcudG8sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLFxuICAgICAgICAgICAgICAgIGNmZy5mcm9tXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRoaXMuX2Zyb20gPSByZXNvbHZlKFtcbiAgICAgICAgICAgICAgICBjZmcuZnJvbSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgdG9cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy50aWNrKERhdGUubm93KCkpO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRpY2soZGF0ZSkge1xuICAgICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICBjb25zdCBwcm9wID0gdGhpcy5fcHJvcDtcbiAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgICAgICBjb25zdCB0byA9IHRoaXMuX3RvO1xuICAgICAgICBsZXQgZmFjdG9yO1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmcm9tICE9PSB0byAmJiAobG9vcCB8fCBlbGFwc2VkIDwgZHVyYXRpb24pO1xuICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdG87XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnkodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsYXBzZWQgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSBmcm9tO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZhY3RvciA9IGVsYXBzZWQgLyBkdXJhdGlvbiAlIDI7XG4gICAgICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgICAgIGZhY3RvciA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmYWN0b3IpKSk7XG4gICAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRoaXMuX2ZuKGZyb20sIHRvLCBmYWN0b3IpO1xuICAgIH1cbiAgICB3YWl0KCkge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaik9PntcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlcyxcbiAgICAgICAgICAgICAgICByZWpcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgICAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgW107XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFuaW1hdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpe1xuICAgICAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICAgIH1cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5hbmltYXRpb24pO1xuICAgICAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBjb25zdCBjZmcgPSBjb25maWdba2V5XTtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoY2ZnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBhbmltYXRpb25PcHRpb25zKXtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFtvcHRpb25dID0gY2ZnW29wdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW1xuICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgXSkuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0ga2V5IHx8ICFhbmltYXRlZFByb3BzLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRlZFByb3BzLnNldChwcm9wLCByZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHZhbHVlcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgICAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgICAgICAgfSwgKCk9PntcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH1cbiBfY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgICAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICAgICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBydW5uaW5nID0gdGFyZ2V0LiRhbmltYXRpb25zIHx8ICh0YXJnZXQuJGFuaW1hdGlvbnMgPSB7fSk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IoaSA9IHByb3BzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKC4uLnRoaXMuX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgICAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bm5pbmdbcHJvcF0gPSBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGNmZywgdGFyZ2V0LCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9XG4gdXBkYXRlKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhbmltYXRvci5hZGQodGhpcy5fY2hhcnQsIGFuaW1hdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgcnVubmluZyA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGFuaW0gPSBhbmltYXRpb25zW2tleXNbaV1dO1xuICAgICAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChydW5uaW5nKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucykge1xuICAgIGlmICghbmV3T3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICRzaGFyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgJGFuaW1hdGlvbnM6IHt9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gc2NhbGVDbGlwKHNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByZXZlcnNlID0gb3B0cy5yZXZlcnNlO1xuICAgIGNvbnN0IG1pbiA9IG9wdHMubWluID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICAgIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgICAgICBlbmQ6IHJldmVyc2UgPyBtaW4gOiBtYXhcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICAgIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeCA9IHNjYWxlQ2xpcCh4U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gICAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB5LmVuZCxcbiAgICAgICAgcmlnaHQ6IHguZW5kLFxuICAgICAgICBib3R0b206IHkuc3RhcnQsXG4gICAgICAgIGxlZnQ6IHguc3RhcnRcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XG4gICAgbGV0IHQsIHIsIGIsIGw7XG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB0ID0gdmFsdWUudG9wO1xuICAgICAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgICAgIGwgPSB2YWx1ZS5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSByID0gYiA9IGwgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0LFxuICAgICAgICByaWdodDogcixcbiAgICAgICAgYm90dG9tOiBiLFxuICAgICAgICBsZWZ0OiBsLFxuICAgICAgICBkaXNhYmxlZDogdmFsdWUgPT09IGZhbHNlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBrZXlzLnB1c2gobWV0YXNldHNbaV0uaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBkc0luZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgICBjb25zdCBzaW5nbGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnc2luZ2xlJztcbiAgICBsZXQgaSwgaWxlbiwgZGF0YXNldEluZGV4LCBvdGhlclZhbHVlO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvcihpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgZGF0YXNldEluZGV4ID0gK2tleXNbaV07XG4gICAgICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgICAgICBpZiAoaXNOdW1iZXJGaW5pdGUob3RoZXJWYWx1ZSkgJiYgKHNpbmdsZU1vZGUgfHwgdmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBsZXQgaSwgaWxlbiwga2V5O1xuICAgIGZvcihpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgYWRhdGFbaV0gPSB7XG4gICAgICAgICAgICB4OiBrZXksXG4gICAgICAgICAgICB5OiBkYXRhW2tleV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXRhO1xufVxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gICAgY29uc3Qgc3RhY2tlZCA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICByZXR1cm4gc3RhY2tlZCB8fCBzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICAgIHJldHVybiBgJHtpbmRleFNjYWxlLmlkfS4ke3ZhbHVlU2NhbGUuaWR9LiR7bWV0YS5zdGFjayB8fCBtZXRhLnR5cGV9YDtcbn1cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgICBjb25zdCB7IG1pbiAsIG1heCAsIG1pbkRlZmluZWQgLCBtYXhEZWZpbmVkICB9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICAgIGNvbnN0IHN1YlN0YWNrID0gc3RhY2tzW3N0YWNrS2V5XSB8fCAoc3RhY2tzW3N0YWNrS2V5XSA9IHt9KTtcbiAgICByZXR1cm4gc3ViU3RhY2tbaW5kZXhWYWx1ZV0gfHwgKHN1YlN0YWNrW2luZGV4VmFsdWVdID0ge30pO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSwgdHlwZSkge1xuICAgIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKXtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIHZhbHVlID4gMCB8fCAhcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgICBjb25zdCB7IGNoYXJ0ICwgX2NhY2hlZE1ldGE6IG1ldGEgIH0gPSBjb250cm9sbGVyO1xuICAgIGNvbnN0IHN0YWNrcyA9IGNoYXJ0Ll9zdGFja3MgfHwgKGNoYXJ0Ll9zdGFja3MgPSB7fSk7XG4gICAgY29uc3QgeyBpU2NhbGUgLCB2U2NhbGUgLCBpbmRleDogZGF0YXNldEluZGV4ICB9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICAgIGNvbnN0IGlsZW4gPSBwYXJzZWQubGVuZ3RoO1xuICAgIGxldCBzdGFjaztcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgY29uc3QgaXRlbSA9IHBhcnNlZFtpXTtcbiAgICAgICAgY29uc3QgeyBbaUF4aXNdOiBpbmRleCAsIFt2QXhpc106IHZhbHVlICB9ID0gaXRlbTtcbiAgICAgICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xuICAgICAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgICAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XG4gICAgICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlLCBtZXRhLnR5cGUpO1xuICAgICAgICBjb25zdCB2aXN1YWxWYWx1ZXMgPSBzdGFjay5fdmlzdWFsVmFsdWVzIHx8IChzdGFjay5fdmlzdWFsVmFsdWVzID0ge30pO1xuICAgICAgICB2aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZChjaGFydCwgYXhpcykge1xuICAgIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoKGtleSk9PnNjYWxlc1trZXldLmF4aXMgPT09IGF4aXMpLnNoaWZ0KCk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgICAgICByYXc6IHVuZGVmaW5lZCxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgICAgdHlwZTogJ2RhdGEnXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjbGVhclN0YWNrcyhtZXRhLCBpdGVtcykge1xuICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgICBpZiAoIWF4aXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgICBmb3IgKGNvbnN0IHBhcnNlZCBvZiBpdGVtcyl7XG4gICAgICAgIGNvbnN0IHN0YWNrcyA9IHBhcnNlZC5fc3RhY2tzO1xuICAgICAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xuICAgICAgICBpZiAoc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXMgIT09IHVuZGVmaW5lZCAmJiBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpPT5tb2RlID09PSAncmVzZXQnIHx8IG1vZGUgPT09ICdub25lJztcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpPT5zaGFyZWQgPyBjYWNoZWQgOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZWQpO1xuY29uc3QgY3JlYXRlU3RhY2sgPSAoY2FuU3RhY2ssIG1ldGEsIGNoYXJ0KT0+Y2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWQgJiYge1xuICAgICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICAgIHZhbHVlczogbnVsbFxuICAgIH07XG5jbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gc3RhdGljIGRlZmF1bHRzID0ge307XG4gc3RhdGljIGRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG4gc3RhdGljIGRhdGFFbGVtZW50VHlwZSA9IG51bGw7XG4gY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCl7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICAgICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xuICAgICAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgICAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgICAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fb2JqZWN0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9kcmF3Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YXNldEVsZW1lbnRUeXBlO1xuICAgICAgICB0aGlzLmRhdGFFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YUVsZW1lbnRUeXBlO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgICAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZpbGwgJiYgIXRoaXMuY2hhcnQuaXNQbHVnaW5FbmFibGVkKCdmaWxsZXInKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gdXNlIHRoZSAnZmlsbCcgb3B0aW9uIHdpdGhvdXQgdGhlICdGaWxsZXInIHBsdWdpbiBlbmFibGVkLiBQbGVhc2UgaW1wb3J0IGFuZCByZWdpc3RlciB0aGUgJ0ZpbGxlcicgcGx1Z2luIGFuZCBtYWtlIHN1cmUgaXQgaXMgbm90IGRpc2FibGVkIGluIHRoZSBvcHRpb25zXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICAgICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIH1cbiAgICBsaW5rU2NhbGVzKCkge1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpPT5heGlzID09PSAneCcgPyB4IDogYXhpcyA9PT0gJ3InID8gciA6IHk7XG4gICAgICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICAgICAgY29uc3QgeWlkID0gbWV0YS55QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC55QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd5JykpO1xuICAgICAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgICAgICBjb25zdCBpaWQgPSBtZXRhLmlBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHhpZCwgeWlkLCByaWQpO1xuICAgICAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgICAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgICAgICBtZXRhLnlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh5aWQpO1xuICAgICAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgICAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgICAgICBtZXRhLnZTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh2aWQpO1xuICAgIH1cbiAgICBnZXREYXRhc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICAgIH1cbiAgICBnZXRNZXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgICB9XG4gZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcbiAgICB9XG4gX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIHJldHVybiBzY2FsZSA9PT0gbWV0YS5pU2NhbGUgPyBtZXRhLnZTY2FsZSA6IG1ldGEuaVNjYWxlO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCdyZXNldCcpO1xuICAgIH1cbiBfZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiBfZGF0YUNoZWNrKCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICAgICAgY29uc3QgX2RhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICAgICAgICAgIHVubGlzdGVuQXJyYXlFdmVudHMoX2RhdGEsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICAgICAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgICAgICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbkFycmF5RXZlbnRzKGRhdGEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEVsZW1lbnRzKCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgbWV0YS5kYXRhc2V0ID0gbmV3IHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICAgICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICAgICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgICAgICBpZiAobWV0YS5zdGFjayAhPT0gZGF0YXNldC5zdGFjaykge1xuICAgICAgICAgICAgc3RhY2tDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgICAgICAgbWV0YS5zdGFjayA9IGRhdGFzZXQuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG4gICAgICAgIGlmIChzdGFja0NoYW5nZWQgfHwgb2xkU3RhY2tlZCAhPT0gbWV0YS5fc3RhY2tlZCkge1xuICAgICAgICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIG1ldGEuX3BhcnNlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gY29uZmlndXJlKCkge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cywgdHJ1ZSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICAgICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgICAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIH1cbiBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICAgICAgY29uc3QgeyBfY2FjaGVkTWV0YTogbWV0YSAsIF9kYXRhOiBkYXRhICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBpU2NhbGUgLCBfc3RhY2tlZCAgfSA9IG1ldGE7XG4gICAgICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgICAgICBsZXQgcHJldiA9IHN0YXJ0ID4gMCAmJiBtZXRhLl9wYXJzZWRbc3RhcnQgLSAxXTtcbiAgICAgICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuICAgICAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgICAgICAgICBtZXRhLl9zb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcGFyc2VkID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCk9PmN1cltpQXhpc10gPT09IG51bGwgfHwgcHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc107XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBjb3VudDsgKytpKXtcbiAgICAgICAgICAgICAgICBtZXRhLl9wYXJzZWRbaSArIHN0YXJ0XSA9IGN1ciA9IHBhcnNlZFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgICAgICB9XG4gICAgfVxuIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICAgICAgY29uc3QgeyBpU2NhbGUgLCB2U2NhbGUgIH0gPSBtZXRhO1xuICAgICAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgICAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgICAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGxldCBpLCBpbGVuLCBpbmRleDtcbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICAgICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgICAgICAgICAgW2lBeGlzXTogc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpbmRleF0sIGluZGV4KSxcbiAgICAgICAgICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICAgICAgY29uc3QgeyB4U2NhbGUgLCB5U2NhbGUgIH0gPSBtZXRhO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICAgICAgICAgIHg6IHhTY2FsZS5wYXJzZShpdGVtWzBdLCBpbmRleCksXG4gICAgICAgICAgICAgICAgeTogeVNjYWxlLnBhcnNlKGl0ZW1bMV0sIGluZGV4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHsgeFNjYWxlICwgeVNjYWxlICB9ID0gbWV0YTtcbiAgICAgICAgY29uc3QgeyB4QXhpc0tleSA9J3gnICwgeUF4aXNLZXkgPSd5JyAgfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICAgICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgICAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgICAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpbmRleClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gZ2V0UGFyc2VkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICAgIH1cbiBnZXREYXRhRWxlbWVudChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICB9XG4gYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgICAgICBjb25zdCBzdGFjayA9IHtcbiAgICAgICAgICAgIGtleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSxcbiAgICAgICAgICAgIHZhbHVlczogcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc10uX3Zpc3VhbFZhbHVlc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHtcbiAgICAgICAgICAgIG1vZGVcbiAgICAgICAgfSk7XG4gICAgfVxuIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHN0YWNrICYmIHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdO1xuICAgICAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICAgICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIHZhbHVlKTtcbiAgICAgICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gICAgfVxuIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgICAgIGNvbnN0IGlsZW4gPSBfcGFyc2VkLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgICAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgICAgICBtaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgbWluOiBvdGhlck1pbiAsIG1heDogb3RoZXJNYXggIH0gPSBnZXRVc2VyQm91bmRzKG90aGVyU2NhbGUpO1xuICAgICAgICBsZXQgaSwgcGFyc2VkO1xuICAgICAgICBmdW5jdGlvbiBfc2tpcCgpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IF9wYXJzZWRbaV07XG4gICAgICAgICAgICBjb25zdCBvdGhlclZhbHVlID0gcGFyc2VkW290aGVyU2NhbGUuYXhpc107XG4gICAgICAgICAgICByZXR1cm4gIWlzTnVtYmVyRmluaXRlKHBhcnNlZFtzY2FsZS5heGlzXSkgfHwgb3RoZXJNaW4gPiBvdGhlclZhbHVlIHx8IG90aGVyTWF4IDwgb3RoZXJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgICAgZm9yKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpe1xuICAgICAgICAgICAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZDtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gcGFyc2VkLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgICAgICAgIGlmIChpc051bWJlckZpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogaVNjYWxlID8gJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSA6ICcnLFxuICAgICAgICAgICAgdmFsdWU6IHZTY2FsZSA/ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSkgOiAnJ1xuICAgICAgICB9O1xuICAgIH1cbiBfdXBkYXRlKG1vZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIHRoaXMudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICAgICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gICAgfVxuIHVwZGF0ZShtb2RlKSB7fVxuICAgIGRyYXcoKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2RyYXdTdGFydCB8fCAwO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCBlbGVtZW50cy5sZW5ndGggLSBzdGFydDtcbiAgICAgICAgY29uc3QgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0aGlzLm9wdGlvbnMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3A7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICAgICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSl7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSAmJiBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgYWN0aXZlW2ldLmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgICAgfVxuICAgIH1cbiBnZXRTdHlsZShpbmRleCwgYWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0ID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIDogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4IHx8IDAsIG1vZGUpO1xuICAgIH1cbiBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgICAgICBsZXQgY29udGV4dDtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8IChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICAgICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgICAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgICAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICAgICAgY29udGV4dC5tb2RlID0gbW9kZTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuIHJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCBtb2RlKTtcbiAgICB9XG4gcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YUVsZW1lbnRUeXBlLmlkLCBtb2RlLCBpbmRleCk7XG4gICAgfVxuIF9yZXNvbHZlRWxlbWVudE9wdGlvbnMoZWxlbWVudFR5cGUsIG1vZGUgPSAnZGVmYXVsdCcsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGVsZW1lbnRUeXBlICsgJy0nICsgbW9kZTtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVJZk5vdFNoYXJlZChjYWNoZWQsIHNoYXJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEVsZW1lbnRTY29wZUtleXModGhpcy5fdHlwZSwgZWxlbWVudFR5cGUpO1xuICAgICAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtcbiAgICAgICAgICAgIGAke2VsZW1lbnRUeXBlfUhvdmVyYCxcbiAgICAgICAgICAgICdob3ZlcicsXG4gICAgICAgICAgICBlbGVtZW50VHlwZSxcbiAgICAgICAgICAgICcnXG4gICAgICAgIF0gOiBbXG4gICAgICAgICAgICBlbGVtZW50VHlwZSxcbiAgICAgICAgICAgICcnXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuZWxlbWVudHNbZWxlbWVudFR5cGVdKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9ICgpPT50aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGNvbmZpZy5yZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzKTtcbiAgICAgICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMuJHNoYXJlZCA9IHNoYXJpbmc7XG4gICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICAgICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCB0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICAgICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnMoY2hhcnQsIG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH1cbiBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgICB9XG4gaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICB9XG4gX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgICAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB8fCBzaGFyZWRPcHRpb25zICE9PSBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucztcbiAgICAgICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaGFyZWRPcHRpb25zLFxuICAgICAgICAgICAgaW5jbHVkZU9wdGlvbnNcbiAgICAgICAgfTtcbiAgICB9XG4gdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgICAgICBpZiAoaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUpLnVwZGF0ZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICAgICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCBtb2RlLCBhY3RpdmUpIHtcbiAgICAgICAgZWxlbWVudC5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSwgYWN0aXZlKS51cGRhdGUoZWxlbWVudCwge1xuICAgICAgICAgICAgb3B0aW9uczogIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykgfHwgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlSG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgICBzZXRIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgICB9XG4gX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuIF9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICAgICAgZm9yIChjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSBvZiB0aGlzLl9zeW5jTGlzdCl7XG4gICAgICAgICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICAgICAgY29uc3QgbnVtTWV0YSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuICAgICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2UoMCwgY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEsIHJlc2V0TmV3RWxlbWVudHMpO1xuICAgICAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gX2luc2VydEVsZW1lbnRzKHN0YXJ0LCBjb3VudCwgcmVzZXROZXdFbGVtZW50cyA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBtb3ZlID0gKGFycik9PntcbiAgICAgICAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XG4gICAgICAgICAgICBmb3IoaSA9IGFyci5sZW5ndGggLSAxOyBpID49IGVuZDsgaS0tKXtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBhcnJbaSAtIGNvdW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbW92ZShkYXRhKTtcbiAgICAgICAgZm9yKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKXtcbiAgICAgICAgICAgIGRhdGFbaV0gPSBuZXcgdGhpcy5kYXRhRWxlbWVudFR5cGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgICAgICAgbW92ZShtZXRhLl9wYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgICAgaWYgKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZGF0YSwgc3RhcnQsIGNvdW50LCAncmVzZXQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9XG4gX3JlbW92ZUVsZW1lbnRzKHN0YXJ0LCBjb3VudCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICAgICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICAgICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGEuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICB9XG4gX3N5bmMoYXJncykge1xuICAgICAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgICAgICAgdGhpcy5fc3luY0xpc3QucHVzaChhcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBfb25EYXRhUHVzaCgpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9zeW5jKFtcbiAgICAgICAgICAgICdfaW5zZXJ0RWxlbWVudHMnLFxuICAgICAgICAgICAgdGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSBjb3VudCxcbiAgICAgICAgICAgIGNvdW50XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBfb25EYXRhUG9wKCkge1xuICAgICAgICB0aGlzLl9zeW5jKFtcbiAgICAgICAgICAgICdfcmVtb3ZlRWxlbWVudHMnLFxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAxXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBfb25EYXRhU2hpZnQoKSB7XG4gICAgICAgIHRoaXMuX3N5bmMoW1xuICAgICAgICAgICAgJ19yZW1vdmVFbGVtZW50cycsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zeW5jKFtcbiAgICAgICAgICAgICAgICAnX3JlbW92ZUVsZW1lbnRzJyxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBjb3VudFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgICAgaWYgKG5ld0NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zeW5jKFtcbiAgICAgICAgICAgICAgICAnX2luc2VydEVsZW1lbnRzJyxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBuZXdDb3VudFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX29uRGF0YVVuc2hpZnQoKSB7XG4gICAgICAgIHRoaXMuX3N5bmMoW1xuICAgICAgICAgICAgJ19pbnNlcnRFbGVtZW50cycsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICBdKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCB0eXBlKSB7XG4gICAgaWYgKCFzY2FsZS5fY2FjaGUuJGJhcikge1xuICAgICAgICBjb25zdCB2aXNpYmxlTWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKTtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSAwLCBpbGVuID0gdmlzaWJsZU1ldGFzLmxlbmd0aDsgaSA8IGlsZW47IGkrKyl7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKT0+YSAtIGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlLl9jYWNoZS4kYmFyO1xufVxuIGZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpIHtcbiAgICBjb25zdCBzY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCBtZXRhLnR5cGUpO1xuICAgIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICAgIGxldCBpLCBpbGVuLCBjdXJyLCBwcmV2O1xuICAgIGNvbnN0IHVwZGF0ZU1pbkFuZFByZXYgPSAoKT0+e1xuICAgICAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGN1cnI7XG4gICAgfTtcbiAgICBmb3IoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcbiAgICAgICAgdXBkYXRlTWluQW5kUHJldigpO1xuICAgIH1cbiAgICBwcmV2ID0gdW5kZWZpbmVkO1xuICAgIGZvcihpID0gMCwgaWxlbiA9IHNjYWxlLnRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG4gICAgICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbn1cbiBmdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gICAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gICAgbGV0IHNpemUsIHJhdGlvO1xuICAgIGlmIChpc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcbiAgICAgICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgICAgICByYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gdGhpY2tuZXNzICogc3RhY2tDb3VudDtcbiAgICAgICAgcmF0aW8gPSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgICAgIHJhdGlvLFxuICAgICAgICBzdGFydDogcnVsZXIucGl4ZWxzW2luZGV4XSAtIHNpemUgLyAyXG4gICAgfTtcbn1cbiBmdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICAgIGNvbnN0IHBpeGVscyA9IHJ1bGVyLnBpeGVscztcbiAgICBjb25zdCBjdXJyID0gcGl4ZWxzW2luZGV4XTtcbiAgICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgICBsZXQgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG4gICAgY29uc3QgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgIHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgbmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcbiAgICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgICAgICByYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxuICAgICAgICBzdGFydFxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgICBjb25zdCBzdGFydFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzBdLCBpKTtcbiAgICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gICAgbGV0IGJhckVuZCA9IG1heDtcbiAgICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICAgICAgYmFyU3RhcnQgPSBtYXg7XG4gICAgICAgIGJhckVuZCA9IG1pbjtcbiAgICB9XG4gICAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG4gICAgaXRlbS5fY3VzdG9tID0ge1xuICAgICAgICBiYXJTdGFydCxcbiAgICAgICAgYmFyRW5kLFxuICAgICAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICAgICAgZW5kOiBlbmRWYWx1ZSxcbiAgICAgICAgbWluLFxuICAgICAgICBtYXhcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gICAgaWYgKGlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbVt2U2NhbGUuYXhpc10gPSB2U2NhbGUucGFyc2UoZW50cnksIGkpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgaXRlbSwgZW50cnk7XG4gICAgZm9yKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgICAgIGl0ZW0gPSB7fTtcbiAgICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2ldLCBpKTtcbiAgICAgICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG59XG5mdW5jdGlvbiBpc0Zsb2F0QmFyKGN1c3RvbSkge1xuICAgIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuICh2U2NhbGUuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHZTY2FsZS5taW4gPj0gYWN0dWFsQmFzZSA/IDEgOiAtMSk7XG59XG5mdW5jdGlvbiBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKSB7XG4gICAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICAgIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcbiAgICAgICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICAgICAgc3RhcnQgPSAnbGVmdCc7XG4gICAgICAgIGVuZCA9ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA8IHByb3BlcnRpZXMueTtcbiAgICAgICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICAgICAgZW5kID0gJ3RvcCc7XG4gICAgfVxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHRvcCA9ICdlbmQnO1xuICAgICAgICBib3R0b20gPSAnc3RhcnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRvcCA9ICdzdGFydCc7XG4gICAgICAgIGJvdHRvbSA9ICdlbmQnO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICByZXZlcnNlLFxuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbVxuICAgIH07XG59XG5mdW5jdGlvbiBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCkge1xuICAgIGxldCBlZGdlID0gb3B0aW9ucy5ib3JkZXJTa2lwcGVkO1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGlmICghZWRnZSkge1xuICAgICAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkZ2UgPT09IHRydWUpIHtcbiAgICAgICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0ge1xuICAgICAgICAgICAgdG9wOiB0cnVlLFxuICAgICAgICAgICAgcmlnaHQ6IHRydWUsXG4gICAgICAgICAgICBib3R0b206IHRydWUsXG4gICAgICAgICAgICBsZWZ0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBzdGFydCAsIGVuZCAsIHJldmVyc2UgLCB0b3AgLCBib3R0b20gIH0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcbiAgICBpZiAoZWRnZSA9PT0gJ21pZGRsZScgJiYgc3RhY2spIHtcbiAgICAgICAgcHJvcGVydGllcy5lbmFibGVCb3JkZXJSYWRpdXMgPSB0cnVlO1xuICAgICAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICBlZGdlID0gdG9wO1xuICAgICAgICB9IGVsc2UgaWYgKChzdGFjay5fYm90dG9tIHx8IDApID09PSBpbmRleCkge1xuICAgICAgICAgICAgZWRnZSA9IGJvdHRvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1twYXJzZUVkZ2UoYm90dG9tLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICAgICAgICAgICAgZWRnZSA9IHRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNbcGFyc2VFZGdlKGVkZ2UsIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuZnVuY3Rpb24gcGFyc2VFZGdlKGVkZ2UsIGEsIGIsIHJldmVyc2UpIHtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICBlZGdlID0gc3dhcChlZGdlLCBhLCBiKTtcbiAgICAgICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGIsIGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBhLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2U7XG59XG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuICAgIHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5mdW5jdGlvbiBzdGFydEVuZCh2LCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cbmZ1bmN0aW9uIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywgeyBpbmZsYXRlQW1vdW50ICB9LCByYXRpbykge1xuICAgIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJyA/IHJhdGlvID09PSAxID8gMC4zMyA6IDAgOiBpbmZsYXRlQW1vdW50O1xufVxuY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgaWQgPSAnYmFyJztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgICAgIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG4gICAgICAgIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICAgICAgICBiYXJQZXJjZW50YWdlOiAwLjksXG4gICAgICAgIGdyb3VwZWQ6IHRydWUsXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICd4JyxcbiAgICAgICAgICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgICAgICAgICAnYmFzZScsXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICAgICAgICdoZWlnaHQnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgIF9pbmRleF86IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdmFsdWVfOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICAgICAgY29uc3QgeyBpU2NhbGUgLCB2U2NhbGUgIH0gPSBtZXRhO1xuICAgICAgICBjb25zdCB7IHhBeGlzS2V5ID0neCcgLCB5QXhpc0tleSA9J3knICB9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICAgICAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgICAgIGZvcihpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIG9iaiA9IGRhdGFbaV07XG4gICAgICAgICAgICBpdGVtID0ge307XG4gICAgICAgICAgICBpdGVtW2lTY2FsZS5heGlzXSA9IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgaUF4aXNLZXkpLCBpKTtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUocmVzb2x2ZU9iamVjdEtleShvYmosIHZBeGlzS2V5KSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgICAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgICAgIGlmIChjdXN0b20gJiYgc2NhbGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlKSB7XG4gICAgICAgICAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIGN1c3RvbS5taW4pO1xuICAgICAgICAgICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCBjdXN0b20ubWF4KTtcbiAgICAgICAgfVxuICAgIH1cbiBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IHsgaVNjYWxlICwgdlNjYWxlICB9ID0gbWV0YTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpc0Zsb2F0QmFyKGN1c3RvbSkgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJyA6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIG1ldGEuc3RhY2sgPSB0aGlzLmdldERhdGFzZXQoKS5zdGFjaztcbiAgICB9XG4gICAgdXBkYXRlKG1vZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMobWV0YS5kYXRhLCAwLCBtZXRhLmRhdGEubGVuZ3RoLCBtb2RlKTtcbiAgICB9XG4gICAgdXBkYXRlRWxlbWVudHMoYmFycywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICAgICAgY29uc3QgeyBpbmRleCAsIF9jYWNoZWRNZXRhOiB7IHZTY2FsZSAgfSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgIGNvbnN0IHJ1bGVyID0gdGhpcy5fZ2V0UnVsZXIoKTtcbiAgICAgICAgY29uc3QgeyBzaGFyZWRPcHRpb25zICwgaW5jbHVkZU9wdGlvbnMgIH0gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICAgICAgZm9yKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspe1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICAgICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtcbiAgICAgICAgICAgICAgICBiYXNlLFxuICAgICAgICAgICAgICAgIGhlYWQ6IGJhc2VcbiAgICAgICAgICAgIH0gOiB0aGlzLl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpKTtcbiAgICAgICAgICAgIGNvbnN0IGlwaXhlbHMgPSB0aGlzLl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpLCBydWxlcik7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IChwYXJzZWQuX3N0YWNrcyB8fCB7fSlbdlNjYWxlLmF4aXNdO1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICAgICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgICAgICAgICBlbmFibGVCb3JkZXJSYWRpdXM6ICFzdGFjayB8fCBpc0Zsb2F0QmFyKHBhcnNlZC5fY3VzdG9tKSB8fCBpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSxcbiAgICAgICAgICAgICAgICB4OiBob3Jpem9udGFsID8gdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXIsXG4gICAgICAgICAgICAgICAgeTogaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogdnBpeGVscy5oZWFkLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgICAgICAgICAgd2lkdGg6IGhvcml6b250YWwgPyBNYXRoLmFicyh2cGl4ZWxzLnNpemUpIDogaXBpeGVscy5zaXplXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYmFyc1tpXS5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XG4gICAgICAgICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICAgICAgICBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIHJ1bGVyLnJhdGlvKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgICAgICBjb25zdCB7IGlTY2FsZSAgfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IG1ldGFzZXRzID0gaVNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpLmZpbHRlcigobWV0YSk9Pm1ldGEuY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpO1xuICAgICAgICBjb25zdCBzdGFja2VkID0gaVNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICAgICAgY29uc3Qgc3RhY2tzID0gW107XG4gICAgICAgIGNvbnN0IHNraXBOdWxsID0gKG1ldGEpPT57XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGRhdGFJbmRleCk7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBwYXJzZWQgJiYgcGFyc2VkW21ldGEudlNjYWxlLmF4aXNdO1xuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiBtZXRhc2V0cyl7XG4gICAgICAgICAgICBpZiAoZGF0YUluZGV4ICE9PSB1bmRlZmluZWQgJiYgc2tpcE51bGwobWV0YSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHwgc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrcztcbiAgICB9XG4gX2dldFN0YWNrQ291bnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XG4gICAgfVxuIF9nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbmFtZSwgZGF0YUluZGV4KSB7XG4gICAgICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZSAhPT0gdW5kZWZpbmVkID8gc3RhY2tzLmluZGV4T2YobmFtZSkgOiAtMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IHN0YWNrcy5sZW5ndGggLSAxIDogaW5kZXg7XG4gICAgfVxuIF9nZXRSdWxlcigpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgICAgICBjb25zdCBwaXhlbHMgPSBbXTtcbiAgICAgICAgbGV0IGksIGlsZW47XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgICAgIGNvbnN0IG1pbiA9IGJhclRoaWNrbmVzcyB8fCBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIHBpeGVscyxcbiAgICAgICAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICAgICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICAgICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICAgICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgICAgICB9O1xuICAgIH1cbiBfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgeyBfY2FjaGVkTWV0YTogeyB2U2NhbGUgLCBfc3RhY2tlZCAsIGluZGV4OiBkYXRhc2V0SW5kZXggIH0gLCBvcHRpb25zOiB7IGJhc2U6IGJhc2VWYWx1ZSAsIG1pbkJhckxlbmd0aCAgfSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGFjdHVhbEJhc2UgPSBiYXNlVmFsdWUgfHwgMDtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICAgICAgY29uc3QgZmxvYXRpbmcgPSBpc0Zsb2F0QmFyKGN1c3RvbSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGxldCBsZW5ndGggPSBfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogdmFsdWU7XG4gICAgICAgIGxldCBoZWFkLCBzaXplO1xuICAgICAgICBpZiAobGVuZ3RoICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgc3RhcnQgPSBsZW5ndGggLSB2YWx1ZTtcbiAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbG9hdGluZykge1xuICAgICAgICAgICAgdmFsdWUgPSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICAgICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRWYWx1ZSA9ICFpc051bGxPclVuZGVmKGJhc2VWYWx1ZSkgJiYgIWZsb2F0aW5nID8gYmFzZVZhbHVlIDogc3RhcnQ7XG4gICAgICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICAgICAgaGVhZCA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQgPSBiYXNlO1xuICAgICAgICB9XG4gICAgICAgIHNpemUgPSBoZWFkIC0gYmFzZTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICAgICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgICAgICAgICAgYmFzZSAtPSBzaXplIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDApO1xuICAgICAgICAgICAgY29uc3QgZW5kUGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDEpO1xuICAgICAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgICAgICAgYmFzZSA9IE1hdGgubWF4KE1hdGgubWluKGJhc2UsIG1heCksIG1pbik7XG4gICAgICAgICAgICBoZWFkID0gYmFzZSArIHNpemU7XG4gICAgICAgICAgICBpZiAoX3N0YWNrZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLl9zdGFja3NbdlNjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZTY2FsZS5nZXRWYWx1ZUZvclBpeGVsKGhlYWQpIC0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2UgPT09IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGFjdHVhbEJhc2UpKSB7XG4gICAgICAgICAgICBjb25zdCBoYWxmR3JpZCA9IHNpZ24oc2l6ZSkgKiB2U2NhbGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYWN0dWFsQmFzZSkgLyAyO1xuICAgICAgICAgICAgYmFzZSArPSBoYWxmR3JpZDtcbiAgICAgICAgICAgIHNpemUgLT0gaGFsZkdyaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBiYXNlLFxuICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG4gICAgICAgIH07XG4gICAgfVxuIF9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpbmRleCwgcnVsZXIpIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3Qgc2tpcE51bGwgPSBvcHRpb25zLnNraXBOdWxsO1xuICAgICAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgICAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgICAgICBpZiAocnVsZXIuZ3JvdXBlZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHNraXBOdWxsID8gdGhpcy5fZ2V0U3RhY2tDb3VudChpbmRleCkgOiBydWxlci5zdGFja0NvdW50O1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLmJhclRoaWNrbmVzcyA9PT0gJ2ZsZXgnID8gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCk7XG4gICAgICAgICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgcmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4ICsgcmFuZ2UuY2h1bmsgLyAyO1xuICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgICAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgICAgICAgY2VudGVyLFxuICAgICAgICAgICAgc2l6ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgICAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvcig7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlY3RzW2ldLmRyYXcodGhpcy5fY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQnViYmxlQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgaWQgPSAnYnViYmxlJztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgbnVtYmVyczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ3gnLFxuICAgICAgICAgICAgICAgICAgICAneScsXG4gICAgICAgICAgICAgICAgICAgICdib3JkZXJXaWR0aCcsXG4gICAgICAgICAgICAgICAgICAgICdyYWRpdXMnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgfVxuIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgICAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbVsyXSwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICAgICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW0gJiYgaXRlbS5yICYmICtpdGVtLnIsIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gICAgfVxuIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgICAgIGNvbnN0IHsgeFNjYWxlICwgeVNjYWxlICB9ID0gbWV0YTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgICAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgICAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgICAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAociA/ICcsICcgKyByIDogJycpICsgJyknXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZShtb2RlKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICAgIH1cbiAgICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgICAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgICAgIGNvbnN0IHsgaVNjYWxlICwgdlNjYWxlICB9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgeyBzaGFyZWRPcHRpb25zICwgaW5jbHVkZU9wdGlvbnMgIH0gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICAgICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICAgICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICAgICAgZm9yKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspe1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSAhcmVzZXQgJiYgdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICAgICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMucmFkaXVzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgICB9XG4gICAgfVxuIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgICBsZXQgdmFsdWVzID0gc3VwZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSk7XG4gICAgICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7XG4gICAgICAgICAgICAgICAgJHNoYXJlZDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgICAgIGlmIChtb2RlICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgdmFsdWVzLnJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KSB7XG4gICAgbGV0IHJhdGlvWCA9IDE7XG4gICAgbGV0IHJhdGlvWSA9IDE7XG4gICAgbGV0IG9mZnNldFggPSAwO1xuICAgIGxldCBvZmZzZXRZID0gMDtcbiAgICBpZiAoY2lyY3VtZmVyZW5jZSA8IFRBVSkge1xuICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICBjb25zdCBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICAgICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICAgICAgY29uc3QgZW5kWSA9IE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgICAgICAgY29uc3QgY2FsY01heCA9IChhbmdsZSwgYSwgYik9Pl9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICAgICAgY29uc3QgY2FsY01pbiA9IChhbmdsZSwgYSwgYik9Pl9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IC0xIDogTWF0aC5taW4oYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgICAgIGNvbnN0IG1heFkgPSBjYWxjTWF4KEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgICAgIGNvbnN0IG1pblggPSBjYWxjTWluKFBJLCBzdGFydFgsIGVuZFgpO1xuICAgICAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgICAgIHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xuICAgICAgICByYXRpb1kgPSAobWF4WSAtIG1pblkpIC8gMjtcbiAgICAgICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICAgICAgb2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmF0aW9YLFxuICAgICAgICByYXRpb1ksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFlcbiAgICB9O1xufVxuY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBpZCA9ICdkb3VnaG51dCc7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgICAgICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICAgICAgICBhbmltYXRlU2NhbGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICdjaXJjdW1mZXJlbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICAgICAgICAgICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICAneCcsXG4gICAgICAgICAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICAgICAgICAgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICdib3JkZXJXaWR0aCcsXG4gICAgICAgICAgICAgICAgICAgICdzcGFjaW5nJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3V0b3V0OiAnNTAlJyxcbiAgICAgICAgcm90YXRpb246IDAsXG4gICAgICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgICAgICAgcmFkaXVzOiAnMTAwJScsXG4gICAgICAgIHNwYWNpbmc6IDAsXG4gICAgICAgIGluZGV4QXhpczogJ3InXG4gICAgfTtcbiAgICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSk9Pm5hbWUgIT09ICdzcGFjaW5nJyxcbiAgICAgICAgX2luZGV4YWJsZTogKG5hbWUpPT5uYW1lICE9PSAnc3BhY2luZycgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYm9yZGVyRGFzaCcpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2hvdmVyQm9yZGVyRGFzaCcpXG4gICAgfTtcbiBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgICAgICBhc3BlY3RSYXRpbzogMSxcbiAgICAgICAgcGx1Z2luczoge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTGFiZWxzIChjaGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBsYWJlbHM6IHsgcG9pbnRTdHlsZSAsIGNvbG9yICB9ICB9ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrIChlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KXtcbiAgICAgICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub2Zmc2V0WCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsaW5rU2NhbGVzKCkge31cbiBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZ2V0dGVyID0gKGkpPT4rZGF0YVtpXTtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleSA9J3ZhbHVlJyAgfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgICAgICAgICAgZ2V0dGVyID0gKGkpPT4rcmVzb2x2ZU9iamVjdEtleShkYXRhW2ldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGksIGlsZW47XG4gICAgICAgICAgICBmb3IoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICAgICAgbWV0YS5fcGFyc2VkW2ldID0gZ2V0dGVyKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuIF9nZXRSb3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gICAgfVxuIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgICAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5jaXJjdW1mZXJlbmNlKTtcbiAgICB9XG4gX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICAgICAgbGV0IG1pbiA9IFRBVTtcbiAgICAgICAgbGV0IG1heCA9IC1UQVU7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLnR5cGUgPT09IHRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdGF0aW9uID0gY29udHJvbGxlci5fZ2V0Um90YXRpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gY29udHJvbGxlci5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm90YXRpb24gKyBjaXJjdW1mZXJlbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm90YXRpb246IG1pbixcbiAgICAgICAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pblxuICAgICAgICB9O1xuICAgIH1cbiB1cGRhdGUobW9kZSkge1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IHsgY2hhcnRBcmVhICB9ID0gY2hhcnQ7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXRNYXhCb3JkZXJXaWR0aCgpICsgdGhpcy5nZXRNYXhPZmZzZXQoYXJjcykgKyB0aGlzLm9wdGlvbnMuc3BhY2luZztcbiAgICAgICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KChNYXRoLm1pbihjaGFydEFyZWEud2lkdGgsIGNoYXJ0QXJlYS5oZWlnaHQpIC0gc3BhY2luZykgLyAyLCAwKTtcbiAgICAgICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcbiAgICAgICAgY29uc3QgY2hhcnRXZWlnaHQgPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHRoaXMuaW5kZXgpO1xuICAgICAgICBjb25zdCB7IGNpcmN1bWZlcmVuY2UgLCByb3RhdGlvbiAgfSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpO1xuICAgICAgICBjb25zdCB7IHJhdGlvWCAsIHJhdGlvWSAsIG9mZnNldFggLCBvZmZzZXRZICB9ID0gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCk7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSAoY2hhcnRBcmVhLmhlaWdodCAtIHNwYWNpbmcpIC8gcmF0aW9ZO1xuICAgICAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgbWF4SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgICAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0aGlzLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCk7XG4gICAgICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICAgICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuICAgICAgICBtZXRhLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpO1xuICAgICAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpO1xuICAgICAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gICAgfVxuIF9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgICAgICBpZiAocmVzZXQgJiYgb3B0cy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSB8fCAhdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSB8fCBtZXRhLl9wYXJzZWRbaV0gPT09IG51bGwgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgICB9XG4gICAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgICAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgICAgICBjb25zdCBhbmltYXRlU2NhbGUgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZTtcbiAgICAgICAgY29uc3QgaW5uZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5pbm5lclJhZGl1cztcbiAgICAgICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5vdXRlclJhZGl1cztcbiAgICAgICAgY29uc3QgeyBzaGFyZWRPcHRpb25zICwgaW5jbHVkZU9wdGlvbnMgIH0gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICAgICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSl7XG4gICAgICAgICAgICBzdGFydEFuZ2xlICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpe1xuICAgICAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgICAgICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgeDogY2VudGVyWCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlLFxuICAgICAgICAgICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgICAgICAgICAgaW5uZXJSYWRpdXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1ldGEuX3BhcnNlZFtpXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIW1ldGFEYXRhW2ldLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgICAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgbGV0IGksIGlsZW4sIG1ldGEsIGNvbnRyb2xsZXIsIG9wdGlvbnM7XG4gICAgICAgIGlmICghYXJjcykge1xuICAgICAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICAgICAgICAgICAgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXJjcykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXRNYXhPZmZzZXQoYXJjcykge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMub2Zmc2V0IHx8IDAsIG9wdGlvbnMuaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gX2dldFJpbmdXZWlnaHRPZmZzZXQoZGF0YXNldEluZGV4KSB7XG4gICAgICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKXtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICAgICAgICByaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gICAgfVxuIF9nZXRSaW5nV2VpZ2h0KGRhdGFzZXRJbmRleCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG4gICAgfVxuIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICAgIH1cbn1cblxuY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gICAgc3RhdGljIGlkID0gJ2xpbmUnO1xuIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gICAgICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICAgICAgc2hvd0xpbmU6IHRydWUsXG4gICAgICAgIHNwYW5HYXBzOiBmYWxzZVxuICAgIH07XG4gc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgICBfaW5kZXhfOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NhdGVnb3J5J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IHRydWU7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgdXBkYXRlKG1vZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IHsgZGF0YXNldDogbGluZSAsIGRhdGE6IHBvaW50cyA9IFtdICwgX2RhdGFzZXQgIH0gPSBtZXRhO1xuICAgICAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgICAgIGxldCB7IHN0YXJ0ICwgY291bnQgIH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG4gICAgICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcbiAgICAgICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICAgICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0sIG1vZGUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgICB9XG4gICAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgICAgICBjb25zdCB7IGlTY2FsZSAsIHZTY2FsZSAsIF9zdGFja2VkICwgX2RhdGFzZXQgIH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCB7IHNoYXJlZE9wdGlvbnMgLCBpbmNsdWRlT3B0aW9ucyAgfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgICAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgICAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgICAgICBjb25zdCB7IHNwYW5HYXBzICwgc2VnbWVudCAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgICAgIGNvbnN0IHBvaW50c0NvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBvaW50c0NvdW50OyArK2kpe1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgICAgICAgIGlmIChpIDwgc3RhcnQgfHwgaSA+PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnNraXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICAgICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICAgICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgfVxuIGdldE1heE92ZXJmbG93KCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICAgICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgICAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICAgICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICAgICAgc3VwZXIuZHJhdygpO1xuICAgIH1cbn1cblxuY2xhc3MgUG9sYXJBcmVhQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgaWQgPSAncG9sYXJBcmVhJztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFuaW1hdGVTY2FsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBudW1iZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAneCcsXG4gICAgICAgICAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICAnZW5kQW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgICAgICAgICAgICAgICAnb3V0ZXJSYWRpdXMnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbmRleEF4aXM6ICdyJyxcbiAgICAgICAgc3RhcnRBbmdsZTogMFxuICAgIH07XG4gc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICAgICAgYXNwZWN0UmF0aW86IDEsXG4gICAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUxhYmVscyAoY2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbGFiZWxzOiB7IHBvaW50U3R5bGUgLCBjb2xvciAgfSAgfSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25DbGljayAoZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgICByOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICAgICAgICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICAgICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgICAgICAgICBjaXJjdWxhcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCl7XG4gICAgICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuICAgICAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLnIsIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICB9XG4gICAgdXBkYXRlKG1vZGUpIHtcbiAgICAgICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICAgIH1cbiBnZXRNaW5NYXgoKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgICAgIG1pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgfTtcbiAgICAgICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KT0+e1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpLnI7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkIDwgcmFuZ2UubWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLm1pbiA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCA+IHJhbmdlLm1heCkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5tYXggPSBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiBfdXBkYXRlUmFkaXVzKCkge1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuICAgICAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcbiAgICAgICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyBvdXRlclJhZGl1cyAvIDEwMCAqIG9wdHMuY3V0b3V0UGVyY2VudGFnZSA6IDEsIDApO1xuICAgICAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICAgIH1cbiAgICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgICAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcbiAgICAgICAgY29uc3QgZGF0YXNldFN0YXJ0QW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKDApIC0gMC41ICogUEk7XG4gICAgICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBzdGFydDsgKytpKXtcbiAgICAgICAgICAgIGFuZ2xlICs9IHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspe1xuICAgICAgICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgICBsZXQgZW5kQW5nbGUgPSBhbmdsZSArIHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgICAgICAgICAgbGV0IG91dGVyUmFkaXVzID0gY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgPyBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKS5yKSA6IDA7XG4gICAgICAgICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgICAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KT0+e1xuICAgICAgICAgICAgaWYgKCFpc05hTih0aGlzLmdldFBhcnNlZChpbmRleCkucikgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpID8gdG9SYWRpYW5zKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkuYW5nbGUgfHwgZGVmYXVsdEFuZ2xlKSA6IDA7XG4gICAgfVxufVxuXG5jbGFzcyBQaWVDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgaWQgPSAncGllJztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIGN1dG91dDogMCxcbiAgICAgICAgcm90YXRpb246IDAsXG4gICAgICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgICAgICAgcmFkaXVzOiAnMTAwJSdcbiAgICB9O1xufVxuXG5jbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gICAgc3RhdGljIGlkID0gJ3JhZGFyJztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICAgICAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgICAgIGluZGV4QXhpczogJ3InLFxuICAgICAgICBzaG93TGluZTogdHJ1ZSxcbiAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICBmaWxsOiAnc3RhcnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgICAgIGFzcGVjdFJhdGlvOiAxLFxuICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgIHI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuICAgIHVwZGF0ZShtb2RlKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgICAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IG1ldGEuaVNjYWxlLmdldExhYmVscygpO1xuICAgICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgX2xvb3A6IHRydWUsXG4gICAgICAgICAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gICAgfVxuICAgIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICAgICAgZm9yKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspe1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICAgICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHRoaXMuZ2V0UGFyc2VkKGkpLnIpO1xuICAgICAgICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICBhbmdsZTogcG9pbnRQb3NpdGlvbi5hbmdsZSxcbiAgICAgICAgICAgICAgICBza2lwOiBpc05hTih4KSB8fCBpc05hTih5KSxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU2NhdHRlckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gICAgc3RhdGljIGlkID0gJ3NjYXR0ZXInO1xuIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICAgICAgICBzaG93TGluZTogZmFsc2UsXG4gICAgICAgIGZpbGw6IGZhbHNlXG4gICAgfTtcbiBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgICAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICAgICAgbW9kZTogJ3BvaW50J1xuICAgICAgICB9LFxuICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgICAgICBjb25zdCB7IHhTY2FsZSAsIHlTY2FsZSAgfSA9IG1ldGE7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICAgICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArICcpJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGUobW9kZSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBwb2ludHMgPSBbXSAgfSA9IG1ldGE7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICAgICAgbGV0IHsgc3RhcnQgLCBjb3VudCAgfSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICAgICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuICAgICAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFzZXQ6IGxpbmUgLCBfZGF0YXNldCAgfSA9IG1ldGE7XG4gICAgICAgICAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgICAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgICAgICAgICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgICAgICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfSwgbW9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZXRhLmRhdGFzZXQ7XG4gICAgICAgICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICAgIH1cbiAgICBhZGRFbGVtZW50cygpIHtcbiAgICAgICAgY29uc3QgeyBzaG93TGluZSAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiBzaG93TGluZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSB0aGlzLmNoYXJ0LnJlZ2lzdHJ5LmdldEVsZW1lbnQoJ2xpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5hZGRFbGVtZW50cygpO1xuICAgIH1cbiAgICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgICAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgICAgIGNvbnN0IHsgaVNjYWxlICwgdlNjYWxlICwgX3N0YWNrZWQgLCBfZGF0YXNldCAgfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICAgICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgICAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgICAgICBjb25zdCB7IHNwYW5HYXBzICwgc2VnbWVudCAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG4gICAgICAgIGZvcihsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKXtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgICAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgICAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICAgICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuICAgICAgICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSA+IG1heEdhcExlbmd0aDtcbiAgICAgICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gICAgfVxuIGdldE1heE92ZXJmbG93KCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSl7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICAgICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gICAgfVxufVxuXG52YXIgY29udHJvbGxlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5CYXJDb250cm9sbGVyOiBCYXJDb250cm9sbGVyLFxuQnViYmxlQ29udHJvbGxlcjogQnViYmxlQ29udHJvbGxlcixcbkRvdWdobnV0Q29udHJvbGxlcjogRG91Z2hudXRDb250cm9sbGVyLFxuTGluZUNvbnRyb2xsZXI6IExpbmVDb250cm9sbGVyLFxuUGllQ29udHJvbGxlcjogUGllQ29udHJvbGxlcixcblBvbGFyQXJlYUNvbnRyb2xsZXI6IFBvbGFyQXJlYUNvbnRyb2xsZXIsXG5SYWRhckNvbnRyb2xsZXI6IFJhZGFyQ29udHJvbGxlcixcblNjYXR0ZXJDb250cm9sbGVyOiBTY2F0dGVyQ29udHJvbGxlclxufSk7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5fYWRhcHRlcnNcbiAqIEBzaW5jZSAyLjguMFxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBhYnN0cmFjdCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC4nKTtcbn1cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqLyBjbGFzcyBEYXRlQWRhcHRlckJhc2Uge1xuICAgIC8qKlxuICAgKiBPdmVycmlkZSBkZWZhdWx0IGRhdGUgYWRhcHRlciBtZXRob2RzLlxuICAgKiBBY2NlcHRzIHR5cGUgcGFyYW1ldGVyIHRvIGRlZmluZSBvcHRpb25zIHR5cGUuXG4gICAqIEBleGFtcGxlXG4gICAqIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZS5vdmVycmlkZTx7bXlBZGFwdGVyT3B0aW9uOiBzdHJpbmd9Pih7XG4gICAqICAgaW5pdCgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKHRoaXMub3B0aW9ucy5teUFkYXB0ZXJPcHRpb24pO1xuICAgKiAgIH1cbiAgICogfSlcbiAgICovIHN0YXRpYyBvdmVycmlkZShtZW1iZXJzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oRGF0ZUFkYXB0ZXJCYXNlLnByb3RvdHlwZSwgbWVtYmVycyk7XG4gICAgfVxuICAgIG9wdGlvbnM7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgICBpbml0KCkge31cbiAgICBmb3JtYXRzKCkge1xuICAgICAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgcGFyc2UoKSB7XG4gICAgICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICAgIH1cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICAgIH1cbiAgICBhZGQoKSB7XG4gICAgICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICAgIH1cbiAgICBkaWZmKCkge1xuICAgICAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgc3RhcnRPZigpIHtcbiAgICAgICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gICAgfVxuICAgIGVuZE9mKCkge1xuICAgICAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgICB9XG59XG52YXIgYWRhcHRlcnMgPSB7XG4gICAgX2RhdGU6IERhdGVBZGFwdGVyQmFzZVxufTtcblxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgICBjb25zdCB7IGNvbnRyb2xsZXIgLCBkYXRhICwgX3NvcnRlZCAgfSA9IG1ldGFzZXQ7XG4gICAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gICAgaWYgKGlTY2FsZSAmJiBheGlzID09PSBpU2NhbGUuYXhpcyAmJiBheGlzICE9PSAncicgJiYgX3NvcnRlZCAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBsb29rdXBNZXRob2QgPSBpU2NhbGUuX3JldmVyc2VQaXhlbHMgPyBfcmxvb2t1cEJ5S2V5IDogX2xvb2t1cEJ5S2V5O1xuICAgICAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSAtIHJhbmdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgKyByYW5nZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbG86IHN0YXJ0LmxvLFxuICAgICAgICAgICAgICAgICAgICBoaTogZW5kLmhpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsbzogMCxcbiAgICAgICAgaGk6IGRhdGEubGVuZ3RoIC0gMVxuICAgIH07XG59XG4gZnVuY3Rpb24gZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgaGFuZGxlciwgaW50ZXJzZWN0KSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgICBmb3IobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgY29uc3QgeyBpbmRleCAsIGRhdGEgIH0gPSBtZXRhc2V0c1tpXTtcbiAgICAgICAgY29uc3QgeyBsbyAsIGhpICB9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcbiAgICAgICAgZm9yKGxldCBqID0gbG87IGogPD0gaGk7ICsrail7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4gZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgICBjb25zdCB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xuICAgIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG4gICAgICAgIGNvbnN0IGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICAgIH07XG59XG4gZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgY29uc3QgZXZhbHVhdGlvbkZ1bmMgPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhX2lzUG9pbnRJbkFyZWEoZWxlbWVudCwgY2hhcnQuY2hhcnRBcmVhLCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICAgIHJldHVybiBpdGVtcztcbn1cbiBmdW5jdGlvbiBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgbGV0IGl0ZW1zID0gW107XG4gICAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0QW5nbGUgLCBlbmRBbmdsZSAgfSA9IGVsZW1lbnQuZ2V0UHJvcHMoW1xuICAgICAgICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgICAgICAgJ2VuZEFuZ2xlJ1xuICAgICAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgeyBhbmdsZSAgfSA9IGdldEFuZ2xlRnJvbVBvaW50KGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiBwb3NpdGlvbi55XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICAgIHJldHVybiBpdGVtcztcbn1cbiBmdW5jdGlvbiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgICAgICBjb25zdCBpblJhbmdlID0gZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgcG9pbnRJbkFyZWEgPSAhIWluY2x1ZGVJbnZpc2libGUgfHwgY2hhcnQuaXNQb2ludEluQXJlYShjZW50ZXIpO1xuICAgICAgICBpZiAoIXBvaW50SW5BcmVhICYmICFpblJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgICByZXR1cm4gaXRlbXM7XG59XG4gZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gICAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBheGlzID09PSAncicgJiYgIWludGVyc2VjdCA/IGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIDogZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbn1cbiBmdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHJhbmdlTWV0aG9kID0gYXhpcyA9PT0gJ3gnID8gJ2luWFJhbmdlJyA6ICdpbllSYW5nZSc7XG4gICAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG4gICAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpPT57XG4gICAgICAgIGlmIChlbGVtZW50W3JhbmdlTWV0aG9kXShwb3NpdGlvbltheGlzXSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGludGVyc2VjdHNJdGVtID0gaW50ZXJzZWN0c0l0ZW0gfHwgZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG59XG4gdmFyIEludGVyYWN0aW9uID0ge1xuICAgIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyxcbiAgICBtb2Rlczoge1xuIGluZGV4IChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuICAgICAgICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3QgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmZvckVhY2goKG1ldGEpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpdGVtc1swXS5pbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5za2lwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9LFxuIGRhdGFzZXQgKGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0ID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmRhdGE7XG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZGF0YVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfSxcbiBwb2ludCAoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICAgICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICAgIH0sXG4gbmVhcmVzdCAoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICAgICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgICAgfSxcbiB4IChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneCcsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgICAgfSxcbiB5IChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneScsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IFNUQVRJQ19QT1NJVElPTlMgPSBbXG4gICAgJ2xlZnQnLFxuICAgICd0b3AnLFxuICAgICdyaWdodCcsXG4gICAgJ2JvdHRvbSdcbl07XG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xuICAgIHJldHVybiBhcnJheS5maWx0ZXIoKHYpPT52LnBvcyA9PT0gcG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGFycmF5LCBheGlzKSB7XG4gICAgcmV0dXJuIGFycmF5LmZpbHRlcigodik9PlNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIGFycmF5LnNvcnQoKGEsIGIpPT57XG4gICAgICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgICAgICBjb25zdCB2MSA9IHJldmVyc2UgPyBhIDogYjtcbiAgICAgICAgcmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID8gdjAuaW5kZXggLSB2MS5pbmRleCA6IHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICAgIGNvbnN0IGxheW91dEJveGVzID0gW107XG4gICAgbGV0IGksIGlsZW4sIGJveCwgcG9zLCBzdGFjaywgc3RhY2tXZWlnaHQ7XG4gICAgZm9yKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgKHsgcG9zaXRpb246IHBvcyAsIG9wdGlvbnM6IHsgc3RhY2sgLCBzdGFja1dlaWdodCA9MSAgfSAgfSA9IGJveCk7XG4gICAgICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBib3gsXG4gICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICAgICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICAgICAgICBzdGFjazogc3RhY2sgJiYgcG9zICsgc3RhY2ssXG4gICAgICAgICAgICBzdGFja1dlaWdodFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuZnVuY3Rpb24gYnVpbGRTdGFja3MobGF5b3V0cykge1xuICAgIGNvbnN0IHN0YWNrcyA9IHt9O1xuICAgIGZvciAoY29uc3Qgd3JhcCBvZiBsYXlvdXRzKXtcbiAgICAgICAgY29uc3QgeyBzdGFjayAsIHBvcyAsIHN0YWNrV2VpZ2h0ICB9ID0gd3JhcDtcbiAgICAgICAgaWYgKCFzdGFjayB8fCAhU1RBVElDX1BPU0lUSU9OUy5pbmNsdWRlcyhwb3MpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfc3RhY2sgPSBzdGFja3Nbc3RhY2tdIHx8IChzdGFja3Nbc3RhY2tdID0ge1xuICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICBwbGFjZWQ6IDAsXG4gICAgICAgICAgICB3ZWlnaHQ6IDAsXG4gICAgICAgICAgICBzaXplOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBfc3RhY2suY291bnQrKztcbiAgICAgICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrcztcbn1cbiBmdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICAgIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICAgIGNvbnN0IHsgdkJveE1heFdpZHRoICwgaEJveE1heEhlaWdodCAgfSA9IHBhcmFtcztcbiAgICBsZXQgaSwgaWxlbiwgbGF5b3V0O1xuICAgIGZvcihpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICAgICAgY29uc3QgeyBmdWxsU2l6ZSAgfSA9IGxheW91dC5ib3g7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja107XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICAgICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICAgICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxheW91dC53aWR0aCA9IHZCb3hNYXhXaWR0aDtcbiAgICAgICAgICAgIGxheW91dC5oZWlnaHQgPSBmYWN0b3IgPyBmYWN0b3IgKiBoQm94TWF4SGVpZ2h0IDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZUhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xuICAgIGNvbnN0IGxheW91dEJveGVzID0gd3JhcEJveGVzKGJveGVzKTtcbiAgICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIoKHdyYXApPT53cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICAgIGNvbnN0IGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XG4gICAgY29uc3QgcmlnaHQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3JpZ2h0JykpO1xuICAgIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICAgIGNvbnN0IGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xuICAgIGNvbnN0IGNlbnRlckhvcml6b250YWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd4Jyk7XG4gICAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVsbFNpemUsXG4gICAgICAgIGxlZnRBbmRUb3A6IGxlZnQuY29uY2F0KHRvcCksXG4gICAgICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICAgICAgY2hhcnRBcmVhOiBmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnY2hhcnRBcmVhJyksXG4gICAgICAgIHZlcnRpY2FsOiBsZWZ0LmNvbmNhdChyaWdodCkuY29uY2F0KGNlbnRlclZlcnRpY2FsKSxcbiAgICAgICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWF4UGFkZGluZ1thXSwgY2hhcnRBcmVhW2FdKSArIE1hdGgubWF4KG1heFBhZGRpbmdbYl0sIGNoYXJ0QXJlYVtiXSk7XG59XG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgICBtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XG4gICAgbWF4UGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuICAgIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgICBtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG59XG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICAgIGNvbnN0IHsgcG9zICwgYm94ICB9ID0gbGF5b3V0O1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgICBpZiAoIWlzT2JqZWN0KHBvcykpIHtcbiAgICAgICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICAgICAgICBjaGFydEFyZWFbcG9zXSAtPSBsYXlvdXQuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtcbiAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICBjb3VudDogMVxuICAgICAgICB9O1xuICAgICAgICBzdGFjay5zaXplID0gTWF0aC5tYXgoc3RhY2suc2l6ZSwgbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoKTtcbiAgICAgICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgICAgIGNoYXJ0QXJlYVtwb3NdICs9IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICAgICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3guZ2V0UGFkZGluZygpKTtcbiAgICB9XG4gICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAndG9wJywgJ2JvdHRvbScpKTtcbiAgICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gICAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gICAgY2hhcnRBcmVhLncgPSBuZXdXaWR0aDtcbiAgICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcbiAgICByZXR1cm4gbGF5b3V0Lmhvcml6b250YWwgPyB7XG4gICAgICAgIHNhbWU6IHdpZHRoQ2hhbmdlZCxcbiAgICAgICAgb3RoZXI6IGhlaWdodENoYW5nZWRcbiAgICB9IDoge1xuICAgICAgICBzYW1lOiBoZWlnaHRDaGFuZ2VkLFxuICAgICAgICBvdGhlcjogd2lkdGhDaGFuZ2VkXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvcyhwb3MpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgICAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gICAgY2hhcnRBcmVhLnggKz0gdXBkYXRlUG9zKCdsZWZ0Jyk7XG4gICAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICAgIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICB9O1xuICAgICAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zKT0+e1xuICAgICAgICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfVxuICAgIHJldHVybiBob3Jpem9udGFsID8gbWFyZ2luRm9yUG9zaXRpb25zKFtcbiAgICAgICAgJ2xlZnQnLFxuICAgICAgICAncmlnaHQnXG4gICAgXSkgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoW1xuICAgICAgICAndG9wJyxcbiAgICAgICAgJ2JvdHRvbSdcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gICAgY29uc3QgcmVmaXRCb3hlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XG4gICAgZm9yKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICAgICAgYm94ID0gbGF5b3V0LmJveDtcbiAgICAgICAgYm94LnVwZGF0ZShsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsIGdldE1hcmdpbnMobGF5b3V0Lmhvcml6b250YWwsIGNoYXJ0QXJlYSkpO1xuICAgICAgICBjb25zdCB7IHNhbWUgLCBvdGhlciAgfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcbiAgICAgICAgcmVmaXQgfD0gc2FtZSAmJiByZWZpdEJveGVzLmxlbmd0aDtcbiAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgb3RoZXI7XG4gICAgICAgIGlmICghYm94LmZ1bGxTaXplKSB7XG4gICAgICAgICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVmaXQgJiYgZml0Qm94ZXMocmVmaXRCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykgfHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHNldEJveERpbXMoYm94LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBib3gudG9wID0gdG9wO1xuICAgIGJveC5sZWZ0ID0gbGVmdDtcbiAgICBib3gucmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgYm94LmJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICBib3gud2lkdGggPSB3aWR0aDtcbiAgICBib3guaGVpZ2h0ID0gaGVpZ2h0O1xufVxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICAgIGNvbnN0IHVzZXJQYWRkaW5nID0gcGFyYW1zLnBhZGRpbmc7XG4gICAgbGV0IHsgeCAsIHkgIH0gPSBjaGFydEFyZWE7XG4gICAgZm9yIChjb25zdCBsYXlvdXQgb2YgYm94ZXMpe1xuICAgICAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgICAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtcbiAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgcGxhY2VkOiAwLFxuICAgICAgICAgICAgd2VpZ2h0OiAxXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHdlaWdodCA9IGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodCB8fCAxO1xuICAgICAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY2hhcnRBcmVhLncgKiB3ZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBzdGFjay5zaXplIHx8IGJveC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICB5ID0gc3RhY2suc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgICAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRCb3hEaW1zKGJveCwgY2hhcnRBcmVhLmxlZnQgKyBzdGFjay5wbGFjZWQsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2suc3RhcnQgPSB5O1xuICAgICAgICAgICAgc3RhY2sucGxhY2VkICs9IHdpZHRoO1xuICAgICAgICAgICAgeSA9IGJveC5ib3R0b207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICAgICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICB4ID0gc3RhY2suc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgICAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIHVzZXJQYWRkaW5nLnRvcCwgd2lkdGgsIHBhcmFtcy5vdXRlckhlaWdodCAtIHVzZXJQYWRkaW5nLmJvdHRvbSAtIHVzZXJQYWRkaW5nLnRvcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgICAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICAgICAgICB4ID0gYm94LnJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYXJ0QXJlYS54ID0geDtcbiAgICBjaGFydEFyZWEueSA9IHk7XG59XG52YXIgbGF5b3V0cyA9IHtcbiBhZGRCb3ggKGNoYXJ0LCBpdGVtKSB7XG4gICAgICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgICAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5mdWxsU2l6ZSA9IGl0ZW0uZnVsbFNpemUgfHwgZmFsc2U7XG4gICAgICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgICAgICBpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XG4gICAgICAgIGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB6OiAwLFxuICAgICAgICAgICAgICAgICAgICBkcmF3IChjaGFydEFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICAgICAgY2hhcnQuYm94ZXMucHVzaChpdGVtKTtcbiAgICB9LFxuIHJlbW92ZUJveCAoY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH0sXG4gY29uZmlndXJlIChjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuICAgICAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICAgICAgaXRlbS5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgICAgIGl0ZW0ud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSxcbiB1cGRhdGUgKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0LCBtaW5QYWRkaW5nKSB7XG4gICAgICAgIGlmICghY2hhcnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKGNoYXJ0Lm9wdGlvbnMubGF5b3V0LnBhZGRpbmcpO1xuICAgICAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgYm94ZXMgPSBidWlsZExheW91dEJveGVzKGNoYXJ0LmJveGVzKTtcbiAgICAgICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgICAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuICAgICAgICBlYWNoKGNoYXJ0LmJveGVzLCAoYm94KT0+e1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBib3guYmVmb3JlTGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApPT53cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBvdXRlcldpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIG91dGVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQsXG4gICAgICAgICAgICB2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZpc2libGVWZXJ0aWNhbEJveENvdW50LFxuICAgICAgICAgICAgaEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWF4UGFkZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHBhZGRpbmcpO1xuICAgICAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIHRvUGFkZGluZyhtaW5QYWRkaW5nKSk7XG4gICAgICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgbWF4UGFkZGluZyxcbiAgICAgICAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgICAgICAgeTogcGFkZGluZy50b3BcbiAgICAgICAgfSwgcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcbiAgICAgICAgZml0Qm94ZXMoYm94ZXMuZnVsbFNpemUsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgICAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICAgICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgICAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcbiAgICAgICAgcGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICAgICAgY2hhcnRBcmVhLnggKz0gY2hhcnRBcmVhLnc7XG4gICAgICAgIGNoYXJ0QXJlYS55ICs9IGNoYXJ0QXJlYS5oO1xuICAgICAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICAgICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICAgICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICAgICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgICAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgICAgICAgIHdpZHRoOiBjaGFydEFyZWEud1xuICAgICAgICB9O1xuICAgICAgICBlYWNoKGJveGVzLmNoYXJ0QXJlYSwgKGxheW91dCk9PntcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgICAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7fVxuIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICAgICAgfTtcbiAgICB9XG4gaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICB9XG59XG5cbmNsYXNzIEJhc2ljUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICAgIGFjcXVpcmVDb250ZXh0KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICAgIH1cbiAgICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5vcHRpb25zLmFuaW1hdGlvbiA9IGZhbHNlO1xuICAgIH1cbn1cblxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xuIGNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICAgIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuICAgIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gICAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgICBwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcbiAgICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gICAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuICAgIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuY29uc3QgaXNOdWxsT3JFbXB0eSA9ICh2YWx1ZSk9PnZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJztcbiBmdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgICBjb25zdCBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcbiAgICBjb25zdCByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgY2FudmFzW0VYUEFORE9fS0VZXSA9IHtcbiAgICAgICAgaW5pdGlhbDoge1xuICAgICAgICAgICAgaGVpZ2h0OiByZW5kZXJIZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogcmVuZGVyV2lkdGgsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHN0eWxlLndpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG4gICAgc3R5bGUuYm94U2l6aW5nID0gc3R5bGUuYm94U2l6aW5nIHx8ICdib3JkZXItYm94JztcbiAgICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJXaWR0aCkpIHtcbiAgICAgICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgICAgIGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcbiAgICAgICAgaWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGFzcGVjdFJhdGlvIHx8IDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5SGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FudmFzO1xufVxuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge1xuICAgIHBhc3NpdmU6IHRydWVcbn0gOiBmYWxzZTtcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjaGFydC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICAgIGNvbnN0IHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hhcnQsXG4gICAgICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgICAgIHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuICAgICAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbFxuICAgIH07XG59XG5mdW5jdGlvbiBub2RlTGlzdENvbnRhaW5zKG5vZGVMaXN0LCBjYW52YXMpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxpc3Qpe1xuICAgICAgICBpZiAobm9kZSA9PT0gY2FudmFzIHx8IG5vZGUuY29udGFpbnMoY2FudmFzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVBdHRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoZW50cmllcyk9PntcbiAgICAgICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKXtcbiAgICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJpZ2dlcikge1xuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcyl7XG4gICAgICAgICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbmNvbnN0IGRycExpc3RlbmluZ0NoYXJ0cyA9IG5ldyBNYXAoKTtcbmxldCBvbGREZXZpY2VQaXhlbFJhdGlvID0gMDtcbmZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvbGREZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuICAgIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KT0+e1xuICAgICAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgICAgICAgcmVzaXplKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gICAgfVxuICAgIGRycExpc3RlbmluZ0NoYXJ0cy5zZXQoY2hhcnQsIHJlc2l6ZSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gICAgZHJwTGlzdGVuaW5nQ2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gICAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCk9PntcbiAgICAgICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmICh3IDwgY29udGFpbmVyLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgfSwgd2luZG93KTtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcyk9PntcbiAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuICAgIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIHJlbGVhc2VPYnNlcnZlcihjaGFydCwgdHlwZSwgb2JzZXJ2ZXIpIHtcbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICAgIGNvbnN0IHByb3h5ID0gdGhyb3R0bGVkKChldmVudCk9PntcbiAgICAgICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgICAgICB9XG4gICAgfSwgY2hhcnQpO1xuICAgIGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuICAgIHJldHVybiBwcm94eTtcbn1cbiBjbGFzcyBEb21QbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0ICYmIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICAgICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgICAgIFtcbiAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgJ3dpZHRoJ1xuICAgICAgICBdLmZvckVhY2goKHByb3ApPT57XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuICAgICAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgICAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICAgICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgY3JlYXRlUHJveHlBbmRMaXN0ZW47XG4gICAgICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuICAgICAgICBpZiAoIXByb3h5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBhdHRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgICAgICAgIGRldGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgICAgICAgcmVzaXplOiByZWxlYXNlT2JzZXJ2ZXJcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgICAgICBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBwcm94eSk7XG4gICAgICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgICAgICByZXR1cm4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gICAgfVxuIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgICBpZiAoIV9pc0RvbVN1cHBvcnRlZCgpIHx8IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcbiAgICB9XG4gICAgcmV0dXJuIERvbVBsYXRmb3JtO1xufVxuXG5jbGFzcyBFbGVtZW50IHtcbiAgICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcbiAgICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHVuZGVmaW5lZDtcbiAgICB4O1xuICAgIHk7XG4gICAgYWN0aXZlID0gZmFsc2U7XG4gICAgb3B0aW9ucztcbiAgICAkYW5pbWF0aW9ucztcbiAgICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAgICAgICAneCcsXG4gICAgICAgICAgICAneSdcbiAgICAgICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICB9O1xuICAgIH1cbiAgICBoYXNWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgICB9XG4gICAgZ2V0UHJvcHMocHJvcHMsIGZpbmFsKSB7XG4gICAgICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICAgICAgaWYgKCFmaW5hbCB8fCAhYW5pbXMpIHtcbiAgICAgICAgICAgIC8vIGxldCdzIG5vdCBjcmVhdGUgYW4gb2JqZWN0LCBpZiBub3QgbmVlZGVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgICAgcHJvcHMuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgICAgIHJldFtwcm9wXSA9IGFuaW1zW3Byb3BdICYmIGFuaW1zW3Byb3BdLmFjdGl2ZSgpID8gYW5pbXNbcHJvcF0uX3RvIDogdGhpc1twcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhdXRvU2tpcChzY2FsZSwgdGlja3MpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgZGV0ZXJtaW5lZE1heFRpY2tzID0gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICAgIGNvbnN0IHRpY2tzTGltaXQgPSBNYXRoLm1pbih0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGRldGVybWluZWRNYXhUaWNrcywgZGV0ZXJtaW5lZE1heFRpY2tzKTtcbiAgICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICAgIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3QgZmlyc3QgPSBtYWpvckluZGljZXNbMF07XG4gICAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuICAgIGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG4gICAgICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgICAgICByZXR1cm4gbmV3VGlja3M7XG4gICAgfVxuICAgIGNvbnN0IHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpO1xuICAgIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgICAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspe1xuICAgICAgICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGxhc3QsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xuICAgICAgICByZXR1cm4gbmV3VGlja3M7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICAgIGNvbnN0IG9mZnNldCA9IHNjYWxlLm9wdGlvbnMub2Zmc2V0O1xuICAgIGNvbnN0IHRpY2tMZW5ndGggPSBzY2FsZS5fdGlja1NpemUoKTtcbiAgICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgICBjb25zdCBtYXhDaGFydCA9IHNjYWxlLl9tYXhMZW5ndGggLyB0aWNrTGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKG1heFNjYWxlLCBtYXhDaGFydCkpO1xufVxuIGZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCkge1xuICAgIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICAgIGNvbnN0IHNwYWNpbmcgPSB0aWNrcy5sZW5ndGggLyB0aWNrc0xpbWl0O1xuICAgIGlmICghZXZlbk1ham9yU3BhY2luZykge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gICAgfVxuICAgIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICAgIGZvcihsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspe1xuICAgICAgICBjb25zdCBmYWN0b3IgPSBmYWN0b3JzW2ldO1xuICAgICAgICBpZiAoZmFjdG9yID4gc3BhY2luZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG59XG4gZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKXtcbiAgICAgICAgaWYgKHRpY2tzW2ldLm1ham9yKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIGZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICAgIGxldCBpO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gICAgZm9yKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgbmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xuICAgICAgICB9XG4gICAgfVxufVxuIGZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWVPckRlZmF1bHQobWFqb3JTdGFydCwgMCk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgbGVuZ3RoLCBpLCBuZXh0O1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gICAgaWYgKG1ham9yRW5kKSB7XG4gICAgICAgIGxlbmd0aCA9IG1ham9yRW5kIC0gbWFqb3JTdGFydDtcbiAgICAgICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XG4gICAgfVxuICAgIG5leHQgPSBzdGFydDtcbiAgICB3aGlsZShuZXh0IDwgMCl7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgICB9XG4gICAgZm9yKGkgPSBNYXRoLm1heChzdGFydCwgMCk7IGkgPCBlbmQ7IGkrKyl7XG4gICAgICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICAgICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4gZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBsZXQgaSwgZGlmZjtcbiAgICBpZiAobGVuIDwgMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcihkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKXtcbiAgICAgICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZjtcbn1cblxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKT0+YWxpZ24gPT09ICdsZWZ0JyA/ICdyaWdodCcgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6IGFsaWduO1xuY29uc3Qgb2Zmc2V0RnJvbUVkZ2UgPSAoc2NhbGUsIGVkZ2UsIG9mZnNldCk9PmVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5jb25zdCBnZXRUaWNrc0xpbWl0ID0gKHRpY2tzTGVuZ3RoLCBtYXhUaWNrc0xpbWl0KT0+TWF0aC5taW4obWF4VGlja3NMaW1pdCB8fCB0aWNrc0xlbmd0aCwgdGlja3NMZW5ndGgpO1xuIGZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvcig7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KXtcbiAgICAgICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiBmdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICAgIGNvbnN0IHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcbiAgICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gICAgY29uc3QgZXBzaWxvbiA9IDFlLTY7XG4gICAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcbiAgICBsZXQgb2Zmc2V0O1xuICAgIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgbGluZVZhbHVlICs9IHZhbGlkSW5kZXggPCBpbmRleCA/IG9mZnNldCA6IC1vZmZzZXQ7XG4gICAgICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lVmFsdWU7XG59XG4gZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgICBlYWNoKGNhY2hlcywgKGNhY2hlKT0+e1xuICAgICAgICBjb25zdCBnYyA9IGNhY2hlLmdjO1xuICAgICAgICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAoZ2NMZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGdjTGVuOyArK2kpe1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiBmdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cbiBmdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICAgIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBmb250ID0gdG9Gb250KG9wdGlvbnMuZm9udCwgZmFsbGJhY2spO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuICAgIHJldHVybiBsaW5lcyAqIGZvbnQubGluZUhlaWdodCArIHBhZGRpbmcuaGVpZ2h0O1xufVxuZnVuY3Rpb24gY3JlYXRlU2NhbGVDb250ZXh0KHBhcmVudCwgc2NhbGUpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIHR5cGU6ICdzY2FsZSdcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICAgICAgdGljayxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHR5cGU6ICd0aWNrJ1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpIHtcbiAgICAgbGV0IHJldCA9IF90b0xlZnRSaWdodENlbnRlcihhbGlnbik7XG4gICAgaWYgKHJldmVyc2UgJiYgcG9zaXRpb24gIT09ICdyaWdodCcgfHwgIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0aXRsZUFyZ3Moc2NhbGUsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKSB7XG4gICAgY29uc3QgeyB0b3AgLCBsZWZ0ICwgYm90dG9tICwgcmlnaHQgLCBjaGFydCAgfSA9IHNjYWxlO1xuICAgIGNvbnN0IHsgY2hhcnRBcmVhICwgc2NhbGVzICB9ID0gY2hhcnQ7XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgICAgIHRpdGxlWSA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0aXRsZVkgPSAoY2hhcnRBcmVhLmJvdHRvbSArIGNoYXJ0QXJlYS50b3ApIC8gMiArIGhlaWdodCAtIG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICAgICAgdGl0bGVYID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSAtIHdpZHRoICsgb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpdGxlWCA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtSEFMRl9QSSA6IEhBTEZfUEk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlWCxcbiAgICAgICAgdGl0bGVZLFxuICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgcm90YXRpb25cbiAgICB9O1xufVxuY2xhc3MgU2NhbGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjZmcpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICAgICAgIHRoaXMudHlwZSA9IGNmZy50eXBlO1xuICAgICAgICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgICAgICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcbiAgICAgICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIH07XG4gICAgICAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLnRpY2tzID0gW107XG4gICAgICAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICAgICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fTtcbiAgICAgICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLl9lbmRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl91c2VyTWluID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGlja3NMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gaW5pdChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgICAgICAgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5taW4pO1xuICAgICAgICB0aGlzLl91c2VyTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLm1heCk7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWF4KTtcbiAgICB9XG4gcGFyc2UocmF3LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gcmF3O1xuICAgIH1cbiBnZXRVc2VyQm91bmRzKCkge1xuICAgICAgICBsZXQgeyBfdXNlck1pbiAsIF91c2VyTWF4ICwgX3N1Z2dlc3RlZE1pbiAsIF9zdWdnZXN0ZWRNYXggIH0gPSB0aGlzO1xuICAgICAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgICAgIF9zdWdnZXN0ZWRNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIF9zdWdnZXN0ZWRNaW4pLFxuICAgICAgICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIF9zdWdnZXN0ZWRNYXgpLFxuICAgICAgICAgICAgbWluRGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNaW4pLFxuICAgICAgICAgICAgbWF4RGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNYXgpXG4gICAgICAgIH07XG4gICAgfVxuIGdldE1pbk1heChjYW5TdGFjaykge1xuICAgICAgICBsZXQgeyBtaW4gLCBtYXggLCBtaW5EZWZpbmVkICwgbWF4RGVmaW5lZCAgfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgICAgICBsZXQgcmFuZ2U7XG4gICAgICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgICAgIG1heFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICAgICAgZm9yKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICByYW5nZSA9IG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0TWluTWF4KHRoaXMsIGNhblN0YWNrKTtcbiAgICAgICAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcbiAgICAgICAgbWF4ID0gbWluRGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtaW4gOiBtYXg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgICAgICB9O1xuICAgIH1cbiBnZXRQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgICAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgICAgICB9O1xuICAgIH1cbiBnZXRUaWNrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlja3M7XG4gICAgfVxuIGdldExhYmVscygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xuICAgIH1cbiBnZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSA9IHRoaXMuY2hhcnQuY2hhcnRBcmVhKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICAgIGJlZm9yZUxheW91dCgpIHtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSk7XG4gICAgfVxuIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgICAgIGNvbnN0IHsgYmVnaW5BdFplcm8gLCBncmFjZSAsIHRpY2tzOiB0aWNrT3B0cyAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XG4gICAgICAgIHRoaXMuYmVmb3JlVXBkYXRlKCk7XG4gICAgICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBib3R0b206IDBcbiAgICAgICAgfSwgbWFyZ2lucyk7XG4gICAgICAgIHRoaXMudGlja3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgICAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuX21heExlbmd0aCA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodCA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhTGltaXRzQ2FjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZURhdGFMaW1pdHMoKTtcbiAgICAgICAgICAgIHRoaXMuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xuICAgICAgICAgICAgdGhpcy5hZnRlckRhdGFMaW1pdHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3JhbmdlID0gX2FkZEdyYWNlKHRoaXMsIGdyYWNlLCBiZWdpbkF0WmVybyk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKTtcbiAgICAgICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuICAgICAgICB0aGlzLmFmdGVyQnVpbGRUaWNrcygpO1xuICAgICAgICBjb25zdCBzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgICAgICB0aGlzLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgICAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5hZnRlckF1dG9Ta2lwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICAgICAgdGhpcy5maXQoKTtcbiAgICAgICAgdGhpcy5hZnRlckZpdCgpO1xuICAgICAgICB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gICAgfVxuIGNvbmZpZ3VyZSgpIHtcbiAgICAgICAgbGV0IHJldmVyc2VQaXhlbHMgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZTtcbiAgICAgICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgc3RhcnRQaXhlbCA9IHRoaXMubGVmdDtcbiAgICAgICAgICAgIGVuZFBpeGVsID0gdGhpcy5yaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgIGVuZFBpeGVsID0gdGhpcy5ib3R0b207XG4gICAgICAgICAgICByZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XG4gICAgICAgIHRoaXMuX2VuZFBpeGVsID0gZW5kUGl4ZWw7XG4gICAgICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XG4gICAgICAgIHRoaXMuX2FsaWduVG9QaXhlbHMgPSB0aGlzLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcbiAgICB9XG4gICAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdKTtcbiAgICB9XG4gICAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHNldERpbWVuc2lvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSAwO1xuICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgICAgICB0aGlzLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgfVxuICAgIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdKTtcbiAgICB9XG4gICAgX2NhbGxIb29rcyhuYW1lKSB7XG4gICAgICAgIHRoaXMuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMub3B0aW9uc1tuYW1lXSwgW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdKTtcbiAgICB9XG4gICAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICAgICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVEYXRhTGltaXRzJyk7XG4gICAgfVxuICAgIGRldGVybWluZURhdGFMaW1pdHMoKSB7fVxuICAgIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICAgICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckRhdGFMaW1pdHMnKTtcbiAgICB9XG4gICAgYmVmb3JlQnVpbGRUaWNrcygpIHtcbiAgICAgICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gICAgfVxuIGJ1aWxkVGlja3MoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgICAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyQnVpbGRUaWNrcycpO1xuICAgIH1cbiAgICBiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSk7XG4gICAgfVxuIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgICAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICAgICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKyl7XG4gICAgICAgICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICAgICAgICB0aWNrLmxhYmVsID0gY2FsbGJhY2sodGlja09wdHMuY2FsbGJhY2ssIFtcbiAgICAgICAgICAgICAgICB0aWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgdGlja3NcbiAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgICAgIGNvbnN0IG51bVRpY2tzID0gZ2V0VGlja3NMaW1pdCh0aGlzLnRpY2tzLmxlbmd0aCwgb3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICAgICAgY29uc3QgbWluUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuICAgICAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgICAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgICAgICBsZXQgdGlja1dpZHRoLCBtYXhIZWlnaHQsIG1heExhYmVsRGlhZ29uYWw7XG4gICAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgICAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gX2xpbWl0VmFsdWUodGhpcy5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgsIDAsIHRoaXMubWF4V2lkdGgpO1xuICAgICAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG4gICAgICAgIGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuICAgICAgICAgICAgdGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG4gICAgICAgICAgICBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCkgLSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucy50aXRsZSwgdGhpcy5jaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgICAgICAgbWF4TGFiZWxEaWFnb25hbCA9IE1hdGguc3FydChtYXhMYWJlbFdpZHRoICogbWF4TGFiZWxXaWR0aCArIG1heExhYmVsSGVpZ2h0ICogbWF4TGFiZWxIZWlnaHQpO1xuICAgICAgICAgICAgbGFiZWxSb3RhdGlvbiA9IHRvRGVncmVlcyhNYXRoLm1pbihNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSwgTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSkgLSBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpKSk7XG4gICAgICAgICAgICBsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgICB9XG4gICAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhZnRlckF1dG9Ta2lwKCkge31cbiAgICBiZWZvcmVGaXQoKSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGZpdCgpIHtcbiAgICAgICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgY2hhcnQgLCBvcHRpb25zOiB7IHRpY2tzOiB0aWNrT3B0cyAsIHRpdGxlOiB0aXRsZU9wdHMgLCBncmlkOiBncmlkT3B0cyAgfSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9pc1Zpc2libGUoKTtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICAgICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gZ2V0VGl0bGVIZWlnaHQodGl0bGVPcHRzLCBjaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbWluU2l6ZS53aWR0aCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZpcnN0ICwgbGFzdCAsIHdpZGVzdCAsIGhpZ2hlc3QgIH0gPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nICogMjtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGggKyB0aWNrUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9sZW5ndGggPSBjaGFydC53aWR0aCAtIHRoaXMuX21hcmdpbnMubGVmdCAtIHRoaXMuX21hcmdpbnMucmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgICAgIGNvbnN0IHsgdGlja3M6IHsgYWxpZ24gLCBwYWRkaW5nICB9ICwgcG9zaXRpb24gIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGlzUm90YXRlZCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMDtcbiAgICAgICAgY29uc3QgbGFiZWxzQmVsb3dUaWNrcyA9IHBvc2l0aW9uICE9PSAndG9wJyAmJiB0aGlzLmF4aXMgPT09ICd4JztcbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldExlZnQgPSB0aGlzLmdldFBpeGVsRm9yVGljaygwKSAtIHRoaXMubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFJpZ2h0ID0gdGhpcy5yaWdodCAtIHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKHRoaXMudGlja3MubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBsZXQgcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgICAgICAgbGV0IHBhZGRpbmdSaWdodCA9IDA7XG4gICAgICAgICAgICBpZiAoaXNSb3RhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsc0JlbG93VGlja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSBjb3MgKiBmaXJzdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGNvcyAqIGxhc3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApO1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldFJpZ2h0KSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nO1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbSArIHBhZGRpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXJnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJnaW5zLmxlZnQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdMZWZ0LCB0aGlzLl9tYXJnaW5zLmxlZnQpO1xuICAgICAgICAgICAgdGhpcy5fbWFyZ2lucy50b3AgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdUb3AsIHRoaXMuX21hcmdpbnMudG9wKTtcbiAgICAgICAgICAgIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0JvdHRvbSwgdGhpcy5fbWFyZ2lucy5ib3R0b20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFmdGVyRml0KCkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSk7XG4gICAgfVxuIGlzSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgY29uc3QgeyBheGlzICwgcG9zaXRpb24gIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IGF4aXMgPT09ICd4JztcbiAgICB9XG4gaXNGdWxsU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgICB9XG4gX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgICAgIHRoaXMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcbiAgICAgICAgbGV0IGksIGlsZW47XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKyl7XG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICB0aWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaWxlbi0tO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gICAgfVxuIF9nZXRMYWJlbFNpemVzKCkge1xuICAgICAgICBsZXQgbGFiZWxTaXplcyA9IHRoaXMuX2xhYmVsU2l6ZXM7XG4gICAgICAgIGlmICghbGFiZWxTaXplcykge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgICAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlja3MgPSBzYW1wbGUodGlja3MsIHNhbXBsZVNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IGxhYmVsU2l6ZXMgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgdGlja3MubGVuZ3RoLCB0aGlzLm9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsU2l6ZXM7XG4gICAgfVxuIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4ICwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlcyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgICAgICBjb25zdCBoZWlnaHRzID0gW107XG4gICAgICAgIGNvbnN0IGluY3JlbWVudCA9IE1hdGguZmxvb3IobGVuZ3RoIC8gZ2V0VGlja3NMaW1pdChsZW5ndGgsIG1heFRpY2tzTGltaXQpKTtcbiAgICAgICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgICAgIGxldCBoaWdoZXN0TGFiZWxTaXplID0gMDtcbiAgICAgICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gaW5jcmVtZW50KXtcbiAgICAgICAgICAgIGxhYmVsID0gdGlja3NbaV0ubGFiZWw7XG4gICAgICAgICAgICB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICAgICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7XG4gICAgICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICAgICAgZ2M6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICBmb3IoaiA9IDAsIGpsZW4gPSBsYWJlbC5sZW5ndGg7IGogPCBqbGVuOyArK2ope1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRMYWJlbCA9ICBsYWJlbFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpZHRocy5wdXNoKHdpZHRoKTtcbiAgICAgICAgICAgIGhlaWdodHMucHVzaChoZWlnaHQpO1xuICAgICAgICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICAgICAgICBoaWdoZXN0TGFiZWxTaXplID0gTWF0aC5tYXgoaGVpZ2h0LCBoaWdoZXN0TGFiZWxTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlQXQgPSAoaWR4KT0+KHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgICAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgICAgICAgIHdpZHRocyxcbiAgICAgICAgICAgIGhlaWdodHNcbiAgICAgICAgfTtcbiAgICB9XG4gZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuIGdldFBpeGVsRm9yVmFsdWUodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHt9XG4gZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgICB9XG4gZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgICAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xuICAgICAgICByZXR1cm4gX2ludDE2UmFuZ2UodGhpcy5fYWxpZ25Ub1BpeGVscyA/IF9hbGlnblBpeGVsKHRoaXMuY2hhcnQsIHBpeGVsLCAwKSA6IHBpeGVsKTtcbiAgICB9XG4gZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSB7XG4gICAgICAgIGNvbnN0IGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gICAgfVxuIGdldEJhc2VQaXhlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgICB9XG4gZ2V0QmFzZVZhbHVlKCkge1xuICAgICAgICBjb25zdCB7IG1pbiAsIG1heCAgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOiBtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOiAwO1xuICAgIH1cbiBnZXRDb250ZXh0KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgICAgICAgICByZXR1cm4gdGljay4kY29udGV4dCB8fCAodGljay4kY29udGV4dCA9IGNyZWF0ZVRpY2tDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgdGljaykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlU2NhbGVDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzKSk7XG4gICAgfVxuIF90aWNrU2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgICAgIGNvbnN0IHJvdCA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG4gICAgICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICAgICAgY29uc3QgdyA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLndpZGVzdC53aWR0aCArIHBhZGRpbmcgOiAwO1xuICAgICAgICBjb25zdCBoID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKCkgPyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luIDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcbiAgICB9XG4gX2lzVmlzaWJsZSgpIHtcbiAgICAgICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuICAgICAgICBpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXR1cm4gISFkaXNwbGF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgICB9XG4gX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgICAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgZ3JpZCAsIHBvc2l0aW9uICwgYm9yZGVyICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZ3JpZC5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgICAgY29uc3QgdGlja3NMZW5ndGggPSB0aWNrcy5sZW5ndGggKyAob2Zmc2V0ID8gMSA6IDApO1xuICAgICAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICBjb25zdCBib3JkZXJPcHRzID0gYm9yZGVyLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgICAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXJPcHRzLmRpc3BsYXkgPyBib3JkZXJPcHRzLndpZHRoIDogMDtcbiAgICAgICAgY29uc3QgYXhpc0hhbGZXaWR0aCA9IGF4aXNXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGJvcmRlclZhbHVlLCBpLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5ib3R0b20pO1xuICAgICAgICAgICAgdHkxID0gdGhpcy5ib3R0b20gLSB0bDtcbiAgICAgICAgICAgIHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgICAgICAgIHkxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEudG9wKSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICAgICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xuICAgICAgICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgICAgICAgeTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgICAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgICAgICAgIHR5MiA9IHRoaXMudG9wICsgdGw7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMucmlnaHQpO1xuICAgICAgICAgICAgdHgxID0gdGhpcy5yaWdodCAtIHRsO1xuICAgICAgICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgICAgICAgeDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICAgICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMubGVmdCk7XG4gICAgICAgICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgICAgICAgeDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgICAgICAgdHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgICAgICAgdHgyID0gdGhpcy5sZWZ0ICsgdGw7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyICsgMC41KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgICAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICAgICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICAgICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICAgICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR4MSA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgICAgICAgIHR4MiA9IHR4MSAtIHRsO1xuICAgICAgICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgICAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0LCB0aWNrc0xlbmd0aCk7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgaSArPSBzdGVwKXtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoaSk7XG4gICAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgICAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoIHx8IFtdO1xuICAgICAgICAgICAgY29uc3QgYm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4Qm9yZGVyLmRhc2hPZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICAgICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICAgICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcbiAgICAgICAgICAgIGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUodGhpcywgaSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgdHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHgxLFxuICAgICAgICAgICAgICAgIHR5MSxcbiAgICAgICAgICAgICAgICB0eDIsXG4gICAgICAgICAgICAgICAgdHkyLFxuICAgICAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgICAgIHgyLFxuICAgICAgICAgICAgICAgIHkyLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgICAgICAgICBib3JkZXJEYXNoLFxuICAgICAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICAgICAgdGlja1dpZHRoLFxuICAgICAgICAgICAgICAgIHRpY2tDb2xvcixcbiAgICAgICAgICAgICAgICB0aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICAgICAgdGhpcy5fYm9yZGVyVmFsdWUgPSBib3JkZXJWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb24gLCB0aWNrczogb3B0aW9uVGlja3MgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICAgIGNvbnN0IHsgYWxpZ24gLCBjcm9zc0FsaWduICwgcGFkZGluZyAsIG1pcnJvciAgfSA9IG9wdGlvblRpY2tzO1xuICAgICAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCk7XG4gICAgICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgICAgICBjb25zdCBoVGlja0FuZFBhZGRpbmcgPSBtaXJyb3IgPyAtcGFkZGluZyA6IHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgbGV0IGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XG4gICAgICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgeSA9IHRoaXMuYm90dG9tIC0gaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgeSA9IHRoaXMudG9wICsgaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgICAgICAgIHggPSByZXQueDtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgICAgICAgeCA9IHJldC54O1xuICAgICAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIHkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgeCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICAgICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICAgICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG4gICAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IG9wdGlvblRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgICAgICAgIHBpeGVsID0gdGhpcy5nZXRQaXhlbEZvclRpY2soaSkgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcbiAgICAgICAgICAgIGZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgICAgICAgbGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcbiAgICAgICAgICAgIGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcbiAgICAgICAgICAgIGNvbnN0IGhhbGZDb3VudCA9IGxpbmVDb3VudCAvIDI7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aDtcbiAgICAgICAgICAgIGxldCB0aWNrVGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHggPSBwaXhlbDtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm90YXRpb24gIT09IDAgJiYgIW9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gbGluZUhlaWdodCAvIDIgKiBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJhY2tkcm9wO1xuICAgICAgICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxQYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IHRleHRPZmZzZXQgLSBsYWJlbFBhZGRpbmcudG9wO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gMCAtIGxhYmVsUGFkZGluZy5sZWZ0O1xuICAgICAgICAgICAgICAgIHN3aXRjaCh0ZXh0QmFzZWxpbmUpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wIC09IGhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoKHRleHRBbGlnbil7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhY2tkcm9wID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCArIGxhYmVsUGFkZGluZy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBmb250LFxuICAgICAgICAgICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0aWNrVGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb24gLCB0aWNrcyAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICAgIGFsaWduID0gJ2lubmVyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgfVxuICAgIF9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKSB7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb24gLCB0aWNrczogeyBjcm9zc0FsaWduICwgbWlycm9yICwgcGFkZGluZyAgfSAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgICAgICBsZXQgdGV4dEFsaWduO1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gd2lkZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgeCAtPSB3aWRlc3QgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgeCAtPSB3aWRlc3QgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICAgICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHRBbGlnbixcbiAgICAgICAgICAgIHhcbiAgICAgICAgfTtcbiAgICB9XG4gX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMubGVmdCxcbiAgICAgICAgICAgICAgICBib3R0b206IGNoYXJ0LmhlaWdodCxcbiAgICAgICAgICAgICAgICByaWdodDogdGhpcy5yaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiB0aGlzLmJvdHRvbSxcbiAgICAgICAgICAgICAgICByaWdodDogY2hhcnQud2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gZHJhd0JhY2tncm91bmQoKSB7XG4gICAgICAgIGNvbnN0IHsgY3R4ICwgb3B0aW9uczogeyBiYWNrZ3JvdW5kQ29sb3IgIH0gLCBsZWZ0ICwgdG9wICwgd2lkdGggLCBoZWlnaHQgIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIWdyaWQuZGlzcGxheSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRpY2tzLmZpbmRJbmRleCgodCk9PnQudmFsdWUgPT09IHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICAgICAgbGV0IGksIGlsZW47XG4gICAgICAgIGNvbnN0IGRyYXdMaW5lID0gKHAxLCBwMiwgc3R5bGUpPT57XG4gICAgICAgICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgICAgICAgIGZvcihpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3TGluZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpdGVtLngxLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaXRlbS55MVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpdGVtLngyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaXRlbS55MlxuICAgICAgICAgICAgICAgICAgICB9LCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdMaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGl0ZW0udHgxLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaXRlbS50eTFcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogaXRlbS50eDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBpdGVtLnR5MlxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaXRlbS50aWNrV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gZHJhd0JvcmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjaGFydCAsIGN0eCAsIG9wdGlvbnM6IHsgYm9yZGVyICwgZ3JpZCAgfSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlci5kaXNwbGF5ID8gYm9yZGVyT3B0cy53aWR0aCA6IDA7XG4gICAgICAgIGlmICghYXhpc1dpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICAgICAgY29uc3QgYm9yZGVyVmFsdWUgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICAgICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgICAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICAgICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICAgICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgICAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy53aWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyT3B0cy5jb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgICAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICAgICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgICAgIGlmIChhcmVhKSB7XG4gICAgICAgICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcyl7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJUZXh0T3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgICAgICAgY29uc3QgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgICAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIHJlbmRlclRleHRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJlYSkge1xuICAgICAgICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgICAgICB9XG4gICAgfVxuIGRyYXdUaXRsZSgpIHtcbiAgICAgICAgY29uc3QgeyBjdHggLCBvcHRpb25zOiB7IHBvc2l0aW9uICwgdGl0bGUgLCByZXZlcnNlICB9ICB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICAgICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcbiAgICAgICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgcG9zaXRpb24gPT09ICdjZW50ZXInIHx8IGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcuYm90dG9tO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodGl0bGUudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gcGFkZGluZy50b3A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0aXRsZVggLCB0aXRsZVkgLCBtYXhXaWR0aCAsIHJvdGF0aW9uICB9ID0gdGl0bGVBcmdzKHRoaXMsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKTtcbiAgICAgICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgICAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgICAgICAgIG1heFdpZHRoLFxuICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICAgICAgICB0cmFuc2xhdGlvbjogW1xuICAgICAgICAgICAgICAgIHRpdGxlWCxcbiAgICAgICAgICAgICAgICB0aXRsZVlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgIH1cbiBfbGF5ZXJzKCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XG4gICAgICAgIGNvbnN0IGJ6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ib3JkZXIgJiYgb3B0cy5ib3JkZXIueiwgMCk7XG4gICAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBTY2FsZS5wcm90b3R5cGUuZHJhdykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHo6IHR6LFxuICAgICAgICAgICAgICAgICAgICBkcmF3OiAoY2hhcnRBcmVhKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgejogZ3osXG4gICAgICAgICAgICAgICAgZHJhdzogKGNoYXJ0QXJlYSk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB6OiBieixcbiAgICAgICAgICAgICAgICBkcmF3OiAoKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHo6IHR6LFxuICAgICAgICAgICAgICAgIGRyYXc6IChjaGFydEFyZWEpPT57XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG4gZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xuICAgICAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgICAgICBjb25zdCBheGlzSUQgPSB0aGlzLmF4aXMgKyAnQXhpc0lEJztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICAgIH1cbiBfbWF4RGlnaXRzKCkge1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICAgIH1cbn1cblxuY2xhc3MgVHlwZWRSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKXtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBpc0ZvclR5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICAgIH1cbiByZWdpc3RlcihpdGVtKSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGl0ZW0pO1xuICAgICAgICBsZXQgcGFyZW50U2NvcGU7XG4gICAgICAgIGlmIChpc0lDaGFydENvbXBvbmVudChwcm90bykpIHtcbiAgICAgICAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZSArICcuJyArIGlkO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgICAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiBnZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICAgIH1cbiB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcbiAgICAgICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICAgICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY29wZSAmJiBpZCBpbiBkZWZhdWx0c1tzY29wZV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgICAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICAgICAgZGVmYXVsdHMuZ2V0KHNjb3BlKSxcbiAgICAgICAgaXRlbS5kZWZhdWx0c1xuICAgIF0pO1xuICAgIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcbiAgICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgICAgIHJvdXRlRGVmYXVsdHMoc2NvcGUsIGl0ZW0uZGVmYXVsdFJvdXRlcyk7XG4gICAgfVxuICAgIGlmIChpdGVtLmRlc2NyaXB0b3JzKSB7XG4gICAgICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgICB9XG59XG5mdW5jdGlvbiByb3V0ZURlZmF1bHRzKHNjb3BlLCByb3V0ZXMpIHtcbiAgICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2goKHByb3BlcnR5KT0+e1xuICAgICAgICBjb25zdCBwcm9wZXJ0eVBhcnRzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW1xuICAgICAgICAgICAgc2NvcGVcbiAgICAgICAgXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHJvdXRlc1twcm9wZXJ0eV0uc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgICAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgZGVmYXVsdHMucm91dGUoc291cmNlU2NvcGUsIHNvdXJjZU5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSB7XG4gICAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cblxuY2xhc3MgUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3IFR5cGVkUmVnaXN0cnkoT2JqZWN0LCAncGx1Z2lucycpO1xuICAgICAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcnMsXG4gICAgICAgICAgICB0aGlzLnNjYWxlcyxcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNcbiAgICAgICAgXTtcbiAgICB9XG4gYWRkKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgICB9XG4gICAgcmVtb3ZlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICAgIH1cbiBhZGRDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gICAgfVxuIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgICB9XG4gYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgICB9XG4gYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gICAgfVxuIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgICB9XG4gZ2V0RWxlbWVudChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmVsZW1lbnRzLCAnZWxlbWVudCcpO1xuICAgIH1cbiBnZXRQbHVnaW4oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5wbHVnaW5zLCAncGx1Z2luJyk7XG4gICAgfVxuIGdldFNjYWxlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuc2NhbGVzLCAnc2NhbGUnKTtcbiAgICB9XG4gcmVtb3ZlQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgICAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gICAgfVxuIHJlbW92ZUVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICAgIH1cbiByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gICAgfVxuIHJlbW92ZVNjYWxlcyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gICAgfVxuIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgICAgICBbXG4gICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgIF0uZm9yRWFjaCgoYXJnKT0+e1xuICAgICAgICAgICAgY29uc3QgcmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoYXJnKTtcbiAgICAgICAgICAgIGlmICh0eXBlZFJlZ2lzdHJ5IHx8IHJlZy5pc0ZvclR5cGUoYXJnKSB8fCByZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlYWNoKGFyZywgKGl0ZW0pPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIGl0ZW1SZWcsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gX2V4ZWMobWV0aG9kLCByZWdpc3RyeSwgY29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgICAgICAgcmVnaXN0cnlbbWV0aG9kXShjb21wb25lbnQpO1xuICAgICAgICBjYWxsYmFjayhjb21wb25lbnRbJ2FmdGVyJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7XG4gICAgfVxuIF9nZXRSZWdpc3RyeUZvclR5cGUodHlwZSkge1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IHJlZyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tpXTtcbiAgICAgICAgICAgIGlmIChyZWcuaXNGb3JUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICAgIH1cbiBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0eXBlZFJlZ2lzdHJ5LmdldChpZCk7XG4gICAgICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaWQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgdHlwZSArICcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxufVxudmFyIHJlZ2lzdHJ5ID0gLyogI19fUFVSRV9fICovIG5ldyBSZWdpc3RyeSgpO1xuXG5jbGFzcyBQbHVnaW5TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLl9pbml0ID0gW107XG4gICAgfVxuIG5vdGlmeShjaGFydCwgaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgICAgIGlmIChob29rID09PSAnYmVmb3JlSW5pdCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXQgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWx0ZXIgPyB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCkuZmlsdGVyKGZpbHRlcikgOiB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuICAgICAgICBpZiAoaG9vayA9PT0gJ2FmdGVyRGVzdHJveScpIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgICAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICAgICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKXtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW1xuICAgICAgICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5vcHRpb25zXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKG1ldGhvZCwgcGFyYW1zLCBwbHVnaW4pID09PSBmYWxzZSAmJiBhcmdzLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICAgICAgdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICAgIH1cbiAgICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZU9yRGVmYXVsdChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gICAgICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgICB9XG4gX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGU7XG4gICAgICAgIGNvbnN0IGRpZmYgPSAoYSwgYik9PmEuZmlsdGVyKCh4KT0+IWIuc29tZSgoeSk9PngucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoZGlmZihwcmV2aW91c0Rlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgICB9XG59XG4gZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgICBjb25zdCBsb2NhbElkcyA9IHt9O1xuICAgIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWwgPSBjb25maWcucGx1Z2lucyB8fCBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcbiAgICAgICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICBsb2NhbElkc1twbHVnaW4uaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwbHVnaW5zLFxuICAgICAgICBsb2NhbElkc1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRPcHRzKG9wdGlvbnMsIGFsbCkge1xuICAgIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHsgcGx1Z2lucyAsIGxvY2FsSWRzICB9LCBvcHRpb25zLCBhbGwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBjb250ZXh0ID0gY2hhcnQuZ2V0Q29udGV4dCgpO1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpe1xuICAgICAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywge1xuICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICBsb2NhbDogbG9jYWxJZHNbaWRdXG4gICAgICAgICAgICB9LCBvcHRzLCBjb250ZXh0KVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBsdWdpbk9wdHMoY29uZmlnLCB7IHBsdWdpbiAsIGxvY2FsICB9LCBvcHRzLCBjb250ZXh0KSB7XG4gICAgY29uc3Qga2V5cyA9IGNvbmZpZy5wbHVnaW5TY29wZUtleXMocGx1Z2luKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICAgIGlmIChsb2NhbCAmJiBwbHVnaW4uZGVmYXVsdHMpIHtcbiAgICAgICAgc2NvcGVzLnB1c2gocGx1Z2luLmRlZmF1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFtcbiAgICAgICAgJydcbiAgICBdLCB7XG4gICAgICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgICBpbmRleGFibGU6IGZhbHNlLFxuICAgICAgICBhbGxLZXlzOiB0cnVlXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gICAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoaWQsIGluZGV4QXhpcykge1xuICAgIGxldCBheGlzID0gaWQ7XG4gICAgaWYgKGlkID09PSAnX2luZGV4XycpIHtcbiAgICAgICAgYXhpcyA9IGluZGV4QXhpcztcbiAgICB9IGVsc2UgaWYgKGlkID09PSAnX3ZhbHVlXycpIHtcbiAgICAgICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcztcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgaW5kZXhBeGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cbmZ1bmN0aW9uIGlkTWF0Y2hlc0F4aXMoaWQpIHtcbiAgICBpZiAoaWQgPT09ICd4JyB8fCBpZCA9PT0gJ3knIHx8IGlkID09PSAncicpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICByZXR1cm4gJ3gnO1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICByZXR1cm4gJ3knO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZUF4aXMoaWQsIC4uLnNjYWxlT3B0aW9ucykge1xuICAgIGlmIChpZE1hdGNoZXNBeGlzKGlkKSkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3B0cyBvZiBzY2FsZU9wdGlvbnMpe1xuICAgICAgICBjb25zdCBheGlzID0gb3B0cy5heGlzIHx8IGF4aXNGcm9tUG9zaXRpb24ob3B0cy5wb3NpdGlvbikgfHwgaWQubGVuZ3RoID4gMSAmJiBpZE1hdGNoZXNBeGlzKGlkWzBdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoYXhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGF4aXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGV0ZXJtaW5lIHR5cGUgb2YgJyR7aWR9JyBheGlzLiBQbGVhc2UgcHJvdmlkZSAnYXhpcycgb3IgJ3Bvc2l0aW9uJyBvcHRpb24uYCk7XG59XG5mdW5jdGlvbiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsIGF4aXMsIGRhdGFzZXQpIHtcbiAgICBpZiAoZGF0YXNldFtheGlzICsgJ0F4aXNJRCddID09PSBpZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXhpc1xuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5kYXRhICYmIGNvbmZpZy5kYXRhLmRhdGFzZXRzKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kRHMgPSBjb25maWcuZGF0YS5kYXRhc2V0cy5maWx0ZXIoKGQpPT5kLnhBeGlzSUQgPT09IGlkIHx8IGQueUF4aXNJRCA9PT0gaWQpO1xuICAgICAgICBpZiAoYm91bmREcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsICd4JywgYm91bmREc1swXSkgfHwgZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCAneScsIGJvdW5kRHNbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn1cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge1xuICAgICAgICBzY2FsZXM6IHt9XG4gICAgfTtcbiAgICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgICBjb25zdCBjaGFydEluZGV4QXhpcyA9IGdldEluZGV4QXhpcyhjb25maWcudHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc2NhbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goKGlkKT0+e1xuICAgICAgICBjb25zdCBzY2FsZUNvbmYgPSBjb25maWdTY2FsZXNbaWRdO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHNjYWxlQ29uZikpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZiwgcmV0cmlldmVBeGlzRnJvbURhdGFzZXRzKGlkLCBjb25maWcpLCBkZWZhdWx0cy5zY2FsZXNbc2NhbGVDb25mLnR5cGVdKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBjaGFydERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICAgICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF4aXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2FsZUNvbmYsXG4gICAgICAgICAgICBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLFxuICAgICAgICAgICAgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SWRdXG4gICAgICAgIF0pO1xuICAgIH0pO1xuICAgIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQpPT57XG4gICAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgY29uZmlnLnR5cGU7XG4gICAgICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgICAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gZGF0YXNldERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaCgoZGVmYXVsdElEKT0+e1xuICAgICAgICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgYXhpcztcbiAgICAgICAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbmZpZ1NjYWxlc1tpZF0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SURdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgICAgIG1lcmdlSWYoc2NhbGUsIFtcbiAgICAgICAgICAgIGRlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSxcbiAgICAgICAgICAgIGRlZmF1bHRzLnNjYWxlXG4gICAgICAgIF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzY2FsZXM7XG59XG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuICAgIG9wdGlvbnMucGx1Z2lucyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuICAgIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG59XG5jb25zdCBrZXlDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IGtleXNDYWNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBjYWNoZWRLZXlzKGNhY2hlS2V5LCBnZW5lcmF0ZSkge1xuICAgIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWtleXMpIHtcbiAgICAgICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAgICAgIGtleUNhY2hlLnNldChjYWNoZUtleSwga2V5cyk7XG4gICAgICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSk9PntcbiAgICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXQuYWRkKG9wdHMpO1xuICAgIH1cbn07XG5jbGFzcyBDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyl7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0IHBsYXRmb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICAgIH1cbiAgICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgICB9XG4gICAgc2V0IGRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9jb25maWcuZGF0YSA9IGluaXREYXRhKGRhdGEpO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICAgIH1cbiAgICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICAgIH1cbiAgICBjbGVhckNhY2hlKCkge1xuICAgICAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgICAgICByZXR1cm4gY2FjaGVkS2V5cyhkYXRhc2V0VHlwZSwgKCk9PltcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSk7XG4gICAgfVxuIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsICgpPT5bXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIF0pO1xuICAgIH1cbiBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LSR7ZWxlbWVudFR5cGV9YCwgKCk9PltcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICAgICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICAgICAgICAgICAgIGBlbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSk7XG4gICAgfVxuIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICAgICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsICgpPT5bXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSk7XG4gICAgfVxuIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICAgICAgbGV0IGNhY2hlID0gX3Njb3BlQ2FjaGUuZ2V0KG1haW5TY29wZSk7XG4gICAgICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgLCB0eXBlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGtleUxpc3RzLmZvckVhY2goKGtleXMpPT57XG4gICAgICAgICAgICBpZiAobWFpblNjb3BlKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KT0+YWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goKGtleSk9PmFkZElmRm91bmQoc2NvcGVzLCBvcHRpb25zLCBrZXkpKTtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KT0+YWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goKGtleSk9PmFkZElmRm91bmQoc2NvcGVzLCBkZWZhdWx0cywga2V5KSk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goKGtleSk9PmFkZElmRm91bmQoc2NvcGVzLCBkZXNjcmlwdG9ycywga2V5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oc2NvcGVzKTtcbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5c0NhY2hlZC5oYXMoa2V5TGlzdHMpKSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQoa2V5TGlzdHMsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgLCB0eXBlICB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvdmVycmlkZXNbdHlwZV0gfHwge30sXG4gICAgICAgICAgICBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgICAgICBkZXNjcmlwdG9yc1xuICAgICAgICBdO1xuICAgIH1cbiByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gW1xuICAgICAgICAnJ1xuICAgIF0pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJHNoYXJlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IHJlc29sdmVyICwgc3ViUHJlZml4ZXMgIH0gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSByZXNvbHZlcjtcbiAgICAgICAgaWYgKG5lZWRDb250ZXh0KHJlc29sdmVyLCBuYW1lcykpIHtcbiAgICAgICAgICAgIHJlc3VsdC4kc2hhcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICAgICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpe1xuICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gW1xuICAgICAgICAnJ1xuICAgIF0sIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVyICB9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KSA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cykgOiByZXNvbHZlcjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gICAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XG4gICAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFjYWNoZWQpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgICAgIGNhY2hlZCA9IHtcbiAgICAgICAgICAgIHJlc29sdmVyLFxuICAgICAgICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcigocCk9PiFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXG4gICAgICAgIH07XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbn1cbmNvbnN0IGhhc0Z1bmN0aW9uID0gKHZhbHVlKT0+aXNPYmplY3QodmFsdWUpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoKGFjYywga2V5KT0+YWNjIHx8IGlzRnVuY3Rpb24odmFsdWVba2V5XSksIGZhbHNlKTtcbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICAgIGNvbnN0IHsgaXNTY3JpcHRhYmxlICwgaXNJbmRleGFibGUgIH0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcyl7XG4gICAgICAgIGNvbnN0IHNjcmlwdGFibGUgPSBpc1NjcmlwdGFibGUocHJvcCk7XG4gICAgICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XG4gICAgICAgIGlmIChzY3JpcHRhYmxlICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBoYXNGdW5jdGlvbih2YWx1ZSkpIHx8IGluZGV4YWJsZSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiNC40LjBcIjtcblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gW1xuICAgICd0b3AnLFxuICAgICdib3R0b20nLFxuICAgICdsZWZ0JyxcbiAgICAncmlnaHQnLFxuICAgICdjaGFydEFyZWEnXG5dO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBLTk9XTl9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIGF4aXMgPT09ICd4Jztcbn1cbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbbDFdID09PSBiW2wxXSA/IGFbbDJdIC0gYltsMl0gOiBhW2wxXSAtIGJbbDFdO1xuICAgIH07XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gICAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICAgIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbXG4gICAgICAgIGNvbnRleHRcbiAgICBdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbXG4gICAgICAgIGNvbnRleHRcbiAgICBdLCBjaGFydCk7XG59XG4gZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1bMF07XG4gICAgfVxuICAgIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59XG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSk9PntcbiAgICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZpbHRlcigoYyk9PmMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcbmZ1bmN0aW9uIG1vdmVOdW1lcmljS2V5cyhvYmosIHN0YXJ0LCBtb3ZlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyl7XG4gICAgICAgIGNvbnN0IGludEtleSA9ICtrZXk7XG4gICAgICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBvYmpbaW50S2V5ICsgbW92ZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiBmdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICAgIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNDbGljaykge1xuICAgICAgICByZXR1cm4gbGFzdEV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGdldFNpemVGb3JBcmVhKHNjYWxlLCBjaGFydEFyZWEsIGZpZWxkKSB7XG4gICAgcmV0dXJuIHNjYWxlLm9wdGlvbnMuY2xpcCA/IHNjYWxlW2ZpZWxkXSA6IGNoYXJ0QXJlYVtmaWVsZF07XG59XG5mdW5jdGlvbiBnZXREYXRhc2V0QXJlYShtZXRhLCBjaGFydEFyZWEpIHtcbiAgICBjb25zdCB7IHhTY2FsZSAsIHlTY2FsZSAgfSA9IG1ldGE7XG4gICAgaWYgKHhTY2FsZSAmJiB5U2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGdldFNpemVGb3JBcmVhKHhTY2FsZSwgY2hhcnRBcmVhLCAnbGVmdCcpLFxuICAgICAgICAgICAgcmlnaHQ6IGdldFNpemVGb3JBcmVhKHhTY2FsZSwgY2hhcnRBcmVhLCAncmlnaHQnKSxcbiAgICAgICAgICAgIHRvcDogZ2V0U2l6ZUZvckFyZWEoeVNjYWxlLCBjaGFydEFyZWEsICd0b3AnKSxcbiAgICAgICAgICAgIGJvdHRvbTogZ2V0U2l6ZUZvckFyZWEoeVNjYWxlLCBjaGFydEFyZWEsICdib3R0b20nKVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnRBcmVhO1xufVxuY2xhc3MgQ2hhcnQge1xuICAgIHN0YXRpYyBkZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIHN0YXRpYyBpbnN0YW5jZXMgPSBpbnN0YW5jZXM7XG4gICAgc3RhdGljIG92ZXJyaWRlcyA9IG92ZXJyaWRlcztcbiAgICBzdGF0aWMgcmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgICBzdGF0aWMgdmVyc2lvbiA9IHZlcnNpb247XG4gICAgc3RhdGljIGdldENoYXJ0ID0gZ2V0Q2hhcnQ7XG4gICAgc3RhdGljIHJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgICAgIHJlZ2lzdHJ5LmFkZCguLi5pdGVtcyk7XG4gICAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICAgIHN0YXRpYyB1bnJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgICAgIHJlZ2lzdHJ5LnJlbW92ZSguLi5pdGVtcyk7XG4gICAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJDb25maWcpe1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcodXNlckNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxDYW52YXMgPSBnZXRDYW52YXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nQ2hhcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgKyAnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuY2FudmFzLmlkICsgJ1xcJyBjYW4gYmUgcmV1c2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS51cGRhdGVDb25maWcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG4gICAgICAgIHRoaXMuaWQgPSB1aWQoKTtcbiAgICAgICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgICAgIHRoaXMuX21ldGFzZXRzID0gW107XG4gICAgICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ib3hlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgICAgIHRoaXMuX2xhc3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgICAgICB0aGlzLl9wbHVnaW5zID0gbmV3IFBsdWdpblNlcnZpY2UoKTtcbiAgICAgICAgdGhpcy4kcHJveGllcyA9IHt9O1xuICAgICAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9kb1Jlc2l6ZSA9IGRlYm91bmNlKChtb2RlKT0+dGhpcy51cGRhdGUobW9kZSksIG9wdGlvbnMucmVzaXplRGVsYXkgfHwgMCk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG4gICAgICAgIGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdjb21wbGV0ZScsIG9uQW5pbWF0aW9uc0NvbXBsZXRlKTtcbiAgICAgICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdwcm9ncmVzcycsIG9uQW5pbWF0aW9uUHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zOiB7IGFzcGVjdFJhdGlvICwgbWFpbnRhaW5Bc3BlY3RSYXRpbyAgfSAsIHdpZHRoICwgaGVpZ2h0ICwgX2FzcGVjdFJhdGlvICB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYWludGFpbkFzcGVjdFJhdGlvICYmIF9hc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gICAgfVxuICAgIHNldCBkYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gICAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IHJlZ2lzdHJ5KCkge1xuICAgICAgICByZXR1cm4gcmVnaXN0cnk7XG4gICAgfVxuIF9pbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGNsZWFyQ2FudmFzKHRoaXMuY2FudmFzLCB0aGlzLmN0eCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBhbmltYXRvci5zdG9wKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICAgICAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgICAgY29uc3QgbW9kZSA9IHRoaXMud2lkdGggPyAncmVzaXplJyA6ICdhdHRhY2gnO1xuICAgICAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBuZXdTaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge1xuICAgICAgICAgICAgc2l6ZTogbmV3U2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbGJhY2sob3B0aW9ucy5vblJlc2l6ZSwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG5ld1NpemVcbiAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZG9SZXNpemUobW9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgICAgICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCk9PntcbiAgICAgICAgICAgIGF4aXNPcHRpb25zLmlkID0gYXhpc0lEO1xuICAgICAgICB9KTtcbiAgICB9XG4gYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3Qgc2NhbGVPcHRzID0gb3B0aW9ucy5zY2FsZXM7XG4gICAgICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgICAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpPT57XG4gICAgICAgICAgICBvYmpbaWRdID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICBpZiAoc2NhbGVPcHRzKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChPYmplY3Qua2V5cyhzY2FsZU9wdHMpLm1hcCgoaWQpPT57XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGVPcHRzW2lkXTtcbiAgICAgICAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhZGlhbCA9IGF4aXMgPT09ICdyJztcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogc2NhbGVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVhY2goaXRlbXMsIChpdGVtKT0+e1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG4gICAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlVHlwZSA9IHZhbHVlT3JEZWZhdWx0KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcbiAgICAgICAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBzY2FsZXNbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZUNsYXNzID0gcmVnaXN0cnkuZ2V0U2NhbGUoc2NhbGVUeXBlKTtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQ6IHRoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKHVwZGF0ZWQsIChoYXNVcGRhdGVkLCBpZCk9PntcbiAgICAgICAgICAgIGlmICghaGFzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2FsZXNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWFjaChzY2FsZXMsIChzY2FsZSk9PntcbiAgICAgICAgICAgIGxheW91dHMuY29uZmlndXJlKHRoaXMsIHNjYWxlLCBzY2FsZS5vcHRpb25zKTtcbiAgICAgICAgICAgIGxheW91dHMuYWRkQm94KHRoaXMsIHNjYWxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICAgICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICAgICAgY29uc3QgbnVtRGF0YSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG4gICAgICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpPT5hLmluZGV4IC0gYi5pbmRleCk7XG4gICAgICAgIGlmIChudW1NZXRhID4gbnVtRGF0YSkge1xuICAgICAgICAgICAgZm9yKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSl7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YXNldHMuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gICAgfVxuIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICAgICAgY29uc3QgeyBfbWV0YXNldHM6IG1ldGFzZXRzICwgZGF0YTogeyBkYXRhc2V0cyAgfSAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgICAgIH1cbiAgICAgICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpPT57XG4gICAgICAgICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKCh4KT0+eCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpIHtcbiAgICAgICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSB0aGlzLmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgICB0aGlzLl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2ldO1xuICAgICAgICAgICAgbGV0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCB0aGlzLmNvbmZpZy50eXBlO1xuICAgICAgICAgICAgaWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICAgICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgICAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICAgICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG4gICAgICAgICAgICBpZiAobWV0YS5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICAgICAgICAgIG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IENvbnRyb2xsZXJDbGFzcyA9IHJlZ2lzdHJ5LmdldENvbnRyb2xsZXIodHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhc2V0RWxlbWVudFR5cGUgLCBkYXRhRWxlbWVudFR5cGUgIH0gPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcywge1xuICAgICAgICAgICAgICAgICAgICBkYXRhRWxlbWVudFR5cGU6IHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YUVsZW1lbnRUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBkYXRhc2V0RWxlbWVudFR5cGUgJiYgcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhc2V0RWxlbWVudFR5cGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlTWV0YXNldHMoKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICAgIH1cbiBfcmVzZXRFbGVtZW50cygpIHtcbiAgICAgICAgZWFjaCh0aGlzLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpPT57XG4gICAgICAgICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG4gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNldCcpO1xuICAgIH1cbiAgICB1cGRhdGUobW9kZSkge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgICAgICBjb25zdCBhbmltc0Rpc2FibGVkID0gdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gIW9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgICB0aGlzLl91cGRhdGVTY2FsZXMoKTtcbiAgICAgICAgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcbiAgICAgICAgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHtcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFbGVtZW50c1VwZGF0ZScpO1xuICAgICAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IHsgY29udHJvbGxlciAgfSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgICBjb25zdCByZXNldCA9ICFhbmltc0Rpc2FibGVkICYmIG5ld0NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPT09IC0xO1xuICAgICAgICAgICAgY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXQpO1xuICAgICAgICAgICAgbWluUGFkZGluZyA9IE1hdGgubWF4KCtjb250cm9sbGVyLmdldE1heE92ZXJmbG93KCksIG1pblBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpO1xuICAgICAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKT0+e1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyVXBkYXRlJywge1xuICAgICAgICAgICAgbW9kZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuICAgICAgICBjb25zdCB7IF9hY3RpdmUgLCBfbGFzdEV2ZW50ICB9ID0gdGhpcztcbiAgICAgICAgaWYgKF9sYXN0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihfbGFzdEV2ZW50LCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoX2FjdGl2ZSwgX2FjdGl2ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gX3VwZGF0ZVNjYWxlcygpIHtcbiAgICAgICAgZWFjaCh0aGlzLnNjYWxlcywgKHNjYWxlKT0+e1xuICAgICAgICAgICAgbGF5b3V0cy5yZW1vdmVCb3godGhpcywgc2NhbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgICAgIHRoaXMuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuICAgIH1cbiBfY2hlY2tFdmVudEJpbmRpbmdzKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgICAgIGNvbnN0IG5ld0V2ZW50cyA9IG5ldyBTZXQob3B0aW9ucy5ldmVudHMpO1xuICAgICAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuIF91cGRhdGVIaWRkZW5JbmRpY2VzKCkge1xuICAgICAgICBjb25zdCB7IF9oaWRkZW5JbmRpY2VzICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbWV0aG9kICwgc3RhcnQgLCBjb3VudCAgfSBvZiBjaGFuZ2VzKXtcbiAgICAgICAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XG4gICAgICAgICAgICBtb3ZlTnVtZXJpY0tleXMoX2hpZGRlbkluZGljZXMsIHN0YXJ0LCBtb3ZlKTtcbiAgICAgICAgfVxuICAgIH1cbiBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgICAgICBjb25zdCBfZGF0YUNoYW5nZXMgPSB0aGlzLl9kYXRhQ2hhbmdlcztcbiAgICAgICAgaWYgKCFfZGF0YUNoYW5nZXMgfHwgIV9kYXRhQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhc2V0Q291bnQgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBtYWtlU2V0ID0gKGlkeCk9Pm5ldyBTZXQoX2RhdGFDaGFuZ2VzLmZpbHRlcigoYyk9PmNbMF0gPT09IGlkeCkubWFwKChjLCBpKT0+aSArICcsJyArIGMuc3BsaWNlKDEpLmpvaW4oJywnKSkpO1xuICAgICAgICBjb25zdCBjaGFuZ2VTZXQgPSBtYWtlU2V0KDApO1xuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgZGF0YXNldENvdW50OyBpKyspe1xuICAgICAgICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShjaGFuZ2VTZXQpLm1hcCgoYyk9PmMuc3BsaXQoJywnKSkubWFwKChhKT0+KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGFbMV0sXG4gICAgICAgICAgICAgICAgc3RhcnQ6ICthWzJdLFxuICAgICAgICAgICAgICAgIGNvdW50OiArYVszXVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiBfdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbWluUGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICAgICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG4gICAgICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpPT57XG4gICAgICAgICAgICBpZiAobm9BcmVhICYmIGJveC5wb3NpdGlvbiA9PT0gJ2NoYXJ0QXJlYScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm94LmNvbmZpZ3VyZSkge1xuICAgICAgICAgICAgICAgIGJveC5jb25maWd1cmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KT0+e1xuICAgICAgICAgICAgaXRlbS5faWR4ID0gaW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyTGF5b3V0Jyk7XG4gICAgfVxuIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzVXBkYXRlJywge1xuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXQoaSwgaXNGdW5jdGlvbihtb2RlKSA/IG1vZGUoe1xuICAgICAgICAgICAgICAgIGRhdGFzZXRJbmRleDogaVxuICAgICAgICAgICAgfSkgOiBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNVcGRhdGUnLCB7XG4gICAgICAgICAgICBtb2RlXG4gICAgICAgIH0pO1xuICAgIH1cbiBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0VXBkYXRlJywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWV0YS5jb250cm9sbGVyLl91cGRhdGUobW9kZSk7XG4gICAgICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldFVwZGF0ZScsIGFyZ3MpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVJlbmRlcicsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdG9yLmhhcyh0aGlzKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICAgICAgb25BbmltYXRpb25zQ29tcGxldGUoe1xuICAgICAgICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggLCBoZWlnaHQgIH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEcmF3Jywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKXtcbiAgICAgICAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kcmF3RGF0YXNldHMoKTtcbiAgICAgICAgZm9yKDsgaSA8IGxheWVycy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgICB9XG4gX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fc29ydGVkTWV0YXNldHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaSwgaWxlbjtcbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcbiAgICAgICAgICAgIGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZXRhLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKHRydWUpO1xuICAgIH1cbiBfZHJhd0RhdGFzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c0RyYXcnLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgICAgIGZvcihsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNEcmF3Jyk7XG4gICAgfVxuIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgICAgICAgY29uc3QgdXNlQ2xpcCA9ICFjbGlwLmRpc2FibGVkO1xuICAgICAgICBjb25zdCBhcmVhID0gZ2V0RGF0YXNldEFyZWEobWV0YSwgdGhpcy5jaGFydEFyZWEpO1xuICAgICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0RHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICAgICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIGNsaXAubGVmdCxcbiAgICAgICAgICAgICAgICByaWdodDogY2xpcC5yaWdodCA9PT0gZmFsc2UgPyB0aGlzLndpZHRoIDogYXJlYS5yaWdodCArIGNsaXAucmlnaHQsXG4gICAgICAgICAgICAgICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcbiAgICAgICAgICAgICAgICBib3R0b206IGNsaXAuYm90dG9tID09PSBmYWxzZSA/IHRoaXMuaGVpZ2h0IDogYXJlYS5ib3R0b20gKyBjbGlwLmJvdHRvbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWV0YS5jb250cm9sbGVyLmRyYXcoKTtcbiAgICAgICAgaWYgKHVzZUNsaXApIHtcbiAgICAgICAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXREcmF3JywgYXJncyk7XG4gICAgfVxuIGlzUG9pbnRJbkFyZWEocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIF9pc1BvaW50SW5BcmVhKHBvaW50LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XG4gICAgfVxuICAgIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICBjb25zdCBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgICAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgICAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcigoeCk9PnggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XG4gICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgbWV0YSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogbnVsbCxcbiAgICAgICAgICAgICAgICBoaWRkZW46IG51bGwsXG4gICAgICAgICAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgICAgICAgICB5QXhpc0lEOiBudWxsLFxuICAgICAgICAgICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcbiAgICAgICAgICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgICAgIF9kYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICAgICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICAgICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YTtcbiAgICB9XG4gICAgZ2V0Q29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwsIHtcbiAgICAgICAgICAgIGNoYXJ0OiB0aGlzLFxuICAgICAgICAgICAgdHlwZTogJ2NoYXJ0J1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gICAgfVxuICAgIGlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICAgICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIWRhdGFzZXQuaGlkZGVuO1xuICAgIH1cbiAgICBzZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgICAgbWV0YS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICB9XG4gICAgdG9nZ2xlRGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gICAgfVxuICAgIGdldERhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gICAgfVxuIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcbiAgICAgICAgaWYgKGRlZmluZWQoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgbWV0YS5kYXRhW2RhdGFJbmRleF0uaGlkZGVuID0gIXZpc2libGU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgICAgICAgYW5pbXMudXBkYXRlKG1ldGEsIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKChjdHgpPT5jdHguZGF0YXNldEluZGV4ID09PSBkYXRhc2V0SW5kZXggPyBtb2RlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoaWRlKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgICB9XG4gICAgc2hvdyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgICAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB0cnVlKTtcbiAgICB9XG4gX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgICAgIGlmIChtZXRhICYmIG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICAgICAgbWV0YS5jb250cm9sbGVyLl9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgfVxuICAgIF9zdG9wKCkge1xuICAgICAgICBsZXQgaSwgaWxlbjtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGFuaW1hdG9yLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgICAgIGNvbnN0IHsgY2FudmFzICwgY3R4ICB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgICB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCk7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCk7XG4gICAgICAgICAgICB0aGlzLnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KGN0eCk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRlc3Ryb3knKTtcbiAgICB9XG4gICAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gICAgfVxuIGJpbmRFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiBiaW5kVXNlckV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpPT57XG4gICAgICAgICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KT0+e1xuICAgICAgICAgICAgZS5vZmZzZXRYID0geDtcbiAgICAgICAgICAgIGUub2Zmc2V0WSA9IHk7XG4gICAgICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXIoZSk7XG4gICAgICAgIH07XG4gICAgICAgIGVhY2godGhpcy5vcHRpb25zLmV2ZW50cywgKHR5cGUpPT5fYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgfVxuIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgICAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpPT57XG4gICAgICAgICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKT0+e1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKHdpZHRoLCBoZWlnaHQpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGRldGFjaGVkO1xuICAgICAgICBjb25zdCBhdHRhY2hlZCA9ICgpPT57XG4gICAgICAgICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgICAgIH07XG4gICAgICAgIGRldGFjaGVkID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIF9yZW1vdmUoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZSgwLCAwKTtcbiAgICAgICAgICAgIF9hZGQoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBsYXRmb3JtLmlzQXR0YWNoZWQodGhpcy5jYW52YXMpKSB7XG4gICAgICAgICAgICBhdHRhY2hlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWNoZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiB1bmJpbmRFdmVudHMoKSB7XG4gICAgICAgIGVhY2godGhpcy5fbGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpPT57XG4gICAgICAgICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICAgIGVhY2godGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKT0+e1xuICAgICAgICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgICAgIGxldCBtZXRhLCBpdGVtLCBpLCBpbGVuO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBpdGVtICYmIHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShpdGVtLmVsZW1lbnQsIGl0ZW0uZGF0YXNldEluZGV4LCBpdGVtLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICB9XG4gc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7IGRhdGFzZXRJbmRleCAsIGluZGV4ICB9KT0+e1xuICAgICAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiBub3RpZnlQbHVnaW5zKGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgICB9XG4gaXNQbHVnaW5FbmFibGVkKHBsdWdpbklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLl9jYWNoZS5maWx0ZXIoKHApPT5wLnBsdWdpbi5pZCA9PT0gcGx1Z2luSWQpLmxlbmd0aCA9PT0gMTtcbiAgICB9XG4gX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICAgICAgY29uc3QgZGlmZiA9IChhLCBiKT0+YS5maWx0ZXIoKHgpPT4hYi5zb21lKCh5KT0+eC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICAgICAgY29uc3QgZGVhY3RpdmF0ZWQgPSBkaWZmKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgICAgIGNvbnN0IGFjdGl2YXRlZCA9IHJlcGxheSA/IGFjdGl2ZSA6IGRpZmYoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICAgICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gX2V2ZW50SGFuZGxlcihlLCByZXBsYXkpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgcmVwbGF5LFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGluQ2hhcnRBcmVhOiB0aGlzLmlzUG9pbnRJbkFyZWEoZSlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXZlbnRGaWx0ZXIgPSAocGx1Z2luKT0+KHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcbiAgICAgICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgYXJncy5pbkNoYXJ0QXJlYSk7XG4gICAgICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcik7XG4gICAgICAgIGlmIChjaGFuZ2VkIHx8IGFyZ3MuY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICAgICAgY29uc3QgeyBfYWN0aXZlOiBsYXN0QWN0aXZlID0gW10gLCBvcHRpb25zICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBpc0NsaWNrID0gX2lzQ2xpY2tFdmVudChlKTtcbiAgICAgICAgY29uc3QgbGFzdEV2ZW50ID0gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIHRoaXMuX2xhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spO1xuICAgICAgICBpZiAoaW5DaGFydEFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICAgICAgICBjYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgIGFjdGl2ZSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sob3B0aW9ucy5vbkNsaWNrLCBbXG4gICAgICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICAgICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxufVxuZnVuY3Rpb24gaW52YWxpZGF0ZVBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpPT5jaGFydC5fcGx1Z2lucy5pbnZhbGlkYXRlKCkpO1xufVxuXG5mdW5jdGlvbiBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpIHtcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUgLCBwaXhlbE1hcmdpbiAsIHggLCB5ICwgb3V0ZXJSYWRpdXMgLCBpbm5lclJhZGl1cyAgfSA9IGVsZW1lbnQ7XG4gICAgbGV0IGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBvdXRlclJhZGl1cztcbiAgICAvLyBEcmF3IGFuIGlubmVyIGJvcmRlciBieSBjbGlwcGluZyB0aGUgYXJjIGFuZCBkcmF3aW5nIGEgZG91YmxlLXdpZHRoIGJvcmRlclxuICAgIC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XG4gICAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICAgICAgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGlubmVyUmFkaXVzO1xuICAgICAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgSEFMRl9QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIHRvUmFkaXVzQ29ybmVycyh2YWx1ZSkge1xuICAgIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgW1xuICAgICAgICAnb3V0ZXJTdGFydCcsXG4gICAgICAgICdvdXRlckVuZCcsXG4gICAgICAgICdpbm5lclN0YXJ0JyxcbiAgICAgICAgJ2lubmVyRW5kJ1xuICAgIF0pO1xufVxuLyoqXG4gKiBQYXJzZSBib3JkZXIgcmFkaXVzIGZyb20gdGhlIHByb3ZpZGVkIG9wdGlvbnNcbiAqLyBmdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyQxKGFyYywgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBhbmdsZURlbHRhKSB7XG4gICAgY29uc3QgbyA9IHRvUmFkaXVzQ29ybmVycyhhcmMub3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuICAgIGNvbnN0IGhhbGZUaGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyAyO1xuICAgIGNvbnN0IGlubmVyTGltaXQgPSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBhbmdsZURlbHRhICogaW5uZXJSYWRpdXMgLyAyKTtcbiAgICAvLyBPdXRlciBsaW1pdHMgYXJlIGNvbXBsaWNhdGVkLiBXZSB3YW50IHRvIGNvbXB1dGUgdGhlIGF2YWlsYWJsZSBhbmd1bGFyIGRpc3RhbmNlIGF0XG4gICAgLy8gYSByYWRpdXMgb2Ygb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSBmb3Igc21hbGwgYW5ndWxhciBkaXN0YW5jZXMsIHRoaXMgdGVybSBsaW1pdHMuXG4gICAgLy8gV2UgY29tcHV0ZSBhdCByID0gb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSB0aGlzIGNpcmNsZSBkZWZpbmVzIHRoZSBjZW50ZXIgb2YgdGhlIGJvcmRlciBjb3JuZXJzLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlIGJvcmRlclJhZGl1cyBpcyBsYXJnZSwgdGhhdCB2YWx1ZSBjYW4gYmVjb21lIG5lZ2F0aXZlLlxuICAgIC8vIFRoaXMgY2F1c2VzIHRoZSBvdXRlciBib3JkZXJzIHRvIGxvc2UgdGhlaXIgcmFkaXVzIGVudGlyZWx5LCB3aGljaCBpcyByYXRoZXIgdW5leHBlY3RlZC4gVG8gc29sdmUgdGhhdCwgaWYgYm9yZGVyUmFkaXVzID4gb3V0ZXJSYWRpdXNcbiAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIHRoaWNrbmVzcyB0ZXJtIHdpbGwgZG9taW5hdGUgYW5kIGNvbXB1dGUgdGhlIGxpbWl0cyBhdCB0aGF0IHBvaW50XG4gICAgY29uc3QgY29tcHV0ZU91dGVyTGltaXQgPSAodmFsKT0+e1xuICAgICAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICAgICAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbCwgMCwgTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgb3V0ZXJBcmNMaW1pdCkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcbiAgICAgICAgb3V0ZXJFbmQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJFbmQpLFxuICAgICAgICBpbm5lclN0YXJ0OiBfbGltaXRWYWx1ZShvLmlubmVyU3RhcnQsIDAsIGlubmVyTGltaXQpLFxuICAgICAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdClcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IChyLCDwnZyDKSB0byAoeCwgeSlcbiAqLyBmdW5jdGlvbiByVGhldGFUb1hZKHIsIHRoZXRhLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgIHk6IHkgKyByICogTWF0aC5zaW4odGhldGEpXG4gICAgfTtcbn1cbi8qKlxuICogUGF0aCB0aGUgYXJjLCByZXNwZWN0aW5nIGJvcmRlciByYWRpdXMgYnkgc2VwYXJhdGluZyBpbnRvIGxlZnQgYW5kIHJpZ2h0IGhhbHZlcy5cbiAqXG4gKiAgIFN0YXJ0ICAgICAgRW5kXG4gKlxuICogICAgMS0tLT5hLS0tPjIgICAgT3V0ZXJcbiAqICAgLyAgICAgICAgICAgXFxcbiAqICAgOCAgICAgICAgICAgM1xuICogICB8ICAgICAgICAgICB8XG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgNyAgICAgICAgICAgNFxuICogICBcXCAgICAgICAgICAgL1xuICogICAgNjwtLS1iPC0tLTUgICAgSW5uZXJcbiAqLyBmdW5jdGlvbiBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmQsIGNpcmN1bGFyKSB7XG4gICAgY29uc3QgeyB4ICwgeSAsIHN0YXJ0QW5nbGU6IHN0YXJ0ICwgcGl4ZWxNYXJnaW4gLCBpbm5lclJhZGl1czogaW5uZXJSICB9ID0gZWxlbWVudDtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiArIHNwYWNpbmcgKyBvZmZzZXQgKyBwaXhlbE1hcmdpbiA6IDA7XG4gICAgbGV0IHNwYWNpbmdPZmZzZXQgPSAwO1xuICAgIGNvbnN0IGFscGhhID0gZW5kIC0gc3RhcnQ7XG4gICAgaWYgKHNwYWNpbmcpIHtcbiAgICAgICAgLy8gV2hlbiBzcGFjaW5nIGlzIHByZXNlbnQsIGl0IGlzIHRoZSBzYW1lIGZvciBhbGwgaXRlbXNcbiAgICAgICAgLy8gU28gd2UgYWRqdXN0IHRoZSBzdGFydCBhbmQgZW5kIGFuZ2xlIG9mIHRoZSBhcmMgc3VjaCB0aGF0XG4gICAgICAgIC8vIHRoZSBkaXN0YW5jZSBpcyB0aGUgc2FtZSBhcyBpdCB3b3VsZCBiZSB3aXRob3V0IHRoZSBzcGFjaW5nXG4gICAgICAgIGNvbnN0IG5vU3BhY2luZ0lubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiAtIHNwYWNpbmcgOiAwO1xuICAgICAgICBjb25zdCBub1NwYWNpbmdPdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzID4gMCA/IG91dGVyUmFkaXVzIC0gc3BhY2luZyA6IDA7XG4gICAgICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkQW5nbGUgPSBhdk5vZ1NwYWNpbmdSYWRpdXMgIT09IDAgPyBhbHBoYSAqIGF2Tm9nU3BhY2luZ1JhZGl1cyAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xuICAgICAgICBzcGFjaW5nT2Zmc2V0ID0gKGFscGhhIC0gYWRqdXN0ZWRBbmdsZSkgLyAyO1xuICAgIH1cbiAgICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gc3RhcnQgKyBhbmdsZU9mZnNldCArIHNwYWNpbmdPZmZzZXQ7XG4gICAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gICAgY29uc3QgeyBvdXRlclN0YXJ0ICwgb3V0ZXJFbmQgLCBpbm5lclN0YXJ0ICwgaW5uZXJFbmQgIH0gPSBwYXJzZUJvcmRlclJhZGl1cyQxKGVsZW1lbnQsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyU3RhcnQ7XG4gICAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gICAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgICBjb25zdCBvdXRlckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIG91dGVyRW5kIC8gb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cztcbiAgICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyU3RhcnQ7XG4gICAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gICAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgaW5uZXJTdGFydCAvIGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgICBjb25zdCBpbm5lckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJFbmRBZGp1c3RlZFJhZGl1cztcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBhcmMgc2VnbWVudHMgZnJvbSBwb2ludCAxIHRvIHBvaW50IGEgdG8gcG9pbnQgMlxuICAgICAgICBjb25zdCBvdXRlck1pZEFkanVzdGVkQW5nbGUgPSAob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgKyBvdXRlckVuZEFkanVzdGVkQW5nbGUpIC8gMjtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIG91dGVyTWlkQWRqdXN0ZWRBbmdsZSk7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyTWlkQWRqdXN0ZWRBbmdsZSwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKTtcbiAgICAgICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgMiB0byBwb2ludCAzXG4gICAgICAgIGlmIChvdXRlckVuZCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgMyB0byBwb2ludCA0XG4gICAgICAgIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XG4gICAgICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDQgdG8gcG9pbnQgNVxuICAgICAgICBpZiAoaW5uZXJFbmQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBpbm5lckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJFbmQsIGVuZEFuZ2xlICsgSEFMRl9QSSwgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGlubmVyIGFyYyBmcm9tIHBvaW50IDUgdG8gcG9pbnQgYiB0byBwb2ludCA2XG4gICAgICAgIGNvbnN0IGlubmVyTWlkQWRqdXN0ZWRBbmdsZSA9IChlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJSYWRpdXMgKyAoc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cykpIC8gMjtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgLSBpbm5lckVuZCAvIGlubmVyUmFkaXVzLCBpbm5lck1pZEFkanVzdGVkQW5nbGUsIHRydWUpO1xuICAgICAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBpbm5lck1pZEFkanVzdGVkQW5nbGUsIHN0YXJ0QW5nbGUgKyBpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMsIHRydWUpO1xuICAgICAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA2IHRvIHBvaW50IDdcbiAgICAgICAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyU3RhcnQsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgNyB0byBwb2ludCA4XG4gICAgICAgIGNvbnN0IHA4ID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIHN0YXJ0QW5nbGUsIHgsIHkpO1xuICAgICAgICBjdHgubGluZVRvKHA4LngsIHA4LnkpO1xuICAgICAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA4IHRvIHBvaW50IDFcbiAgICAgICAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICBjb25zdCBvdXRlclN0YXJ0WCA9IE1hdGguY29zKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICAgICAgY29uc3Qgb3V0ZXJTdGFydFkgPSBNYXRoLnNpbihvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgICAgIGN0eC5saW5lVG8ob3V0ZXJTdGFydFgsIG91dGVyU3RhcnRZKTtcbiAgICAgICAgY29uc3Qgb3V0ZXJFbmRYID0gTWF0aC5jb3Mob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICAgICAgY29uc3Qgb3V0ZXJFbmRZID0gTWF0aC5zaW4ob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICAgICAgY3R4LmxpbmVUbyhvdXRlckVuZFgsIG91dGVyRW5kWSk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbn1cbmZ1bmN0aW9uIGRyYXdBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKSB7XG4gICAgY29uc3QgeyBmdWxsQ2lyY2xlcyAsIHN0YXJ0QW5nbGUgLCBjaXJjdW1mZXJlbmNlICB9ID0gZWxlbWVudDtcbiAgICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICAgIGlmIChmdWxsQ2lyY2xlcykge1xuICAgICAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSl7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChjaXJjdW1mZXJlbmNlICUgVEFVIHx8IFRBVSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIHJldHVybiBlbmRBbmdsZTtcbn1cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKSB7XG4gICAgY29uc3QgeyBmdWxsQ2lyY2xlcyAsIHN0YXJ0QW5nbGUgLCBjaXJjdW1mZXJlbmNlICwgb3B0aW9ucyAgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgeyBib3JkZXJXaWR0aCAsIGJvcmRlckpvaW5TdHlsZSAsIGJvcmRlckRhc2ggLCBib3JkZXJEYXNoT2Zmc2V0ICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpbm5lciA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG4gICAgaWYgKCFib3JkZXJXaWR0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zZXRMaW5lRGFzaChib3JkZXJEYXNoIHx8IFtdKTtcbiAgICBjdHgubGluZURhc2hPZmZzZXQgPSBib3JkZXJEYXNoT2Zmc2V0O1xuICAgIGlmIChpbm5lcikge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGggKiAyO1xuICAgICAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAnYmV2ZWwnO1xuICAgIH1cbiAgICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICAgIGlmIChmdWxsQ2lyY2xlcykge1xuICAgICAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSl7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGNpcmN1bWZlcmVuY2UgJSBUQVUgfHwgVEFVKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKTtcbiAgICB9XG4gICAgaWYgKCFmdWxsQ2lyY2xlcykge1xuICAgICAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufVxuY2xhc3MgQXJjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIHN0YXRpYyBpZCA9ICdhcmMnO1xuICAgIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgYm9yZGVyQWxpZ246ICdjZW50ZXInLFxuICAgICAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgICAgICBib3JkZXJEYXNoOiBbXSxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgICAgICAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgc3BhY2luZzogMCxcbiAgICAgICAgYW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2lyY3VsYXI6IHRydWVcbiAgICB9O1xuICAgIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXG4gICAgfTtcbiAgICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgICAgICBfaW5kZXhhYmxlOiAobmFtZSk9Pm5hbWUgIT09ICdib3JkZXJEYXNoJ1xuICAgIH07XG4gICAgY2lyY3VtZmVyZW5jZTtcbiAgICBlbmRBbmdsZTtcbiAgICBmdWxsQ2lyY2xlcztcbiAgICBpbm5lclJhZGl1cztcbiAgICBvdXRlclJhZGl1cztcbiAgICBwaXhlbE1hcmdpbjtcbiAgICBzdGFydEFuZ2xlO1xuICAgIGNvbnN0cnVjdG9yKGNmZyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jaXJjdW1mZXJlbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXJ0QW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgICAgICB0aGlzLmZ1bGxDaXJjbGVzID0gMDtcbiAgICAgICAgaWYgKGNmZykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluUmFuZ2UoY2hhcnRYLCBjaGFydFksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICAgICAgICd4JyxcbiAgICAgICAgICAgICd5J1xuICAgICAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgeyBhbmdsZSAsIGRpc3RhbmNlICB9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHtcbiAgICAgICAgICAgIHg6IGNoYXJ0WCxcbiAgICAgICAgICAgIHk6IGNoYXJ0WVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBzdGFydEFuZ2xlICwgZW5kQW5nbGUgLCBpbm5lclJhZGl1cyAsIG91dGVyUmFkaXVzICwgY2lyY3VtZmVyZW5jZSAgfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAgICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICBjb25zdCByQWRqdXN0ID0gKHRoaXMub3B0aW9ucy5zcGFjaW5nICsgdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoKSAvIDI7XG4gICAgICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICAgICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IF9jaXJjdW1mZXJlbmNlID49IFRBVSB8fCBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgICAgIGNvbnN0IHdpdGhpblJhZGl1cyA9IF9pc0JldHdlZW4oZGlzdGFuY2UsIGlubmVyUmFkaXVzICsgckFkanVzdCwgb3V0ZXJSYWRpdXMgKyByQWRqdXN0KTtcbiAgICAgICAgcmV0dXJuIGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzO1xuICAgIH1cbiAgICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgLCBzdGFydEFuZ2xlICwgZW5kQW5nbGUgLCBpbm5lclJhZGl1cyAsIG91dGVyUmFkaXVzICB9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAgICAgICAneCcsXG4gICAgICAgICAgICAneScsXG4gICAgICAgICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAgICAgICAnZW5kQW5nbGUnLFxuICAgICAgICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICAgICAgICdvdXRlclJhZGl1cydcbiAgICAgICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0ICwgc3BhY2luZyAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgaGFsZkFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xuICAgICAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG4gICAgICAgICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICAgIGRyYXcoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyAsIGNpcmN1bWZlcmVuY2UgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5vZmZzZXQgfHwgMCkgLyA0O1xuICAgICAgICBjb25zdCBzcGFjaW5nID0gKG9wdGlvbnMuc3BhY2luZyB8fCAwKSAvIDI7XG4gICAgICAgIGNvbnN0IGNpcmN1bGFyID0gb3B0aW9ucy5jaXJjdWxhcjtcbiAgICAgICAgdGhpcy5waXhlbE1hcmdpbiA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcicgPyAwLjMzIDogMDtcbiAgICAgICAgdGhpcy5mdWxsQ2lyY2xlcyA9IGNpcmN1bWZlcmVuY2UgPiBUQVUgPyBNYXRoLmZsb29yKGNpcmN1bWZlcmVuY2UgLyBUQVUpIDogMDtcbiAgICAgICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICsgdGhpcy5lbmRBbmdsZSkgLyAyO1xuICAgICAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiBvZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiBvZmZzZXQpO1xuICAgICAgICBjb25zdCBmaXggPSAxIC0gTWF0aC5zaW4oTWF0aC5taW4oUEksIGNpcmN1bWZlcmVuY2UgfHwgMCkpO1xuICAgICAgICBjb25zdCByYWRpdXNPZmZzZXQgPSBvZmZzZXQgKiBmaXg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICAgICAgZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuICAgICAgICBkcmF3Qm9yZGVyKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHN0eWxlID0gb3B0aW9ucykge1xuICAgIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ2FwU3R5bGUsIG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpO1xuICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LCBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpO1xuICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckpvaW5TdHlsZSwgb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpO1xuICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ29sb3IsIG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xufVxuZnVuY3Rpb24gbGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCkge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbiBmdW5jdGlvbiBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgICAgIHJldHVybiBfc3RlcHBlZExpbmVUbztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICAgICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xuICAgIH1cbiAgICByZXR1cm4gbGluZVRvO1xufVxuZnVuY3Rpb24gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCB7IHN0YXJ0OiBwYXJhbXNTdGFydCA9IDAgLCBlbmQ6IHBhcmFtc0VuZCA9IGNvdW50IC0gMSAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB7IHN0YXJ0OiBzZWdtZW50U3RhcnQgLCBlbmQ6IHNlZ21lbnRFbmQgIH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5taW4ocGFyYW1zRW5kLCBzZWdtZW50RW5kKTtcbiAgICBjb25zdCBvdXRzaWRlID0gcGFyYW1zU3RhcnQgPCBzZWdtZW50U3RhcnQgJiYgcGFyYW1zRW5kIDwgc2VnbWVudFN0YXJ0IHx8IHBhcmFtc1N0YXJ0ID4gc2VnbWVudEVuZCAmJiBwYXJhbXNFbmQgPiBzZWdtZW50RW5kO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvdW50LFxuICAgICAgICBzdGFydCxcbiAgICAgICAgbG9vcDogc2VnbWVudC5sb29wLFxuICAgICAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxuICAgIH07XG59XG4gZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgICBjb25zdCB7IHBvaW50cyAsIG9wdGlvbnMgIH0gPSBsaW5lO1xuICAgIGNvbnN0IHsgY291bnQgLCBzdGFydCAsIGxvb3AgLCBpbGVuICB9ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICAgIGNvbnN0IGxpbmVNZXRob2QgPSBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpO1xuICAgIGxldCB7IG1vdmUgPXRydWUgLCByZXZlcnNlICB9ID0gcGFyYW1zIHx8IHt9O1xuICAgIGxldCBpLCBwb2ludCwgcHJldjtcbiAgICBmb3IoaSA9IDA7IGkgPD0gaWxlbjsgKytpKXtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaSA6IGkpKSAlIGNvdW50XTtcbiAgICAgICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICBtb3ZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IHBvaW50O1xuICAgIH1cbiAgICBpZiAobG9vcCkge1xuICAgICAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gOiAwKSkgJSBjb3VudF07XG4gICAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbn1cbiBmdW5jdGlvbiBmYXN0UGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgICBjb25zdCB7IGNvdW50ICwgc3RhcnQgLCBpbGVuICB9ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICAgIGNvbnN0IHsgbW92ZSA9dHJ1ZSAsIHJldmVyc2UgIH0gPSBwYXJhbXMgfHwge307XG4gICAgbGV0IGF2Z1ggPSAwO1xuICAgIGxldCBjb3VudFggPSAwO1xuICAgIGxldCBpLCBwb2ludCwgcHJldlgsIG1pblksIG1heFksIGxhc3RZO1xuICAgIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpPT4oc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpbmRleCA6IGluZGV4KSkgJSBjb3VudDtcbiAgICBjb25zdCBkcmF3WCA9ICgpPT57XG4gICAgICAgIGlmIChtaW5ZICE9PSBtYXhZKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGF2Z1gsIG1heFkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oYXZnWCwgbGFzdFkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAobW92ZSkge1xuICAgICAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KDApXTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICB9XG4gICAgZm9yKGkgPSAwOyBpIDw9IGlsZW47ICsraSl7XG4gICAgICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuICAgICAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgICAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcbiAgICAgICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgICAgIG1pblkgPSB5O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICAgICAgICAgIG1heFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgeCkgLyArK2NvdW50WDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYXdYKCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICAgICAgICBjb3VudFggPSAwO1xuICAgICAgICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGxhc3RZID0geTtcbiAgICB9XG4gICAgZHJhd1goKTtcbn1cbiBmdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gICAgY29uc3Qgb3B0cyA9IGxpbmUub3B0aW9ucztcbiAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gICAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gICAgcmV0dXJuIHVzZUZhc3RQYXRoID8gZmFzdFBhdGhTZWdtZW50IDogcGF0aFNlZ21lbnQ7XG59XG4gZnVuY3Rpb24gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICAgICAgcmV0dXJuIF9zdGVwcGVkSW50ZXJwb2xhdGlvbjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICAgICAgcmV0dXJuIF9iZXppZXJJbnRlcnBvbGF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICAgIGxldCBwYXRoID0gbGluZS5fcGF0aDtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcGF0aCA9IGxpbmUuX3BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XG4gICAgY3R4LnN0cm9rZShwYXRoKTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7IHNlZ21lbnRzICwgb3B0aW9ucyAgfSA9IGxpbmU7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cyl7XG4gICAgICAgIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc2VnbWVudC5zdHlsZSk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgaWYgKHNlZ21lbnRNZXRob2QoY3R4LCBsaW5lLCBzZWdtZW50LCB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnQgKyBjb3VudCAtIDFcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufVxuY29uc3QgdXNlUGF0aDJEID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgICBpZiAodXNlUGF0aDJEICYmICFsaW5lLm9wdGlvbnMuc2VnbWVudCkge1xuICAgICAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgICB9XG59XG5jbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIHN0YXRpYyBpZCA9ICdsaW5lJztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG4gICAgICAgIGJvcmRlckRhc2g6IFtdLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgICAgICBib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG4gICAgICAgIGJvcmRlcldpZHRoOiAzLFxuICAgICAgICBjYXBCZXppZXJQb2ludHM6IHRydWUsXG4gICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdkZWZhdWx0JyxcbiAgICAgICAgZmlsbDogZmFsc2UsXG4gICAgICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgICAgICAgc3RlcHBlZDogZmFsc2UsXG4gICAgICAgIHRlbnNpb246IDBcbiAgICB9O1xuIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgICAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICAgIH07XG4gICAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgICAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICAgICAgX2luZGV4YWJsZTogKG5hbWUpPT5uYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnXG4gICAgfTtcbiAgICBjb25zdHJ1Y3RvcihjZmcpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZnVsbExvb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2VnbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RhdGFzZXRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNmZykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNvbnRyb2xQb2ludHMoY2hhcnRBcmVhLCBpbmRleEF4aXMpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgICAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0IHBvaW50cyhwb2ludHMpIHtcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgICAgICBkZWxldGUgdGhpcy5fc2VnbWVudHM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wYXRoO1xuICAgICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gICAgfVxuICAgIGdldCBzZWdtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzIHx8ICh0aGlzLl9zZWdtZW50cyA9IF9jb21wdXRlU2VnbWVudHModGhpcywgdGhpcy5vcHRpb25zLnNlZ21lbnQpKTtcbiAgICB9XG4gZmlyc3QoKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggJiYgcG9pbnRzW3NlZ21lbnRzWzBdLnN0YXJ0XTtcbiAgICB9XG4gbGFzdCgpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgY29uc3QgY291bnQgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBjb3VudCAmJiBwb2ludHNbc2VnbWVudHNbY291bnQgLSAxXS5lbmRdO1xuICAgIH1cbiBpbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgc3RhcnQ6IHZhbHVlLFxuICAgICAgICAgICAgZW5kOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgX2ludGVycG9sYXRlID0gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucyk7XG4gICAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgY29uc3QgeyBzdGFydCAsIGVuZCAgfSA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgICAgICAgY29uc3QgcDIgPSBwb2ludHNbZW5kXTtcbiAgICAgICAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwMSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKHZhbHVlIC0gcDFbcHJvcGVydHldKSAvIChwMltwcm9wZXJ0eV0gLSBwMVtwcm9wZXJ0eV0pKTtcbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlZCA9IF9pbnRlcnBvbGF0ZShwMSwgcDIsIHQsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2xhdGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICB9XG4gcGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgICAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gICAgfVxuIHBhdGgoY3R4LCBzdGFydCwgY291bnQpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgICAgIGxldCBsb29wID0gdGhpcy5fbG9vcDtcbiAgICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgICBjb3VudCA9IGNvdW50IHx8IHRoaXMucG9pbnRzLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpe1xuICAgICAgICAgICAgbG9vcCAmPSBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogc3RhcnQgKyBjb3VudCAtIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIWxvb3A7XG4gICAgfVxuIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cyB8fCBbXTtcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbmltYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5SYW5nZSQxKGVsLCBwb3MsIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgICBjb25zdCB7IFtheGlzXTogdmFsdWUgIH0gPSBlbC5nZXRQcm9wcyhbXG4gICAgICAgIGF4aXNcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4gTWF0aC5hYnMocG9zIC0gdmFsdWUpIDwgb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbn1cbmNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIHN0YXRpYyBpZCA9ICdwb2ludCc7XG4gICAgcGFyc2VkO1xuICAgIHNraXA7XG4gICAgc3RvcDtcbiAgICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIGhpdFJhZGl1czogMSxcbiAgICAgICAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgICAgICAgaG92ZXJSYWRpdXM6IDQsXG4gICAgICAgIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICAgICAgICByYWRpdXM6IDMsXG4gICAgICAgIHJvdGF0aW9uOiAwXG4gICAgfTtcbiAgICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgICAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICAgIH07XG4gICAgY29uc3RydWN0b3IoY2ZnKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5za2lwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChjZmcpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICAgICAgICd4JyxcbiAgICAgICAgICAgICd5J1xuICAgICAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikgPCBNYXRoLnBvdyhvcHRpb25zLmhpdFJhZGl1cyArIG9wdGlvbnMucmFkaXVzLCAyKTtcbiAgICB9XG4gICAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGluUmFuZ2UkMSh0aGlzLCBtb3VzZVksICd5JywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICAgIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgICAgICAgJ3gnLFxuICAgICAgICAgICAgJ3knXG4gICAgICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2l6ZShvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbGV0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDA7XG4gICAgICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICAgICAgcmV0dXJuIChyYWRpdXMgKyBib3JkZXJXaWR0aCkgKiAyO1xuICAgIH1cbiAgICBkcmF3KGN0eCwgYXJlYSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5za2lwIHx8IG9wdGlvbnMucmFkaXVzIDwgMC4xIHx8ICFfaXNQb2ludEluQXJlYSh0aGlzLCBhcmVhLCB0aGlzLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgZ2V0UmFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRmFsbGJhY2tzIHNob3VsZCBuZXZlciBiZSBoaXQgaW4gcHJhY3RpY2VcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgeyB4ICwgeSAsIGJhc2UgLCB3aWR0aCAsIGhlaWdodCAgfSA9ICBiYXIuZ2V0UHJvcHMoW1xuICAgICAgICAneCcsXG4gICAgICAgICd5JyxcbiAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAnd2lkdGgnLFxuICAgICAgICAnaGVpZ2h0J1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG4gICAgaWYgKGJhci5ob3Jpem9udGFsKSB7XG4gICAgICAgIGhhbGYgPSBoZWlnaHQgLyAyO1xuICAgICAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XG4gICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgYmFzZSk7XG4gICAgICAgIHRvcCA9IHkgLSBoYWxmO1xuICAgICAgICBib3R0b20gPSB5ICsgaGFsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoYWxmID0gd2lkdGggLyAyO1xuICAgICAgICBsZWZ0ID0geCAtIGhhbGY7XG4gICAgICAgIHJpZ2h0ID0geCArIGhhbGY7XG4gICAgICAgIHRvcCA9IE1hdGgubWluKHksIGJhc2UpO1xuICAgICAgICBib3R0b20gPSBNYXRoLm1heCh5LCBiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wLFxuICAgICAgICByaWdodCxcbiAgICAgICAgYm90dG9tXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNraXBPckxpbWl0KHNraXAsIHZhbHVlLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xuICAgIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICAgIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHQ6IHNraXBPckxpbWl0KHNraXAudG9wLCBvLnRvcCwgMCwgbWF4SCksXG4gICAgICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgICAgICBiOiBza2lwT3JMaW1pdChza2lwLmJvdHRvbSwgby5ib3R0b20sIDAsIG1heEgpLFxuICAgICAgICBsOiBza2lwT3JMaW1pdChza2lwLmxlZnQsIG8ubGVmdCwgMCwgbWF4VylcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCBtYXhXLCBtYXhIKSB7XG4gICAgY29uc3QgeyBlbmFibGVCb3JkZXJSYWRpdXMgIH0gPSBiYXIuZ2V0UHJvcHMoW1xuICAgICAgICAnZW5hYmxlQm9yZGVyUmFkaXVzJ1xuICAgIF0pO1xuICAgIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyUmFkaXVzO1xuICAgIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgICBjb25zdCBtYXhSID0gTWF0aC5taW4obWF4VywgbWF4SCk7XG4gICAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICAgIGNvbnN0IGVuYWJsZUJvcmRlciA9IGVuYWJsZUJvcmRlclJhZGl1cyB8fCBpc09iamVjdCh2YWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxuICAgICAgICBib3R0b21MZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAubGVmdCwgby5ib3R0b21MZWZ0LCAwLCBtYXhSKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgICB9O1xufVxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcbiAgICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcbiAgICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuICAgIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuICAgIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvdXRlcjoge1xuICAgICAgICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICAgICAgICB5OiBib3VuZHMudG9wLFxuICAgICAgICAgICAgdzogd2lkdGgsXG4gICAgICAgICAgICBoOiBoZWlnaHQsXG4gICAgICAgICAgICByYWRpdXNcbiAgICAgICAgfSxcbiAgICAgICAgaW5uZXI6IHtcbiAgICAgICAgICAgIHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG4gICAgICAgICAgICB5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG4gICAgICAgICAgICB3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG4gICAgICAgICAgICBoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iLFxuICAgICAgICAgICAgcmFkaXVzOiB7XG4gICAgICAgICAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcFJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5yKSksXG4gICAgICAgICAgICAgICAgYm90dG9tTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbUxlZnQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLmwpKSxcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHNraXBYID0geCA9PT0gbnVsbDtcbiAgICBjb25zdCBza2lwWSA9IHkgPT09IG51bGw7XG4gICAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgICBjb25zdCBib3VuZHMgPSBiYXIgJiYgIXNraXBCb3RoICYmIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiBib3VuZHMgJiYgKHNraXBYIHx8IF9pc0JldHdlZW4oeCwgYm91bmRzLmxlZnQsIGJvdW5kcy5yaWdodCkpICYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcbn1cbmZ1bmN0aW9uIGhhc1JhZGl1cyhyYWRpdXMpIHtcbiAgICByZXR1cm4gcmFkaXVzLnRvcExlZnQgfHwgcmFkaXVzLnRvcFJpZ2h0IHx8IHJhZGl1cy5ib3R0b21MZWZ0IHx8IHJhZGl1cy5ib3R0b21SaWdodDtcbn1cbiBmdW5jdGlvbiBhZGROb3JtYWxSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgICBjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xufVxuZnVuY3Rpb24gaW5mbGF0ZVJlY3QocmVjdCwgYW1vdW50LCByZWZSZWN0ID0ge30pIHtcbiAgICBjb25zdCB4ID0gcmVjdC54ICE9PSByZWZSZWN0LnggPyAtYW1vdW50IDogMDtcbiAgICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgICBjb25zdCB3ID0gKHJlY3QueCArIHJlY3QudyAhPT0gcmVmUmVjdC54ICsgcmVmUmVjdC53ID8gYW1vdW50IDogMCkgLSB4O1xuICAgIGNvbnN0IGggPSAocmVjdC55ICsgcmVjdC5oICE9PSByZWZSZWN0LnkgKyByZWZSZWN0LmggPyBhbW91bnQgOiAwKSAtIHk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcmVjdC54ICsgeCxcbiAgICAgICAgeTogcmVjdC55ICsgeSxcbiAgICAgICAgdzogcmVjdC53ICsgdyxcbiAgICAgICAgaDogcmVjdC5oICsgaCxcbiAgICAgICAgcmFkaXVzOiByZWN0LnJhZGl1c1xuICAgIH07XG59XG5jbGFzcyBCYXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgc3RhdGljIGlkID0gJ2Jhcic7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICAgICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXG4gICAgICAgIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxuICAgIH07XG4gc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gICAgfTtcbiAgICBjb25zdHJ1Y3RvcihjZmcpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5iYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbmZsYXRlQW1vdW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY2ZnKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhdyhjdHgpIHtcbiAgICAgICAgY29uc3QgeyBpbmZsYXRlQW1vdW50ICwgb3B0aW9uczogeyBib3JkZXJDb2xvciAsIGJhY2tncm91bmRDb2xvciAgfSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgaW5uZXIgLCBvdXRlciAgfSA9IGJvdW5kaW5nUmVjdHModGhpcyk7XG4gICAgICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKG91dGVyLncgIT09IGlubmVyLncgfHwgb3V0ZXIuaCAhPT0gaW5uZXIuaCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCAtaW5mbGF0ZUFtb3VudCwgb3V0ZXIpKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCBpbmZsYXRlQW1vdW50KSk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBudWxsLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gICAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICAgIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAsIGJhc2UgLCBob3Jpem9udGFsICB9ID0gIHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgICAgICAgJ3gnLFxuICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAgICAgJ2hvcml6b250YWwnXG4gICAgICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogaG9yaXpvbnRhbCA/ICh4ICsgYmFzZSkgLyAyIDogeCxcbiAgICAgICAgICAgIHk6IGhvcml6b250YWwgPyB5IDogKHkgKyBiYXNlKSAvIDJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UmFuZ2UoYXhpcykge1xuICAgICAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XG4gICAgfVxufVxuXG52YXIgZWxlbWVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5BcmNFbGVtZW50OiBBcmNFbGVtZW50LFxuQmFyRWxlbWVudDogQmFyRWxlbWVudCxcbkxpbmVFbGVtZW50OiBMaW5lRWxlbWVudCxcblBvaW50RWxlbWVudDogUG9pbnRFbGVtZW50XG59KTtcblxuY29uc3QgQk9SREVSX0NPTE9SUyA9IFtcbiAgICAncmdiKDU0LCAxNjIsIDIzNSknLFxuICAgICdyZ2IoMjU1LCA5OSwgMTMyKScsXG4gICAgJ3JnYigyNTUsIDE1OSwgNjQpJyxcbiAgICAncmdiKDI1NSwgMjA1LCA4NiknLFxuICAgICdyZ2IoNzUsIDE5MiwgMTkyKScsXG4gICAgJ3JnYigxNTMsIDEwMiwgMjU1KScsXG4gICAgJ3JnYigyMDEsIDIwMywgMjA3KScgLy8gZ3JleVxuXTtcbi8vIEJvcmRlciBjb2xvcnMgd2l0aCA1MCUgdHJhbnNwYXJlbmN5XG5jb25zdCBCQUNLR1JPVU5EX0NPTE9SUyA9IC8qICNfX1BVUkVfXyAqLyBCT1JERVJfQ09MT1JTLm1hcCgoY29sb3IpPT5jb2xvci5yZXBsYWNlKCdyZ2IoJywgJ3JnYmEoJykucmVwbGFjZSgnKScsICcsIDAuNSknKSk7XG5mdW5jdGlvbiBnZXRCb3JkZXJDb2xvcihpKSB7XG4gICAgcmV0dXJuIEJPUkRFUl9DT0xPUlNbaSAlIEJPUkRFUl9DT0xPUlMubGVuZ3RoXTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcihpKSB7XG4gICAgcmV0dXJuIEJBQ0tHUk9VTkRfQ09MT1JTW2kgJSBCQUNLR1JPVU5EX0NPTE9SUy5sZW5ndGhdO1xufVxuZnVuY3Rpb24gY29sb3JpemVEZWZhdWx0RGF0YXNldChkYXRhc2V0LCBpKSB7XG4gICAgZGF0YXNldC5ib3JkZXJDb2xvciA9IGdldEJvcmRlckNvbG9yKGkpO1xuICAgIGRhdGFzZXQuYmFja2dyb3VuZENvbG9yID0gZ2V0QmFja2dyb3VuZENvbG9yKGkpO1xuICAgIHJldHVybiArK2k7XG59XG5mdW5jdGlvbiBjb2xvcml6ZURvdWdobnV0RGF0YXNldChkYXRhc2V0LCBpKSB7XG4gICAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpPT5nZXRCb3JkZXJDb2xvcihpKyspKTtcbiAgICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0LCBpKSB7XG4gICAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpPT5nZXRCYWNrZ3JvdW5kQ29sb3IoaSsrKSk7XG4gICAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBnZXRDb2xvcml6ZXIoY2hhcnQpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpPT57XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRG91Z2hudXRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpID0gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIFBvbGFyQXJlYUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGkgPSBjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgaSA9IGNvbG9yaXplRGVmYXVsdERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhkZXNjcmlwdG9ycykge1xuICAgIGxldCBrO1xuICAgIGZvcihrIGluIGRlc2NyaXB0b3JzKXtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3JzW2tdLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3JzW2tdLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKGRlc2NyaXB0b3IpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRvciAmJiAoZGVzY3JpcHRvci5ib3JkZXJDb2xvciB8fCBkZXNjcmlwdG9yLmJhY2tncm91bmRDb2xvcik7XG59XG52YXIgcGx1Z2luX2NvbG9ycyA9IHtcbiAgICBpZDogJ2NvbG9ycycsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZm9yY2VPdmVycmlkZTogZmFsc2VcbiAgICB9LFxuICAgIGJlZm9yZUxheW91dCAoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IGRhdGFzZXRzICB9ICwgb3B0aW9uczogY2hhcnRPcHRpb25zICB9ID0gY2hhcnQuY29uZmlnO1xuICAgICAgICBjb25zdCB7IGVsZW1lbnRzICB9ID0gY2hhcnRPcHRpb25zO1xuICAgICAgICBpZiAoIW9wdGlvbnMuZm9yY2VPdmVycmlkZSAmJiAoY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhkYXRhc2V0cykgfHwgY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKGNoYXJ0T3B0aW9ucykgfHwgZWxlbWVudHMgJiYgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhlbGVtZW50cykpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sb3JpemVyID0gZ2V0Q29sb3JpemVyKGNoYXJ0KTtcbiAgICAgICAgZGF0YXNldHMuZm9yRWFjaChjb2xvcml6ZXIpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpIHtcbiBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICAgIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gICAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gICAgbGV0IHNhbXBsZWRJbmRleCA9IDA7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgICBsZXQgYSA9IHN0YXJ0O1xuICAgIGxldCBpLCBtYXhBcmVhUG9pbnQsIG1heEFyZWEsIGFyZWEsIG5leHRBO1xuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2FdO1xuICAgIGZvcihpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspe1xuICAgICAgICBsZXQgYXZnWCA9IDA7XG4gICAgICAgIGxldCBhdmdZID0gMDtcbiAgICAgICAgbGV0IGo7XG4gICAgICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgICAgIGNvbnN0IGF2Z1JhbmdlRW5kID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDIpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xuICAgICAgICBmb3IoaiA9IGF2Z1JhbmdlU3RhcnQ7IGogPCBhdmdSYW5nZUVuZDsgaisrKXtcbiAgICAgICAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgICAgIH1cbiAgICAgICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICAgICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICAgICAgY29uc3QgcmFuZ2VPZmZzID0gTWF0aC5mbG9vcihpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgICAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgICAgIGNvbnN0IHsgeDogcG9pbnRBeCAsIHk6IHBvaW50QXkgIH0gPSBkYXRhW2FdO1xuICAgICAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuICAgICAgICBmb3IoaiA9IHJhbmdlT2ZmczsgaiA8IHJhbmdlVG87IGorKyl7XG4gICAgICAgICAgICBhcmVhID0gMC41ICogTWF0aC5hYnMoKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSkpO1xuICAgICAgICAgICAgaWYgKGFyZWEgPiBtYXhBcmVhKSB7XG4gICAgICAgICAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgICAgICAgICBuZXh0QSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IG1heEFyZWFQb2ludDtcbiAgICAgICAgYSA9IG5leHRBO1xuICAgIH1cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG4gICAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cbmZ1bmN0aW9uIG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCkge1xuICAgIGxldCBhdmdYID0gMDtcbiAgICBsZXQgY291bnRYID0gMDtcbiAgICBsZXQgaSwgcG9pbnQsIHgsIHksIHByZXZYLCBtaW5JbmRleCwgbWF4SW5kZXgsIHN0YXJ0SW5kZXgsIG1pblksIG1heFk7XG4gICAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgICBjb25zdCB4TWluID0gZGF0YVtzdGFydF0ueDtcbiAgICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuICAgIGZvcihpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpe1xuICAgICAgICBwb2ludCA9IGRhdGFbaV07XG4gICAgICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcbiAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgICAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgICAgICAgICAgbWluWSA9IHk7XG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICAgICAgICAgIG1heFkgPSB5O1xuICAgICAgICAgICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHBvaW50LngpIC8gKytjb3VudFg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBpIC0gMTtcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihtaW5JbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYobWF4SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDIgPSBNYXRoLm1heChtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDEgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4Ml0sXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBhdmdYXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gMCAmJiBsYXN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjaW1hdGVkLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICAgICAgICBjb3VudFggPSAwO1xuICAgICAgICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgICAgICAgICAgbWluSW5kZXggPSBtYXhJbmRleCA9IHN0YXJ0SW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICAgIGlmIChkYXRhc2V0Ll9kZWNpbWF0ZWQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0Ll9kYXRhO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZGF0YVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpIHtcbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQpPT57XG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIHBvaW50cykge1xuICAgIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGNvdW50O1xuICAgIGNvbnN0IHsgaVNjYWxlICB9ID0gbWV0YTtcbiAgICBjb25zdCB7IG1pbiAsIG1heCAsIG1pbkRlZmluZWQgLCBtYXhEZWZpbmVkICB9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgICBzdGFydCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtaW4pLmxvLCAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGNvdW50XG4gICAgfTtcbn1cbnZhciBwbHVnaW5fZGVjaW1hdGlvbiA9IHtcbiAgICBpZDogJ2RlY2ltYXRpb24nLFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGFsZ29yaXRobTogJ21pbi1tYXgnLFxuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH0sXG4gICAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucyk9PntcbiAgICAgICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBjaGFydC53aWR0aDtcbiAgICAgICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCB7IF9kYXRhICwgaW5kZXhBeGlzICB9ID0gZGF0YXNldDtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IF9kYXRhIHx8IGRhdGFzZXQuZGF0YTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlKFtcbiAgICAgICAgICAgICAgICBpbmRleEF4aXMsXG4gICAgICAgICAgICAgICAgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNcbiAgICAgICAgICAgIF0pID09PSAneScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1ldGEuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgeyBzdGFydCAsIGNvdW50ICB9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICAgICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmKF9kYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuX2RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGE7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgICAgICAgc3dpdGNoKG9wdGlvbnMuYWxnb3JpdGhtKXtcbiAgICAgICAgICAgICAgICBjYXNlICdsdHRiJzpcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hdGVkID0gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICAgICAgICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQuX2RlY2ltYXRlZCA9IGRlY2ltYXRlZDtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBkZXN0cm95IChjaGFydCkge1xuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICAgIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKXtcbiAgICAgICAgbGV0IHsgc3RhcnQgLCBlbmQgIH0gPSBzZWdtZW50O1xuICAgICAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKTtcbiAgICAgICAgY29uc3QgYm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG4gICAgICAgIGlmICghdGFyZ2V0LnNlZ21lbnRzKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHBvaW50c1tzdGFydF0sXG4gICAgICAgICAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcbiAgICAgICAgZm9yIChjb25zdCB0Z3Qgb2YgdGFyZ2V0U2VnbWVudHMpe1xuICAgICAgICAgICAgY29uc3Qgc3ViQm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgdHBvaW50c1t0Z3Quc3RhcnRdLCB0cG9pbnRzW3RndC5lbmRdLCB0Z3QubG9vcCk7XG4gICAgICAgICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxsU291cmNlIG9mIGZpbGxTb3VyY2VzKXtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBmaWxsU291cmNlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnc3RhcnQnLCBNYXRoLm1heClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xufVxuZnVuY3Rpb24gX2dldEJvdW5kcyhwcm9wZXJ0eSwgZmlyc3QsIGxhc3QsIGxvb3ApIHtcbiAgICBpZiAobG9vcCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcbiAgICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XG4gICAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgICAgIHN0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICAgICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BlcnR5LFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpIHtcbiAgICBjb25zdCB7IHggPW51bGwgLCB5ID1udWxsICB9ID0gYm91bmRhcnkgfHwge307XG4gICAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoeyBzdGFydCAsIGVuZCAgfSk9PntcbiAgICAgICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgICAgICBjb25zdCBmaXJzdCA9IGxpbmVQb2ludHNbc3RhcnRdO1xuICAgICAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgICAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IGZpcnN0LngsXG4gICAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogbGFzdC54LFxuICAgICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHk6IGZpcnN0LnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeTogbGFzdC55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludHM7XG59XG5mdW5jdGlvbiBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gICAgZm9yKDsgZW5kID4gc3RhcnQ7IGVuZC0tKXtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbZW5kXTtcbiAgICAgICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBfZ2V0RWRnZShhLCBiLCBwcm9wLCBmbikge1xuICAgIGlmIChhICYmIGIpIHtcbiAgICAgICAgcmV0dXJuIGZuKGFbcHJvcF0sIGJbcHJvcF0pO1xuICAgIH1cbiAgICByZXR1cm4gYSA/IGFbcHJvcF0gOiBiID8gYltwcm9wXSA6IDA7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpIHtcbiAgICBsZXQgcG9pbnRzID0gW107XG4gICAgbGV0IF9sb29wID0gZmFsc2U7XG4gICAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgICAgIF9sb29wID0gdHJ1ZTtcbiAgICAgICAgcG9pbnRzID0gYm91bmRhcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRzID0gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICAgICAgcG9pbnRzLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB0ZW5zaW9uOiAwXG4gICAgICAgIH0sXG4gICAgICAgIF9sb29wLFxuICAgICAgICBfZnVsbExvb3A6IF9sb29wXG4gICAgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlICYmIHNvdXJjZS5maWxsICE9PSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgIGxldCBmaWxsID0gc291cmNlLmZpbGw7XG4gICAgY29uc3QgdmlzaXRlZCA9IFtcbiAgICAgICAgaW5kZXhcbiAgICBdO1xuICAgIGxldCB0YXJnZXQ7XG4gICAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuICAgIHdoaWxlKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpe1xuICAgICAgICBpZiAoIWlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsbDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGw7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xuICAgICAgICBmaWxsID0gdGFyZ2V0LmZpbGw7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbiBmdW5jdGlvbiBfZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgICAgY29uc3QgZmlsbCA9IHBhcnNlRmlsbE9wdGlvbihsaW5lKTtcbiAgICBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICAgIH1cbiAgICBsZXQgdGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsKTtcbiAgICBpZiAoaXNOdW1iZXJGaW5pdGUodGFyZ2V0KSAmJiBNYXRoLmZsb29yKHRhcmdldCkgPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVGFyZ2V0SW5kZXgoZmlsbFswXSwgaW5kZXgsIHRhcmdldCwgY291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICAnb3JpZ2luJyxcbiAgICAgICAgJ3N0YXJ0JyxcbiAgICAgICAgJ2VuZCcsXG4gICAgICAgICdzdGFjaycsXG4gICAgICAgICdzaGFwZSdcbiAgICBdLmluZGV4T2YoZmlsbCkgPj0gMCAmJiBmaWxsO1xufVxuZnVuY3Rpb24gZGVjb2RlVGFyZ2V0SW5kZXgoZmlyc3RDaCwgaW5kZXgsIHRhcmdldCwgY291bnQpIHtcbiAgICBpZiAoZmlyc3RDaCA9PT0gJy0nIHx8IGZpcnN0Q2ggPT09ICcrJykge1xuICAgICAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgICB9XG4gICAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuIGZ1bmN0aW9uIF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSkge1xuICAgIGxldCBwaXhlbCA9IG51bGw7XG4gICAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGl4ZWwgPSBzY2FsZS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgICAgICBwaXhlbCA9IHNjYWxlLnRvcDtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgICAgIHBpeGVsID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNjYWxlLmdldEJhc2VQaXhlbCkge1xuICAgICAgICBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIH1cbiAgICByZXR1cm4gcGl4ZWw7XG59XG4gZnVuY3Rpb24gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydFZhbHVlKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgICAgIHZhbHVlID0gc2NhbGUub3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICAgICAgdmFsdWUgPSBmaWxsLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gc2NhbGUuZ2V0QmFzZVZhbHVlKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbiBmdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XG4gICAgY29uc3QgZmlsbE9wdGlvbiA9IG9wdGlvbnMuZmlsbDtcbiAgICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuICAgIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZmlsbCA9ICEhb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICAgIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuICdvcmlnaW4nO1xuICAgIH1cbiAgICByZXR1cm4gZmlsbDtcbn1cblxuZnVuY3Rpb24gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICAgIGNvbnN0IHsgc2NhbGUgLCBpbmRleCAsIGxpbmUgIH0gPSBzb3VyY2U7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNvdXJjZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICAgIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCk7XG4gICAgbGluZXNCZWxvdy5wdXNoKF9jcmVhdGVCb3VuZGFyeUxpbmUoe1xuICAgICAgICB4OiBudWxsLFxuICAgICAgICB5OiBzY2FsZS5ib3R0b21cbiAgICB9LCBsaW5lKSk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICBmb3IobGV0IGogPSBzZWdtZW50LnN0YXJ0OyBqIDw9IHNlZ21lbnQuZW5kOyBqKyspe1xuICAgICAgICAgICAgYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludHNbal0sIGxpbmVzQmVsb3cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe1xuICAgICAgICBwb2ludHMsXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgfSk7XG59XG4gZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpIHtcbiAgICBjb25zdCBiZWxvdyA9IFtdO1xuICAgIGNvbnN0IG1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2xpbmUnKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXRhLmhpZGRlbikge1xuICAgICAgICAgICAgYmVsb3cudW5zaGlmdChtZXRhLmRhdGFzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZWxvdztcbn1cbiBmdW5jdGlvbiBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50LCBsaW5lc0JlbG93KSB7XG4gICAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gICAgZm9yKGxldCBqID0gMDsgaiA8IGxpbmVzQmVsb3cubGVuZ3RoOyBqKyspe1xuICAgICAgICBjb25zdCBsaW5lID0gbGluZXNCZWxvd1tqXTtcbiAgICAgICAgY29uc3QgeyBmaXJzdCAsIGxhc3QgLCBwb2ludCAgfSA9IGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgJ3gnKTtcbiAgICAgICAgaWYgKCFwb2ludCB8fCBmaXJzdCAmJiBsYXN0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBvaW50cy5wdXNoKC4uLnBvc3Rwb25lZCk7XG59XG4gZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHBvaW50ID0gbGluZS5pbnRlcnBvbGF0ZShzb3VyY2VQb2ludCwgcHJvcGVydHkpO1xuICAgIGlmICghcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBwb2ludFZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gICAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gICAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LmVuZF1bcHJvcGVydHldO1xuICAgICAgICBpZiAoX2lzQmV0d2Vlbihwb2ludFZhbHVlLCBmaXJzdFZhbHVlLCBsYXN0VmFsdWUpKSB7XG4gICAgICAgICAgICBmaXJzdCA9IHBvaW50VmFsdWUgPT09IGZpcnN0VmFsdWU7XG4gICAgICAgICAgICBsYXN0ID0gcG9pbnRWYWx1ZSA9PT0gbGFzdFZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlyc3QsXG4gICAgICAgIGxhc3QsXG4gICAgICAgIHBvaW50XG4gICAgfTtcbn1cblxuY2xhc3Mgc2ltcGxlQXJjIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKXtcbiAgICAgICAgdGhpcy54ID0gb3B0cy54O1xuICAgICAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgICAgIHRoaXMucmFkaXVzID0gb3B0cy5yYWRpdXM7XG4gICAgfVxuICAgIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgLCByYWRpdXMgIH0gPSB0aGlzO1xuICAgICAgICBib3VuZHMgPSBib3VuZHMgfHwge1xuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IFRBVVxuICAgICAgICB9O1xuICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuICFvcHRzLmJvdW5kcztcbiAgICB9XG4gICAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAsIHJhZGl1cyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgICAgICAgeTogeSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgICAgICAgIGFuZ2xlXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0VGFyZ2V0KHNvdXJjZSkge1xuICAgIGNvbnN0IHsgY2hhcnQgLCBmaWxsICwgbGluZSAgfSA9IHNvdXJjZTtcbiAgICBpZiAoaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICAgICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgICB9XG4gICAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcbiAgICAgICAgcmV0dXJuIF9idWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoZmlsbCA9PT0gJ3NoYXBlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcbiAgICBpZiAoYm91bmRhcnkgaW5zdGFuY2VvZiBzaW1wbGVBcmMpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kYXJ5O1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSk7XG59XG4gZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcbiAgICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBzb3VyY2Uuc2NhbGUgfHwge307XG4gICAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSkge1xuICAgIGNvbnN0IHsgc2NhbGUgPXt9ICwgZmlsbCAgfSA9IHNvdXJjZTtcbiAgICBjb25zdCBwaXhlbCA9IF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSk7XG4gICAgaWYgKGlzTnVtYmVyRmluaXRlKHBpeGVsKSkge1xuICAgICAgICBjb25zdCBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBob3Jpem9udGFsID8gcGl4ZWwgOiBudWxsLFxuICAgICAgICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiBwaXhlbFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xuICAgIGNvbnN0IHsgc2NhbGUgLCBmaWxsICB9ID0gc291cmNlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuICAgIGNvbnN0IGxlbmd0aCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgICBjb25zdCB2YWx1ZSA9IF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnQpO1xuICAgIGNvbnN0IHRhcmdldCA9IFtdO1xuICAgIGlmIChvcHRpb25zLmdyaWQuY2lyY3VsYXIpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueSxcbiAgICAgICAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpe1xuICAgICAgICB0YXJnZXQucHVzaChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RyYXdmaWxsKGN0eCwgc291cmNlLCBhcmVhKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICAgIGNvbnN0IHsgbGluZSAsIHNjYWxlICwgYXhpcyAgfSA9IHNvdXJjZTtcbiAgICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgICBjb25zdCBjb2xvciA9IGxpbmVPcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgICBjb25zdCB7IGFib3ZlID1jb2xvciAsIGJlbG93ID1jb2xvciAgfSA9IGZpbGxPcHRpb24gfHwge307XG4gICAgaWYgKHRhcmdldCAmJiBsaW5lLnBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICAgICAgZG9GaWxsKGN0eCwge1xuICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGFib3ZlLFxuICAgICAgICAgICAgYmVsb3csXG4gICAgICAgICAgICBhcmVhLFxuICAgICAgICAgICAgc2NhbGUsXG4gICAgICAgICAgICBheGlzXG4gICAgICAgIH0pO1xuICAgICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gICAgY29uc3QgeyBsaW5lICwgdGFyZ2V0ICwgYWJvdmUgLCBiZWxvdyAsIGFyZWEgLCBzY2FsZSAgfSA9IGNmZztcbiAgICBjb25zdCBwcm9wZXJ0eSA9IGxpbmUuX2xvb3AgPyAnYW5nbGUnIDogY2ZnLmF4aXM7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAocHJvcGVydHkgPT09ICd4JyAmJiBiZWxvdyAhPT0gYWJvdmUpIHtcbiAgICAgICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLnRvcCk7XG4gICAgICAgIGZpbGwoY3R4LCB7XG4gICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgY29sb3I6IGFib3ZlLFxuICAgICAgICAgICAgc2NhbGUsXG4gICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGZpbGwoY3R4LCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY29sb3I6IGJlbG93LFxuICAgICAgICBzY2FsZSxcbiAgICAgICAgcHJvcGVydHlcbiAgICB9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICAgIGNvbnN0IHsgc2VnbWVudHMgLCBwb2ludHMgIH0gPSB0YXJnZXQ7XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBsZXQgbGluZUxvb3AgPSBmYWxzZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKXtcbiAgICAgICAgY29uc3QgeyBzdGFydCAsIGVuZCAgfSA9IHNlZ21lbnQ7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lTG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwge1xuICAgICAgICAgICAgbW92ZTogbGluZUxvb3BcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhsYXN0UG9pbnQueCwgY2xpcFkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gZmlsbChjdHgsIGNmZykge1xuICAgIGNvbnN0IHsgbGluZSAsIHRhcmdldCAsIHByb3BlcnR5ICwgY29sb3IgLCBzY2FsZSAgfSA9IGNmZztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KTtcbiAgICBmb3IgKGNvbnN0IHsgc291cmNlOiBzcmMgLCB0YXJnZXQ6IHRndCAsIHN0YXJ0ICwgZW5kICB9IG9mIHNlZ21lbnRzKXtcbiAgICAgICAgY29uc3QgeyBzdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3IgPWNvbG9yICB9ID0ge30gIH0gPSBzcmM7XG4gICAgICAgIGNvbnN0IG5vdFNoYXBlID0gdGFyZ2V0ICE9PSB0cnVlO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIG5vdFNoYXBlICYmIF9nZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb25zdCBsaW5lTG9vcCA9ICEhbGluZS5wYXRoU2VnbWVudChjdHgsIHNyYyk7XG4gICAgICAgIGxldCBsb29wO1xuICAgICAgICBpZiAobm90U2hhcGUpIHtcbiAgICAgICAgICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge1xuICAgICAgICAgICAgICAgIG1vdmU6IGxpbmVMb29wLFxuICAgICAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9vcCA9IGxpbmVMb29wICYmIHRhcmdldExvb3A7XG4gICAgICAgICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbChsb29wID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGJvdW5kcykge1xuICAgIGNvbnN0IHsgdG9wICwgYm90dG9tICB9ID0gc2NhbGUuY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IHsgcHJvcGVydHkgLCBzdGFydCAsIGVuZCAgfSA9IGJvdW5kcyB8fCB7fTtcbiAgICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHN0YXJ0LCB0b3AsIGVuZCAtIHN0YXJ0LCBib3R0b20gLSB0b3ApO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgICBpZiAoaW50ZXJwb2xhdGVkUG9pbnQpIHtcbiAgICAgICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgICB9XG59XG5cbnZhciBpbmRleCA9IHtcbiAgICBpZDogJ2ZpbGxlcicsXG4gICAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZSAoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgICAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBjb3VudDsgKytpKXtcbiAgICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICAgICAgICBzb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGxpbmUgJiYgbGluZS5vcHRpb25zICYmIGxpbmUgaW5zdGFuY2VvZiBMaW5lRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IF9kZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgICAgICAgICAgIGF4aXM6IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgICAgICAgICAgICBsaW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgICAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGNvdW50OyArK2kpe1xuICAgICAgICAgICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgICAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlLmZpbGwgPSBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBvcHRpb25zLnByb3BhZ2F0ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZURyYXcgKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgICAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICAgICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICAgICAgZm9yKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpe1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2UubGluZS51cGRhdGVDb250cm9sUG9pbnRzKGFyZWEsIHNvdXJjZS5heGlzKTtcbiAgICAgICAgICAgIGlmIChkcmF3ICYmIHNvdXJjZS5maWxsKSB7XG4gICAgICAgICAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlRGF0YXNldHNEcmF3IChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0c0RyYXcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgICAgIGZvcihsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICAgICAgICBpZiAoX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEYXRhc2V0RHJhdyAoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG4gICAgICAgIGlmICghX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgfSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gICAgfVxufTtcblxuY29uc3QgZ2V0Qm94U2l6ZSA9IChsYWJlbE9wdHMsIGZvbnRTaXplKT0+e1xuICAgIGxldCB7IGJveEhlaWdodCA9Zm9udFNpemUgLCBib3hXaWR0aCA9Zm9udFNpemUgIH0gPSBsYWJlbE9wdHM7XG4gICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgIGJveEhlaWdodCA9IE1hdGgubWluKGJveEhlaWdodCwgZm9udFNpemUpO1xuICAgICAgICBib3hXaWR0aCA9IGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYm94V2lkdGgsXG4gICAgICAgIGJveEhlaWdodCxcbiAgICAgICAgaXRlbUhlaWdodDogTWF0aC5tYXgoZm9udFNpemUsIGJveEhlaWdodClcbiAgICB9O1xufTtcbmNvbnN0IGl0ZW1zRXF1YWwgPSAoYSwgYik9PmEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcbmNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuIGNvbnN0cnVjdG9yKGNvbmZpZyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgICAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGluZVdpZHRocyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbWFyZ2lucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5idWlsZExhYmVscygpO1xuICAgICAgICB0aGlzLmZpdCgpO1xuICAgIH1cbiAgICBzZXREaW1lbnNpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLl9tYXJnaW5zLmxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZExhYmVscygpIHtcbiAgICAgICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICAgICAgbGV0IGxlZ2VuZEl0ZW1zID0gY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbXG4gICAgICAgICAgICB0aGlzLmNoYXJ0XG4gICAgICAgIF0sIHRoaXMpIHx8IFtdO1xuICAgICAgICBpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuICAgICAgICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoKGl0ZW0pPT5sYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xuICAgICAgICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5zb3J0KChhLCBiKT0+bGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICAgICAgICBsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICAgIH1cbiAgICBmaXQoKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyAsIGN0eCAgfSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhYmVsT3B0cyA9IG9wdGlvbnMubGFiZWxzO1xuICAgICAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgICAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgICAgICBjb25zdCB7IGJveFdpZHRoICwgaXRlbUhlaWdodCAgfSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgICAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fZml0Q29scyh0aXRsZUhlaWdodCwgbGFiZWxGb250LCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5taW4od2lkdGgsIG9wdGlvbnMubWF4V2lkdGggfHwgdGhpcy5tYXhXaWR0aCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gICAgfVxuIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggLCBtYXhXaWR0aCAsIG9wdGlvbnM6IHsgbGFiZWxzOiB7IHBhZGRpbmcgIH0gIH0gIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbGluZVdpZHRocyA9IHRoaXMubGluZVdpZHRocyA9IFtcbiAgICAgICAgICAgIDBcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBsZXQgcm93ID0gLTE7XG4gICAgICAgIGxldCB0b3AgPSAtbGluZUhlaWdodDtcbiAgICAgICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKT0+e1xuICAgICAgICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyBmb250U2l6ZSAvIDIgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArIGl0ZW1XaWR0aCArIDIgKiBwYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgICAgICAgICB0b3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICByb3crKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhpdGJveGVzW2ldID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICB3aWR0aDogaXRlbVdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbUhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSBpdGVtV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICAgIH1cbiAgICBfZml0Q29scyh0aXRsZUhlaWdodCwgbGFiZWxGb250LCBib3hXaWR0aCwgX2l0ZW1IZWlnaHQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggLCBtYXhIZWlnaHQgLCBvcHRpb25zOiB7IGxhYmVsczogeyBwYWRkaW5nICB9ICB9ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5jb2x1bW5TaXplcyA9IFtdO1xuICAgICAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IHBhZGRpbmc7XG4gICAgICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgICAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICAgIGxldCBsZWZ0ID0gMDtcbiAgICAgICAgbGV0IGNvbCA9IDA7XG4gICAgICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgaXRlbVdpZHRoICwgaXRlbUhlaWdodCAgfSA9IGNhbGN1bGF0ZUl0ZW1TaXplKGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCwgbGVnZW5kSXRlbSwgX2l0ZW1IZWlnaHQpO1xuICAgICAgICAgICAgaWYgKGkgPiAwICYmIGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ICsgMiAqIHBhZGRpbmcgPiBoZWlnaHRMaW1pdCkge1xuICAgICAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGN1cnJlbnRDb2xXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICAgICAgICAgIGNvbCsrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGl0Ym94ZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IGN1cnJlbnRDb2xIZWlnaHQsXG4gICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpdGVtV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpdGVtSGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgfSk7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHtcbiAgICAgICAgICAgIHdpZHRoOiBjdXJyZW50Q29sV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICAgIH1cbiAgICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IHsgbGVnZW5kSGl0Qm94ZXM6IGhpdGJveGVzICwgb3B0aW9uczogeyBhbGlnbiAsIGxhYmVsczogeyBwYWRkaW5nICB9ICwgcnRsICB9ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICBsZXQgcm93ID0gMDtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcyl7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyAhPT0gaGl0Ym94LnJvdykge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBoaXRib3gucm93O1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhpdGJveC50b3AgKz0gdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IGhpdGJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29sID0gMDtcbiAgICAgICAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcyl7XG4gICAgICAgICAgICAgICAgaWYgKGhpdGJveC5jb2wgIT09IGNvbCkge1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSBoaXRib3guY29sO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhpdGJveC50b3AgPSB0b3A7XG4gICAgICAgICAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGhpdGJveC5sZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNIb3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICAgICAgY2xpcEFyZWEoY3R4LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXcoKTtcbiAgICAgICAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICAgICAgfVxuICAgIH1cbiBfZHJhdygpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zOiBvcHRzICwgY29sdW1uU2l6ZXMgLCBsaW5lV2lkdGhzICwgY3R4ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBhbGlnbiAsIGxhYmVsczogbGFiZWxPcHRzICB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgICAgIGNvbnN0IHsgcGFkZGluZyAgfSA9IGxhYmVsT3B0cztcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICAgICAgY29uc3QgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuICAgICAgICBsZXQgY3Vyc29yO1xuICAgICAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICAgICAgY29uc3QgeyBib3hXaWR0aCAsIGJveEhlaWdodCAsIGl0ZW1IZWlnaHQgIH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgICAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICAgICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuICAgICAgICAgICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogYm94SGVpZ2h0ICogTWF0aC5TUVJUMiAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIGhhbGZGb250U2l6ZTtcbiAgICAgICAgICAgICAgICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSwgbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCAmJiBib3hXaWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHlCb3hUb3AgPSB5ICsgTWF0aC5tYXgoKGZvbnRTaXplIC0gYm94SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGVnZW5kSXRlbS5ib3JkZXJSYWRpdXMpO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUoKHYpPT52ICE9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4Qm94TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHlCb3hUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHhCb3hMZWZ0LCB5Qm94VG9wLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgICAgICAgIHJlbmRlclRleHQoY3R4LCBsZWdlbmRJdGVtLnRleHQsIHgsIHkgKyBpdGVtSGVpZ2h0IC8gMiwgbGFiZWxGb250LCB7XG4gICAgICAgICAgICAgICAgc3RyaWtldGhyb3VnaDogbGVnZW5kSXRlbS5oaWRkZW4sXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxpbmU6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJzb3IgPSB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5sZWZ0ICsgcGFkZGluZyxcbiAgICAgICAgICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICBsaW5lOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpPT57XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjtcbiAgICAgICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgdGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbiB8fCAobGVnZW5kSXRlbS50ZXh0QWxpZ24gPSBsYWJlbE9wdHMudGV4dEFsaWduKSk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xuICAgICAgICAgICAgbGV0IHggPSBjdXJzb3IueDtcbiAgICAgICAgICAgIGxldCB5ID0gY3Vyc29yLnk7XG4gICAgICAgICAgICBydGxIZWxwZXIuc2V0V2lkdGgodGhpcy53aWR0aCk7XG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgICAgICAgICAgICB4ID0gY3Vyc29yLnggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICB4ID0gY3Vyc29yLnggPSB4ICsgY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLndpZHRoICsgcGFkZGluZztcbiAgICAgICAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG4gICAgICAgICAgICBkcmF3TGVnZW5kQm94KHJlYWxYLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgICAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcbiAgICAgICAgICAgIGZpbGxUZXh0KHJ0bEhlbHBlci54KHgpLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IueCArPSB3aWR0aCArIHBhZGRpbmc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsZWdlbmRJdGVtLnRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9udExpbmVIZWlnaHQgPSBsYWJlbEZvbnQubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBjdXJzb3IueSArPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSArIHBhZGRpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXN0b3JlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgICB9XG4gZHJhd1RpdGxlKCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0aXRsZU9wdHMgPSBvcHRzLnRpdGxlO1xuICAgICAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgICAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgICAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGl0bGVPcHRzLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgICBsZXQgbWF4V2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpO1xuICAgICAgICAgICAgeSA9IHRoaXMudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpPT5NYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICAgICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oX3RvTGVmdFJpZ2h0Q2VudGVyKHBvc2l0aW9uKSk7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgICAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZU9wdHMudGV4dCwgeCwgeSwgdGl0bGVGb250KTtcbiAgICB9XG4gX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICAgICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgICAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgICAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgICAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICAgIH1cbiBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICAgICAgbGV0IGksIGhpdEJveCwgbGg7XG4gICAgICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodCkgJiYgX2lzQmV0d2Vlbih5LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XG4gICAgICAgICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgaGl0Qm94ID0gbGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgaGl0Qm94LmxlZnQsIGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoKSAmJiBfaXNCZXR3ZWVuKHksIGhpdEJveC50b3AsIGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmRJdGVtc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuIGhhbmRsZUV2ZW50KGUpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgICAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG9wdHMub25MZWF2ZSwgW1xuICAgICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcbiAgICAgICAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhvcHRzLm9uSG92ZXIsIFtcbiAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICAgaG92ZXJlZEl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbSkge1xuICAgICAgICAgICAgY2FsbGJhY2sob3B0cy5vbkNsaWNrLCBbXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICBob3ZlcmVkSXRlbSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1TaXplKGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCwgbGVnZW5kSXRlbSwgX2l0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCBpdGVtV2lkdGggPSBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KTtcbiAgICBjb25zdCBpdGVtSGVpZ2h0ID0gY2FsY3VsYXRlSXRlbUhlaWdodChfaXRlbUhlaWdodCwgbGVnZW5kSXRlbSwgbGFiZWxGb250LmxpbmVIZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1XaWR0aCxcbiAgICAgICAgaXRlbUhlaWdodFxuICAgIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KSB7XG4gICAgbGV0IGxlZ2VuZEl0ZW1UZXh0ID0gbGVnZW5kSXRlbS50ZXh0O1xuICAgIGlmIChsZWdlbmRJdGVtVGV4dCAmJiB0eXBlb2YgbGVnZW5kSXRlbVRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxlZ2VuZEl0ZW1UZXh0ID0gbGVnZW5kSXRlbVRleHQucmVkdWNlKChhLCBiKT0+YS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJveFdpZHRoICsgbGFiZWxGb250LnNpemUgLyAyICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW1UZXh0KS53aWR0aDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSB7XG4gICAgbGV0IGl0ZW1IZWlnaHQgPSBfaXRlbUhlaWdodDtcbiAgICBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaXRlbUhlaWdodCA9IGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbUhlaWdodDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpIHtcbiAgICBjb25zdCBsYWJlbEhlaWdodCA9IGxlZ2VuZEl0ZW0udGV4dCA/IGxlZ2VuZEl0ZW0udGV4dC5sZW5ndGggOiAwO1xuICAgIHJldHVybiBmb250TGluZUhlaWdodCAqIGxhYmVsSGVpZ2h0O1xufVxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gICAgaWYgKCh0eXBlID09PSAnbW91c2Vtb3ZlJyB8fCB0eXBlID09PSAnbW91c2VvdXQnKSAmJiAob3B0cy5vbkhvdmVyIHx8IG9wdHMub25MZWF2ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLm9uQ2xpY2sgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ21vdXNldXAnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxudmFyIHBsdWdpbl9sZWdlbmQgPSB7XG4gICAgaWQ6ICdsZWdlbmQnLFxuIF9lbGVtZW50OiBMZWdlbmQsXG4gICAgc3RhcnQgKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtcbiAgICAgICAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGNoYXJ0XG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICAgICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIGxlZ2VuZCk7XG4gICAgfSxcbiAgICBzdG9wIChjaGFydCkge1xuICAgICAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICAgICAgZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcbiAgICB9LFxuICAgIGJlZm9yZVVwZGF0ZSAoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICAgICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgICAgIGxlZ2VuZC5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9LFxuICAgIGFmdGVyVXBkYXRlIChjaGFydCkge1xuICAgICAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgICAgIGxlZ2VuZC5idWlsZExhYmVscygpO1xuICAgICAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgICB9LFxuICAgIGFmdGVyRXZlbnQgKGNoYXJ0LCBhcmdzKSB7XG4gICAgICAgIGlmICghYXJncy5yZXBsYXkpIHtcbiAgICAgICAgICAgIGNoYXJ0LmxlZ2VuZC5oYW5kbGVFdmVudChhcmdzLmV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgICAgICByZXZlcnNlOiBmYWxzZSxcbiAgICAgICAgd2VpZ2h0OiAxMDAwLFxuICAgICAgICBvbkNsaWNrIChlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBjaSA9IGxlZ2VuZC5jaGFydDtcbiAgICAgICAgICAgIGlmIChjaS5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2kuc2hvdyhpbmRleCk7XG4gICAgICAgICAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Ib3ZlcjogbnVsbCxcbiAgICAgICAgb25MZWF2ZTogbnVsbCxcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBjb2xvcjogKGN0eCk9PmN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgICAgICAgYm94V2lkdGg6IDQwLFxuICAgICAgICAgICAgcGFkZGluZzogMTAsXG4gICAgICAgICAgICBnZW5lcmF0ZUxhYmVscyAoY2hhcnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsYWJlbHM6IHsgdXNlUG9pbnRTdHlsZSAsIHBvaW50U3R5bGUgLCB0ZXh0QWxpZ24gLCBjb2xvciAsIHVzZUJvcmRlclJhZGl1cyAsIGJvcmRlclJhZGl1cyAgfSAgfSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHVzZUJvcmRlclJhZGl1cyAmJiAoYm9yZGVyUmFkaXVzIHx8IHN0eWxlLmJvcmRlclJhZGl1cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIGNvbG9yOiAoY3R4KT0+Y3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlc2NyaXB0b3JzOiB7XG4gICAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSk9PiFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgX3NjcmlwdGFibGU6IChuYW1lKT0+IVtcbiAgICAgICAgICAgICAgICAgICAgJ2dlbmVyYXRlTGFiZWxzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbHRlcicsXG4gICAgICAgICAgICAgICAgICAgICdzb3J0J1xuICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMobmFtZSlcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNsYXNzIFRpdGxlIGV4dGVuZHMgRWxlbWVudCB7XG4gY29uc3RydWN0b3IoY29uZmlnKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IG1heFdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gbWF4SGVpZ2h0O1xuICAgICAgICBjb25zdCBsaW5lQ291bnQgPSBpc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgICAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNIb3Jpem9udGFsKCkge1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG4gICAgfVxuICAgIF9kcmF3QXJncyhvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgeyB0b3AgLCBsZWZ0ICwgYm90dG9tICwgcmlnaHQgLCBvcHRpb25zICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgICAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgICAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIHRpdGxlWSA9IHRvcCArIG9mZnNldDtcbiAgICAgICAgICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIHRpdGxlWCA9IGxlZnQgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGl0bGVYID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcbiAgICAgICAgICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpdGxlWCxcbiAgICAgICAgICAgIHRpdGxlWSxcbiAgICAgICAgICAgIG1heFdpZHRoLFxuICAgICAgICAgICAgcm90YXRpb25cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9udE9wdHMgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3A7XG4gICAgICAgIGNvbnN0IHsgdGl0bGVYICwgdGl0bGVZICwgbWF4V2lkdGggLCByb3RhdGlvbiAgfSA9IHRoaXMuX2RyYXdBcmdzKG9mZnNldCk7XG4gICAgICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICAgICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgICAgICAgIG1heFdpZHRoLFxuICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICAgICAgICB0cmFuc2xhdGlvbjogW1xuICAgICAgICAgICAgICAgIHRpdGxlWCxcbiAgICAgICAgICAgICAgICB0aXRsZVlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgICAgY3R4OiBjaGFydC5jdHgsXG4gICAgICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICAgICAgY2hhcnRcbiAgICB9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgICBjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG52YXIgcGx1Z2luX3RpdGxlID0ge1xuICAgIGlkOiAndGl0bGUnLFxuIF9lbGVtZW50OiBUaXRsZSxcbiAgICBzdGFydCAoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIHN0b3AgKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgICAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgICAgIGRlbGV0ZSBjaGFydC50aXRsZUJsb2NrO1xuICAgIH0sXG4gICAgYmVmb3JlVXBkYXRlIChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgICAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgICAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9LFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgIHdlaWdodDogJ2JvbGQnXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgICAgICBwYWRkaW5nOiAxMCxcbiAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgd2VpZ2h0OiAyMDAwXG4gICAgfSxcbiAgICBkZWZhdWx0Um91dGVzOiB7XG4gICAgICAgIGNvbG9yOiAnY29sb3InXG4gICAgfSxcbiAgICBkZXNjcmlwdG9yczoge1xuICAgICAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICAgICAgX2luZGV4YWJsZTogZmFsc2VcbiAgICB9XG59O1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHBsdWdpbl9zdWJ0aXRsZSA9IHtcbiAgICBpZDogJ3N1YnRpdGxlJyxcbiAgICBzdGFydCAoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgICAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGNoYXJ0XG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgICAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgICAgICBtYXAuc2V0KGNoYXJ0LCB0aXRsZSk7XG4gICAgfSxcbiAgICBzdG9wIChjaGFydCkge1xuICAgICAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgICAgICBtYXAuZGVsZXRlKGNoYXJ0KTtcbiAgICB9LFxuICAgIGJlZm9yZVVwZGF0ZSAoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gbWFwLmdldChjaGFydCk7XG4gICAgICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH0sXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgd2VpZ2h0OiAnbm9ybWFsJ1xuICAgICAgICB9LFxuICAgICAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgd2VpZ2h0OiAxNTAwXG4gICAgfSxcbiAgICBkZWZhdWx0Um91dGVzOiB7XG4gICAgICAgIGNvbG9yOiAnY29sb3InXG4gICAgfSxcbiAgICBkZXNjcmlwdG9yczoge1xuICAgICAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICAgICAgX2luZGV4YWJsZTogZmFsc2VcbiAgICB9XG59O1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiBhdmVyYWdlIChpdGVtcykge1xuICAgICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpLCBsZW47XG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgICAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgeCArPSBwb3MueDtcbiAgICAgICAgICAgICAgICB5ICs9IHBvcy55O1xuICAgICAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHggLyBjb3VudCxcbiAgICAgICAgICAgIHk6IHkgLyBjb3VudFxuICAgICAgICB9O1xuICAgIH0sXG4gbmVhcmVzdCAoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICAgICAgbGV0IHkgPSBldmVudFBvc2l0aW9uLnk7XG4gICAgICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG4gICAgICAgIGZvcihpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xuICAgICAgICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lYXJlc3RFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICAgICAgeCA9IHRwLng7XG4gICAgICAgICAgICB5ID0gdHAueTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICAgIGlmICh0b1B1c2gpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2UucHVzaCh0b1B1c2gpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuIGZ1bmN0aW9uIHNwbGl0TmV3bGluZXMoc3RyKSB7XG4gICAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBzdHIuc3BsaXQoJ1xcbicpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuIGZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gICAgY29uc3QgeyBlbGVtZW50ICwgZGF0YXNldEluZGV4ICwgaW5kZXggIH0gPSBpdGVtO1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgY29uc3QgeyBsYWJlbCAsIHZhbHVlICB9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFydCxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgICAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICAgICAgZm9ybWF0dGVkVmFsdWU6IHZhbHVlLFxuICAgICAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICAgICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50XG4gICAgfTtcbn1cbiBmdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XG4gICAgY29uc3QgeyBib2R5ICwgZm9vdGVyICwgdGl0bGUgIH0gPSB0b29sdGlwO1xuICAgIGNvbnN0IHsgYm94V2lkdGggLCBib3hIZWlnaHQgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICAgIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICAgIGNvbnN0IGZvb3RlckxpbmVDb3VudCA9IGZvb3Rlci5sZW5ndGg7XG4gICAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pPT5jb3VudCArIGJvZHlJdGVtLmJlZm9yZS5sZW5ndGggKyBib2R5SXRlbS5saW5lcy5sZW5ndGggKyBib2R5SXRlbS5hZnRlci5sZW5ndGgsIDApO1xuICAgIGNvbWJpbmVkQm9keUxlbmd0aCArPSB0b29sdGlwLmJlZm9yZUJvZHkubGVuZ3RoICsgdG9vbHRpcC5hZnRlckJvZHkubGVuZ3RoO1xuICAgIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgICAgICBoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnQubGluZUhlaWdodCArICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmcgKyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICAgIH1cbiAgICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGJvZHlMaW5lSGVpZ2h0ID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gTWF0aC5tYXgoYm94SGVpZ2h0LCBib2R5Rm9udC5saW5lSGVpZ2h0KSA6IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0ICsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIGJvZHlMaW5lSXRlbUNvdW50KSAqIGJvZHlGb250LmxpbmVIZWlnaHQgKyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICAgIH1cbiAgICBpZiAoZm9vdGVyTGluZUNvdW50KSB7XG4gICAgICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcCArIGZvb3RlckxpbmVDb3VudCAqIGZvb3RlckZvbnQubGluZUhlaWdodCArIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgICB9XG4gICAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gICAgY29uc3QgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICAgIH07XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICAgIGVhY2godG9vbHRpcC5iZWZvcmVCb2R5LmNvbmNhdCh0b29sdGlwLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG4gICAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gYm94V2lkdGggKyAyICsgb3B0aW9ucy5ib3hQYWRkaW5nIDogMDtcbiAgICBlYWNoKGJvZHksIChib2R5SXRlbSk9PntcbiAgICAgICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG4gICAgICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG4gICAgfSk7XG4gICAgd2lkdGhQYWRkaW5nID0gMDtcbiAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICAgIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICB9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKSB7XG4gICAgY29uc3QgeyB5ICwgaGVpZ2h0ICB9ID0gc2l6ZTtcbiAgICBpZiAoeSA8IGhlaWdodCAvIDIpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH0gZWxzZSBpZiAoeSA+IGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpIHtcbiAgICAgICAgcmV0dXJuICdib3R0b20nO1xuICAgIH1cbiAgICByZXR1cm4gJ2NlbnRlcic7XG59XG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgICBjb25zdCB7IHggLCB3aWR0aCAgfSA9IHNpemU7XG4gICAgY29uc3QgY2FyZXQgPSBvcHRpb25zLmNhcmV0U2l6ZSArIG9wdGlvbnMuY2FyZXRQYWRkaW5nO1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0JyAmJiB4ICsgd2lkdGggKyBjYXJldCA+IGNoYXJ0LndpZHRoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbikge1xuICAgIGNvbnN0IHsgeCAsIHdpZHRoICB9ID0gc2l6ZTtcbiAgICBjb25zdCB7IHdpZHRoOiBjaGFydFdpZHRoICwgY2hhcnRBcmVhOiB7IGxlZnQgLCByaWdodCAgfSAgfSA9IGNoYXJ0O1xuICAgIGxldCB4QWxpZ24gPSAnY2VudGVyJztcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSBlbHNlIGlmICh4IDw9IHdpZHRoIC8gMikge1xuICAgICAgICB4QWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh4ID49IGNoYXJ0V2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICAgICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgaWYgKGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkpIHtcbiAgICAgICAgeEFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuICAgIHJldHVybiB4QWxpZ247XG59XG4gZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gICAgY29uc3QgeUFsaWduID0gc2l6ZS55QWxpZ24gfHwgb3B0aW9ucy55QWxpZ24gfHwgZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICAgICAgeUFsaWduXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgICBsZXQgeyB4ICwgd2lkdGggIH0gPSBzaXplO1xuICAgIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeCAtPSB3aWR0aDtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeCAtPSB3aWR0aCAvIDI7XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxuZnVuY3Rpb24gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpIHtcbiAgICBsZXQgeyB5ICwgaGVpZ2h0ICB9ID0gc2l6ZTtcbiAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgICB5ICs9IHBhZGRpbmdBbmRTaXplO1xuICAgIH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICB5IC09IGhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHkgLT0gaGVpZ2h0IC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHk7XG59XG4gZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcbiAgICBjb25zdCB7IGNhcmV0U2l6ZSAsIGNhcmV0UGFkZGluZyAsIGNvcm5lclJhZGl1cyAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyB4QWxpZ24gLCB5QWxpZ24gIH0gPSBhbGlnbm1lbnQ7XG4gICAgY29uc3QgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG4gICAgY29uc3QgeyB0b3BMZWZ0ICwgdG9wUmlnaHQgLCBib3R0b21MZWZ0ICwgYm90dG9tUmlnaHQgIH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgICBjb25zdCB5ID0gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHggLT0gTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyBjYXJldFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeCArPSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpICsgY2FyZXRTaXplO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBfbGltaXRWYWx1ZSh4LCAwLCBjaGFydC53aWR0aCAtIHNpemUud2lkdGgpLFxuICAgICAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJyA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyIDogYWxpZ24gPT09ICdyaWdodCcgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodCA6IHRvb2x0aXAueCArIHBhZGRpbmcubGVmdDtcbn1cbiBmdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICAgIHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgICAgIHRvb2x0aXAsXG4gICAgICAgIHRvb2x0aXBJdGVtcyxcbiAgICAgICAgdHlwZTogJ3Rvb2x0aXAnXG4gICAgfSk7XG59XG5mdW5jdGlvbiBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpIHtcbiAgICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuY29uc3QgZGVmYXVsdENhbGxiYWNrcyA9IHtcbiAgICBiZWZvcmVUaXRsZTogbm9vcCxcbiAgICB0aXRsZSAodG9vbHRpcEl0ZW1zKSB7XG4gICAgICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICAgICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5kYXRhSW5kZXggPCBsYWJlbENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsc1tpdGVtLmRhdGFJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG4gICAgYWZ0ZXJUaXRsZTogbm9vcCxcbiAgICBiZWZvcmVCb2R5OiBub29wLFxuICAgIGJlZm9yZUxhYmVsOiBub29wLFxuICAgIGxhYmVsICh0b29sdGlwSXRlbSkge1xuICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRvb2x0aXBJdGVtLmxhYmVsICsgJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlIHx8IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYWJlbCA9IHRvb2x0aXBJdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgbGFiZWwgKz0gJzogJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgfSxcbiAgICBsYWJlbENvbG9yICh0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDBcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGxhYmVsVGV4dENvbG9yICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgfSxcbiAgICBsYWJlbFBvaW50U3R5bGUgKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvblxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWZ0ZXJMYWJlbDogbm9vcCxcbiAgICBhZnRlckJvZHk6IG5vb3AsXG4gICAgYmVmb3JlRm9vdGVyOiBub29wLFxuICAgIGZvb3Rlcjogbm9vcCxcbiAgICBhZnRlckZvb3Rlcjogbm9vcFxufTtcbiBmdW5jdGlvbiBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsIG5hbWUsIGN0eCwgYXJnKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdENhbGxiYWNrc1tuYW1lXS5jYWxsKGN0eCwgYXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcbiBzdGF0aWMgcG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gW107XG4gICAgICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgICAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmFmdGVyQm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYXJldFkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFiZWxDb2xvcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZEFuaW1hdGlvbnM7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgICAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5lbmFibGVkICYmIGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9ucztcbiAgICAgICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgICAgICBpZiAob3B0cy5fY2FjaGVhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9XG4gZ2V0Q29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVUb29sdGlwQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcywgdGhpcy5fdG9vbHRpcEl0ZW1zKSk7XG4gICAgfVxuICAgIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFja3MgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBiZWZvcmVUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2JlZm9yZVRpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAndGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2FmdGVyVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyVGl0bGUpKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2sob3B0aW9ucy5jYWxsYmFja3MsICdiZWZvcmVCb2R5JywgdGhpcywgdG9vbHRpcEl0ZW1zKSk7XG4gICAgfVxuICAgIGdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2tzICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgYm9keUl0ZW1zID0gW107XG4gICAgICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCk9PntcbiAgICAgICAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogW10sXG4gICAgICAgICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFmdGVyOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICAgICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2JlZm9yZUxhYmVsJywgdGhpcywgY29udGV4dCkpKTtcbiAgICAgICAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWwnLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICAgICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnYWZ0ZXJMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICAgICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm9keUl0ZW1zO1xuICAgIH1cbiAgICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhvcHRpb25zLmNhbGxiYWNrcywgJ2FmdGVyQm9keScsIHRoaXMsIHRvb2x0aXBJdGVtcykpO1xuICAgIH1cbiAgICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2tzICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgYmVmb3JlRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlRm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcbiAgICAgICAgY29uc3QgZm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnZm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcbiAgICAgICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlckZvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICAgICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG4gICAgICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgICAgICBjb25zdCBsYWJlbENvbG9ycyA9IFtdO1xuICAgICAgICBjb25zdCBsYWJlbFBvaW50U3R5bGVzID0gW107XG4gICAgICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgICAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgICAgIGxldCBpLCBsZW47XG4gICAgICAgIGZvcihpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcbiAgICAgICAgICAgIHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKHRoaXMuY2hhcnQsIGFjdGl2ZVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KT0+b3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaXRlbVNvcnQpIHtcbiAgICAgICAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKT0+b3B0aW9ucy5pdGVtU29ydChhLCBiLCBkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KT0+e1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgICAgICAgbGFiZWxDb2xvcnMucHVzaChpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsUG9pbnRTdHlsZScsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgICAgIGxhYmVsVGV4dENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsVGV4dENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgICAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSBsYWJlbFBvaW50U3R5bGVzO1xuICAgICAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICAgICAgdGhpcy5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgICAgICByZXR1cm4gdG9vbHRpcEl0ZW1zO1xuICAgIH1cbiAgICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICAgICAgbGV0IHByb3BlcnRpZXM7XG4gICAgICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICAgICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRvb2x0aXBJdGVtcyA9IHRoaXMuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlQm9keSA9IHRoaXMuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gdGhpcy5nZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQm9keSA9IHRoaXMuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmZvb3RlciA9IHRoaXMuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIHRoaXMuY2hhcnQpO1xuICAgICAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICAgICAgICAgIHk6IGJhY2tncm91bmRQb2ludC55LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgY2FyZXRYOiBwb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICAgICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgIGNoYXJ0OiB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVwbGF5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpO1xuICAgICAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgICAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xuICAgICAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICAgIH1cbiAgICBnZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHhBbGlnbiAsIHlBbGlnbiAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY2FyZXRTaXplICwgY29ybmVyUmFkaXVzICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyB0b3BMZWZ0ICwgdG9wUmlnaHQgLCBib3R0b21MZWZ0ICwgYm90dG9tUmlnaHQgIH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgICAgIGNvbnN0IHsgeDogcHRYICwgeTogcHRZICB9ID0gdG9vbHRpcFBvaW50O1xuICAgICAgICBjb25zdCB7IHdpZHRoICwgaGVpZ2h0ICB9ID0gc2l6ZTtcbiAgICAgICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG4gICAgICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB5MiA9IHB0WSArIGhlaWdodCAvIDI7XG4gICAgICAgICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgICAgICAgICB4MiA9IHgxIC0gY2FyZXRTaXplO1xuICAgICAgICAgICAgICAgIHkxID0geTIgKyBjYXJldFNpemU7XG4gICAgICAgICAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICB4MiA9IHgxICsgY2FyZXRTaXplO1xuICAgICAgICAgICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgICAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHgzID0geDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICB4MiA9IHB0WCArIE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgICAgICAgICAgeTIgPSB5MSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgICAgICAgICB4MSA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgICAgICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHkyID0geTEgKyBjYXJldFNpemU7XG4gICAgICAgICAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeTMgPSB5MTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB4MixcbiAgICAgICAgICAgIHgzLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB5MixcbiAgICAgICAgICAgIHkzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGl0bGUubGVuZ3RoO1xuICAgICAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICAgICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICAgICAgICAgICAgdGl0bGVTcGFjaW5nID0gb3B0aW9ucy50aXRsZVNwYWNpbmc7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsYWJlbENvbG9yID0gdGhpcy5sYWJlbENvbG9yc1tpXTtcbiAgICAgICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgICAgICBjb25zdCB7IGJveEhlaWdodCAsIGJveFdpZHRoICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgICAgIGNvbnN0IGNvbG9yWCA9IGdldEFsaWduZWRYKHRoaXMsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJ0bENvbG9yWCA9IHJ0bEhlbHBlci54KGNvbG9yWCk7XG4gICAgICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuICAgICAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICByYWRpdXM6IE1hdGgubWluKGJveFdpZHRoLCBib3hIZWlnaHQpIC8gMixcbiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBsYWJlbFBvaW50U3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogbGFiZWxQb2ludFN0eWxlLnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3IuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gaXNPYmplY3QobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGgpKSA6IGxhYmVsQ29sb3IuYm9yZGVyV2lkdGggfHwgMTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3IuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvci5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3IuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuICAgICAgICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSAyKTtcbiAgICAgICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvci5ib3JkZXJSYWRpdXMpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKCh2KT0+diAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICAgICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgICAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICAgICAgICAgICAgeTogY29sb3JZICsgMSxcbiAgICAgICAgICAgICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgICAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGlubmVyWCwgY29sb3JZICsgMSwgYm94V2lkdGggLSAyLCBib3hIZWlnaHQgLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gICAgfVxuICAgIGRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBib2R5ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBib2R5U3BhY2luZyAsIGJvZHlBbGlnbiAsIGRpc3BsYXlDb2xvcnMgLCBib3hIZWlnaHQgLCBib3hXaWR0aCAsIGJveFBhZGRpbmcgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICAgICAgbGV0IGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICAgICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG4gICAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICAgIGNvbnN0IGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHB0LnkgKz0gYm9keUxpbmVIZWlnaHQgKyBib2R5U3BhY2luZztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgICAgIGxldCBib2R5SXRlbSwgdGV4dENvbG9yLCBsaW5lcywgaSwgaiwgaWxlbiwgamxlbjtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYm9keUNvbG9yO1xuICAgICAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgICAgICB4TGluZVBhZGRpbmcgPSBkaXNwbGF5Q29sb3JzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcgOiBib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nIDogMDtcbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gYm9keS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgICAgICAgdGV4dENvbG9yID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuICAgICAgICAgICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICAgICAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICAgICAgICBpZiAoZGlzcGxheUNvbG9ycyAmJiBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2ope1xuICAgICAgICAgICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7XG4gICAgfVxuICAgIGRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICAgICAgbGV0IGZvb3RlckZvbnQsIGk7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICAgICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy5mb290ZXJBbGlnbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBwdC55ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5mb290ZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICBwdC55ICs9IGZvb3RlckZvbnQubGluZUhlaWdodCArIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHhBbGlnbiAsIHlBbGlnbiAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBwdDtcbiAgICAgICAgY29uc3QgeyB3aWR0aCAsIGhlaWdodCAgfSA9IHRvb2x0aXBTaXplO1xuICAgICAgICBjb25zdCB7IHRvcExlZnQgLCB0b3BSaWdodCAsIGJvdHRvbUxlZnQgLCBib3R0b21SaWdodCAgfSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCArIHRvcExlZnQsIHkpO1xuICAgICAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHRvcFJpZ2h0KTtcbiAgICAgICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSBib3R0b21SaWdodCk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgICAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdCk7XG4gICAgICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyB0b3BMZWZ0LCB5KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiBfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgICAgIGNvbnN0IGFuaW1YID0gYW5pbXMgJiYgYW5pbXMueDtcbiAgICAgICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgICAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICAgICAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gX3dpbGxSZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMub3BhY2l0eTtcbiAgICB9XG4gICAgZHJhdyhjdHgpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICAgICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgIGlmICghb3BhY2l0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHQgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgICAgICB5OiB0aGlzLnlcbiAgICAgICAgfTtcbiAgICAgICAgb3BhY2l0eSA9IE1hdGguYWJzKG9wYWNpdHkpIDwgMWUtMyA/IDAgOiBvcGFjaXR5O1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGhhc1Rvb2x0aXBDb250ZW50ID0gdGhpcy50aXRsZS5sZW5ndGggfHwgdGhpcy5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB0aGlzLmJvZHkubGVuZ3RoIHx8IHRoaXMuYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB0aGlzLmZvb3Rlci5sZW5ndGg7XG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgICAgICAgcHQueSArPSBwYWRkaW5nLnRvcDtcbiAgICAgICAgICAgIHRoaXMuZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgfVxuIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoeyBkYXRhc2V0SW5kZXggLCBpbmRleCAgfSk9PntcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICAgICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGV2ZW50UG9zaXRpb24pO1xuICAgICAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuIGhhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEgPSB0cnVlKSB7XG4gICAgICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKTtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IGUueVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMsIHJlcGxheSk7XG4gICAgICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgICAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGl2ZTtcbiAgICB9XG4gX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpIHtcbiAgICAgICAgY29uc3QgeyBjYXJldFggLCBjYXJldFkgLCBvcHRpb25zICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICAgIH1cbn1cbnZhciBwbHVnaW5fdG9vbHRpcCA9IHtcbiAgICBpZDogJ3Rvb2x0aXAnLFxuICAgIF9lbGVtZW50OiBUb29sdGlwLFxuICAgIHBvc2l0aW9uZXJzLFxuICAgIGFmdGVySW5pdCAoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe1xuICAgICAgICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVVcGRhdGUgKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgICAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXNldCAoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICAgICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFmdGVyRHJhdyAoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXA7XG4gICAgICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgICAgICAgICB0b29sdGlwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3Jywge1xuICAgICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9vbHRpcC5kcmF3KGNoYXJ0LmN0eCk7XG4gICAgICAgICAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclRvb2x0aXBEcmF3JywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFmdGVyRXZlbnQgKGNoYXJ0LCBhcmdzKSB7XG4gICAgICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gYXJncy5yZXBsYXk7XG4gICAgICAgICAgICBpZiAoY2hhcnQudG9vbHRpcC5oYW5kbGVFdmVudChhcmdzLmV2ZW50LCB1c2VGaW5hbFBvc2l0aW9uLCBhcmdzLmluQ2hhcnRBcmVhKSkge1xuICAgICAgICAgICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGV4dGVybmFsOiBudWxsLFxuICAgICAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgICAgICB0aXRsZUNvbG9yOiAnI2ZmZicsXG4gICAgICAgIHRpdGxlRm9udDoge1xuICAgICAgICAgICAgd2VpZ2h0OiAnYm9sZCdcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgICAgICB0aXRsZU1hcmdpbkJvdHRvbTogNixcbiAgICAgICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgICAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICAgICAgYm9keVNwYWNpbmc6IDIsXG4gICAgICAgIGJvZHlGb250OiB7fSxcbiAgICAgICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgICAgIGZvb3RlckNvbG9yOiAnI2ZmZicsXG4gICAgICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICAgICAgZm9vdGVyRm9udDoge1xuICAgICAgICAgICAgd2VpZ2h0OiAnYm9sZCdcbiAgICAgICAgfSxcbiAgICAgICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICAgICAgcGFkZGluZzogNixcbiAgICAgICAgY2FyZXRQYWRkaW5nOiAyLFxuICAgICAgICBjYXJldFNpemU6IDUsXG4gICAgICAgIGNvcm5lclJhZGl1czogNixcbiAgICAgICAgYm94SGVpZ2h0OiAoY3R4LCBvcHRzKT0+b3B0cy5ib2R5Rm9udC5zaXplLFxuICAgICAgICBib3hXaWR0aDogKGN0eCwgb3B0cyk9Pm9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICAgICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgICAgIGJveFBhZGRpbmc6IDAsXG4gICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnXG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICd4JyxcbiAgICAgICAgICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2NhcmV0WCcsXG4gICAgICAgICAgICAgICAgICAgICdjYXJldFknXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAyMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsbGJhY2tzOiBkZWZhdWx0Q2FsbGJhY2tzXG4gICAgfSxcbiAgICBkZWZhdWx0Um91dGVzOiB7XG4gICAgICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgICAgIGZvb3RlckZvbnQ6ICdmb250JyxcbiAgICAgICAgdGl0bGVGb250OiAnZm9udCdcbiAgICB9LFxuICAgIGRlc2NyaXB0b3JzOiB7XG4gICAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSk9Pm5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcbiAgICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgX2luZGV4YWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICBfZmFsbGJhY2s6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogW1xuICAgICAgICAnaW50ZXJhY3Rpb24nXG4gICAgXVxufTtcblxudmFyIHBsdWdpbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5Db2xvcnM6IHBsdWdpbl9jb2xvcnMsXG5EZWNpbWF0aW9uOiBwbHVnaW5fZGVjaW1hdGlvbixcbkZpbGxlcjogaW5kZXgsXG5MZWdlbmQ6IHBsdWdpbl9sZWdlbmQsXG5TdWJUaXRsZTogcGx1Z2luX3N1YnRpdGxlLFxuVGl0bGU6IHBsdWdpbl90aXRsZSxcblRvb2x0aXA6IHBsdWdpbl90b29sdGlwXG59KTtcblxuY29uc3QgYWRkSWZTdHJpbmcgPSAobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk9PntcbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5kZXggPSBsYWJlbHMucHVzaChyYXcpIC0gMTtcbiAgICAgICAgYWRkZWRMYWJlbHMudW5zaGlmdCh7XG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGxhYmVsOiByYXdcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc05hTihyYXcpKSB7XG4gICAgICAgIGluZGV4ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufTtcbmZ1bmN0aW9uIGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpIHtcbiAgICBjb25zdCBmaXJzdCA9IGxhYmVscy5pbmRleE9mKHJhdyk7XG4gICAgaWYgKGZpcnN0ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gYWRkSWZTdHJpbmcobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSBsYWJlbHMubGFzdEluZGV4T2YocmF3KTtcbiAgICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KT0+aW5kZXggPT09IG51bGwgPyBudWxsIDogX2xpbWl0VmFsdWUoTWF0aC5yb3VuZChpbmRleCksIDAsIG1heCk7XG5mdW5jdGlvbiBfZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPCBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBsYWJlbHNbdmFsdWVdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jbGFzcyBDYXRlZ29yeVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICAgIHN0YXRpYyBpZCA9ICdjYXRlZ29yeSc7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgY2FsbGJhY2s6IF9nZXRMYWJlbEZvclZhbHVlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0cnVjdG9yKGNmZyl7XG4gICAgICAgIHN1cGVyKGNmZyk7XG4gICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICB9XG4gICAgaW5pdChzY2FsZU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICAgICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBpbmRleCAsIGxhYmVsICB9IG9mIGFkZGVkKXtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxzW2luZGV4XSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5pbml0KHNjYWxlT3B0aW9ucyk7XG4gICAgfVxuICAgIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXggOiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgdmFsdWVPckRlZmF1bHQoaW5kZXgsIHJhdyksIHRoaXMuX2FkZGVkTGFiZWxzKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkSW5kZXgoaW5kZXgsIGxhYmVscy5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICAgICAgY29uc3QgeyBtaW5EZWZpbmVkICwgbWF4RGVmaW5lZCAgfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgICAgICBsZXQgeyBtaW4gLCBtYXggIH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgICAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXggPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW4gPSBtaW47XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgIH1cbiAgICBidWlsZFRpY2tzKCkge1xuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgICAgIGxldCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgICBsYWJlbHMgPSBtaW4gPT09IDAgJiYgbWF4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xuICAgICAgICB0aGlzLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgobGFiZWxzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xuICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5taW4gLSAob2Zmc2V0ID8gMC41IDogMCk7XG4gICAgICAgIGZvcihsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKyl7XG4gICAgICAgICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH1cbiAgICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfZ2V0TGFiZWxGb3JWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gY29uZmlndXJlKCkge1xuICAgICAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gIXRoaXMuX3JldmVyc2VQaXhlbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICAgIH1cbiAgICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICAgICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICAgIH1cbiAgICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgICB9XG4gICAgZ2V0QmFzZVBpeGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzJDEoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgY29uc3QgTUlOX1NQQUNJTkcgPSAxZS0xNDtcbiAgICBjb25zdCB7IGJvdW5kcyAsIHN0ZXAgLCBtaW4gLCBtYXggLCBwcmVjaXNpb24gLCBjb3VudCAsIG1heFRpY2tzICwgbWF4RGlnaXRzICwgaW5jbHVkZUJvdW5kcyAgfSA9IGdlbmVyYXRpb25PcHRpb25zO1xuICAgIGNvbnN0IHVuaXQgPSBzdGVwIHx8IDE7XG4gICAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICAgIGNvbnN0IHsgbWluOiBybWluICwgbWF4OiBybWF4ICB9ID0gZGF0YVJhbmdlO1xuICAgIGNvbnN0IG1pbkRlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtaW4pO1xuICAgIGNvbnN0IG1heERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtYXgpO1xuICAgIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgICBjb25zdCBtaW5TcGFjaW5nID0gKHJtYXggLSBybWluKSAvIChtYXhEaWdpdHMgKyAxKTtcbiAgICBsZXQgc3BhY2luZyA9IG5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG4gICAgaWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiAhbWluRGVmaW5lZCAmJiAhbWF4RGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBybWluXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBybWF4XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxuICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgICBpZiAobnVtU3BhY2VzID4gbWF4U3BhY2VzKSB7XG4gICAgICAgIHNwYWNpbmcgPSBuaWNlTnVtKG51bVNwYWNlcyAqIHNwYWNpbmcgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gICAgfVxuICAgIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgIH1cbiAgICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICAgIG5pY2VNaW4gPSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gICAgICAgIG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgICBuaWNlTWluID0gcm1pbjtcbiAgICAgICAgbmljZU1heCA9IHJtYXg7XG4gICAgfVxuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQgJiYgc3RlcCAmJiBhbG1vc3RXaG9sZSgobWF4IC0gbWluKSAvIHN0ZXAsIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKE1hdGgubWluKChtYXggLSBtaW4pIC8gc3BhY2luZywgbWF4VGlja3MpKTtcbiAgICAgICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgICAgICBuaWNlTWluID0gbWluO1xuICAgICAgICBuaWNlTWF4ID0gbWF4O1xuICAgIH0gZWxzZSBpZiAoY291bnREZWZpbmVkKSB7XG4gICAgICAgIG5pY2VNaW4gPSBtaW5EZWZpbmVkID8gbWluIDogbmljZU1pbjtcbiAgICAgICAgbmljZU1heCA9IG1heERlZmluZWQgPyBtYXggOiBuaWNlTWF4O1xuICAgICAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gbnVtU3BhY2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuICAgICAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgICAgICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChfZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSwgX2RlY2ltYWxQbGFjZXMobmljZU1pbikpO1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBsZXQgaiA9IDA7XG4gICAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVCb3VuZHMgJiYgbmljZU1pbiAhPT0gbWluKSB7XG4gICAgICAgICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWluXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbW9zdEVxdWFscyhNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvciwgbWluLCByZWxhdGl2ZUxhYmVsU2l6ZShtaW4sIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcig7IGogPCBudW1TcGFjZXM7ICsrail7XG4gICAgICAgIGNvbnN0IHRpY2tWYWx1ZSA9IE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICAgICAgICBpZiAobWF4RGVmaW5lZCAmJiB0aWNrVmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRpY2tzLnB1c2goe1xuICAgICAgICAgICAgdmFsdWU6IHRpY2tWYWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICAgICAgaWYgKHRpY2tzLmxlbmd0aCAmJiBhbG1vc3RFcXVhbHModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUsIG1heCwgcmVsYXRpdmVMYWJlbFNpemUobWF4LCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgICAgICB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSA9IG1heDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghbWF4RGVmaW5lZCB8fCBuaWNlTWF4ID09PSBtYXgpIHtcbiAgICAgICAgdGlja3MucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZTogbmljZU1heFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gcmVsYXRpdmVMYWJlbFNpemUodmFsdWUsIG1pblNwYWNpbmcsIHsgaG9yaXpvbnRhbCAsIG1pblJvdGF0aW9uICB9KSB7XG4gICAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4ocmFkKSA6IE1hdGguY29zKHJhZCkpIHx8IDAuMDAxO1xuICAgIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xufVxuY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuICAgIGNvbnN0cnVjdG9yKGNmZyl7XG4gICAgICAgIHN1cGVyKGNmZyk7XG4gICAgICAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICAgIH1cbiAgICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodHlwZW9mIHJhdyA9PT0gJ251bWJlcicgfHwgcmF3IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3JhdykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiArcmF3O1xuICAgIH1cbiAgICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgICAgICBjb25zdCB7IGJlZ2luQXRaZXJvICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB7IG1pbkRlZmluZWQgLCBtYXhEZWZpbmVkICB9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgICAgIGxldCB7IG1pbiAsIG1heCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNldE1pbiA9ICh2KT0+bWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHY7XG4gICAgICAgIGNvbnN0IHNldE1heCA9ICh2KT0+bWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHY7XG4gICAgICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG4gICAgICAgICAgICBpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcbiAgICAgICAgICAgICAgICBzZXRNYXgoMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgICAgICAgICAgc2V0TWluKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IG1heCA9PT0gMCA/IDEgOiBNYXRoLmFicyhtYXggKiAwLjA1KTtcbiAgICAgICAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFiZWdpbkF0WmVybykge1xuICAgICAgICAgICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWluID0gbWluO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICB9XG4gICAgZ2V0VGlja0xpbWl0KCkge1xuICAgICAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICAgICAgbGV0IHsgbWF4VGlja3NMaW1pdCAsIHN0ZXBTaXplICB9ID0gdGlja09wdHM7XG4gICAgICAgIGxldCBtYXhUaWNrcztcbiAgICAgICAgaWYgKHN0ZXBTaXplKSB7XG4gICAgICAgICAgICBtYXhUaWNrcyA9IE1hdGguY2VpbCh0aGlzLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IodGhpcy5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuICAgICAgICAgICAgaWYgKG1heFRpY2tzID4gMTAwMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICAgICAgICAgIG1heFRpY2tzID0gMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICAgICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heFRpY2tzO1xuICAgIH1cbiBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIH1cbiAgICBidWlsZFRpY2tzKCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgICAgIGxldCBtYXhUaWNrcyA9IHRoaXMuZ2V0VGlja0xpbWl0KCk7XG4gICAgICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuICAgICAgICBjb25zdCBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1heFRpY2tzLFxuICAgICAgICAgICAgYm91bmRzOiBvcHRzLmJvdW5kcyxcbiAgICAgICAgICAgIG1pbjogb3B0cy5taW4sXG4gICAgICAgICAgICBtYXg6IG9wdHMubWF4LFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG4gICAgICAgICAgICBzdGVwOiB0aWNrT3B0cy5zdGVwU2l6ZSxcbiAgICAgICAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcbiAgICAgICAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICAgICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgICAgICAgbWluUm90YXRpb246IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDAsXG4gICAgICAgICAgICBpbmNsdWRlQm91bmRzOiB0aWNrT3B0cy5pbmNsdWRlQm91bmRzICE9PSBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkYXRhUmFuZ2UgPSB0aGlzLl9yYW5nZSB8fCB0aGlzO1xuICAgICAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MkMShudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgZGF0YVJhbmdlKTtcbiAgICAgICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICAgICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrcztcbiAgICB9XG4gY29uZmlndXJlKCkge1xuICAgICAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5tYXg7XG4gICAgICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICAgICAgICBzdGFydCAtPSBvZmZzZXQ7XG4gICAgICAgICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBzdGFydDtcbiAgICAgICAgdGhpcy5fZW5kVmFsdWUgPSBlbmQ7XG4gICAgICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgICB9XG4gICAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgICB9XG59XG5cbmNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgICBzdGF0aWMgaWQgPSAnbGluZWFyJztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgICAgIGNvbnN0IHsgbWluICwgbWF4ICB9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IG1heCA6IDE7XG4gICAgICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICAgIH1cbiBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgICAgICBjb25zdCBob3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICAgICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKG1pblJvdGF0aW9uKSA6IE1hdGguY29zKG1pblJvdGF0aW9uKSkgfHwgMC4wMDE7XG4gICAgICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGggLyBNYXRoLm1pbig0MCwgdGlja0ZvbnQubGluZUhlaWdodCAvIHJhdGlvKSk7XG4gICAgfVxuICAgIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgICB9XG4gICAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gICAgfVxufVxuXG5jb25zdCBsb2cxMEZsb29yID0gKHYpPT5NYXRoLmZsb29yKGxvZzEwKHYpKTtcbmNvbnN0IGNoYW5nZUV4cG9uZW50ID0gKHYsIG0pPT5NYXRoLnBvdygxMCwgbG9nMTBGbG9vcih2KSArIG0pO1xuZnVuY3Rpb24gaXNNYWpvcih0aWNrVmFsKSB7XG4gICAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIE1hdGgucG93KDEwLCBsb2cxMEZsb29yKHRpY2tWYWwpKTtcbiAgICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuZnVuY3Rpb24gc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSB7XG4gICAgY29uc3QgcmFuZ2VTdGVwID0gTWF0aC5wb3coMTAsIHJhbmdlRXhwKTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IobWluIC8gcmFuZ2VTdGVwKTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLmNlaWwobWF4IC8gcmFuZ2VTdGVwKTtcbiAgICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59XG5mdW5jdGlvbiBzdGFydEV4cChtaW4sIG1heCkge1xuICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICAgIGxldCByYW5nZUV4cCA9IGxvZzEwRmxvb3IocmFuZ2UpO1xuICAgIHdoaWxlKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPiAxMCl7XG4gICAgICAgIHJhbmdlRXhwKys7XG4gICAgfVxuICAgIHdoaWxlKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPCAxMCl7XG4gICAgICAgIHJhbmdlRXhwLS07XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihyYW5nZUV4cCwgbG9nMTBGbG9vcihtaW4pKTtcbn1cbiBmdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB7IG1pbiAsIG1heCAgfSkge1xuICAgIG1pbiA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIG1pbik7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBjb25zdCBtaW5FeHAgPSBsb2cxMEZsb29yKG1pbik7XG4gICAgbGV0IGV4cCA9IHN0YXJ0RXhwKG1pbiwgbWF4KTtcbiAgICBsZXQgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG4gICAgY29uc3Qgc3RlcFNpemUgPSBNYXRoLnBvdygxMCwgZXhwKTtcbiAgICBjb25zdCBiYXNlID0gbWluRXhwID4gZXhwID8gTWF0aC5wb3coMTAsIG1pbkV4cCkgOiAwO1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5yb3VuZCgobWluIC0gYmFzZSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgIGNvbnN0IG9mZnNldCA9IE1hdGguZmxvb3IoKG1pbiAtIGJhc2UpIC8gc3RlcFNpemUgLyAxMCkgKiBzdGVwU2l6ZSAqIDEwO1xuICAgIGxldCBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IoKHN0YXJ0IC0gb2Zmc2V0KSAvIE1hdGgucG93KDEwLCBleHApKTtcbiAgICBsZXQgdmFsdWUgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnJvdW5kKChiYXNlICsgb2Zmc2V0ICsgc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uKTtcbiAgICB3aGlsZSh2YWx1ZSA8IG1heCl7XG4gICAgICAgIHRpY2tzLnB1c2goe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBtYWpvcjogaXNNYWpvcih2YWx1ZSksXG4gICAgICAgICAgICBzaWduaWZpY2FuZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNpZ25pZmljYW5kID49IDEwKSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZCA9IHNpZ25pZmljYW5kIDwgMTUgPyAxNSA6IDIwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmlmaWNhbmQgPj0gMjApIHtcbiAgICAgICAgICAgIGV4cCsrO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmQgPSAyO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgICB9XG4gICAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB2YWx1ZSk7XG4gICAgdGlja3MucHVzaCh7XG4gICAgICAgIHZhbHVlOiBsYXN0VGljayxcbiAgICAgICAgbWFqb3I6IGlzTWFqb3IobGFzdFRpY2spLFxuICAgICAgICBzaWduaWZpY2FuZFxuICAgIH0pO1xuICAgIHJldHVybiB0aWNrcztcbn1cbmNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gICAgc3RhdGljIGlkID0gJ2xvZ2FyaXRobWljJztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICAgICAgICAgIG1ham9yOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdHJ1Y3RvcihjZmcpe1xuICAgICAgICBzdXBlcihjZmcpO1xuICAgICAgICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgfVxuICAgIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgIF0pO1xuICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpICYmIHZhbHVlID4gMCA/IHZhbHVlIDogbnVsbDtcbiAgICB9XG4gICAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICAgICAgY29uc3QgeyBtaW4gLCBtYXggIH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICAgICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XG4gICAgICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IE1hdGgubWF4KDAsIG1heCkgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJlZ2luQXRaZXJvKSB7XG4gICAgICAgICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5femVybyAmJiB0aGlzLm1pbiAhPT0gdGhpcy5fc3VnZ2VzdGVkTWluICYmICFpc051bWJlckZpbml0ZSh0aGlzLl91c2VyTWluKSkge1xuICAgICAgICAgICAgdGhpcy5taW4gPSBtaW4gPT09IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAwKSA/IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAtMSkgOiBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gICAgfVxuICAgIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgbWluRGVmaW5lZCAsIG1heERlZmluZWQgIH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICAgICAgbGV0IG1pbiA9IHRoaXMubWluO1xuICAgICAgICBsZXQgbWF4ID0gdGhpcy5tYXg7XG4gICAgICAgIGNvbnN0IHNldE1pbiA9ICh2KT0+bWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHY7XG4gICAgICAgIGNvbnN0IHNldE1heCA9ICh2KT0+bWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHY7XG4gICAgICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgc2V0TWluKDEpO1xuICAgICAgICAgICAgICAgIHNldE1heCgxMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldE1pbihjaGFuZ2VFeHBvbmVudChtaW4sIC0xKSk7XG4gICAgICAgICAgICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1heCwgKzEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgICAgIHNldE1pbihjaGFuZ2VFeHBvbmVudChtYXgsIC0xKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCA8PSAwKSB7XG4gICAgICAgICAgICBzZXRNYXgoY2hhbmdlRXhwb25lbnQobWluLCArMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWluID0gbWluO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICB9XG4gICAgYnVpbGRUaWNrcygpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtaW46IHRoaXMuX3VzZXJNaW4sXG4gICAgICAgICAgICBtYXg6IHRoaXMuX3VzZXJNYXhcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB0aGlzKTtcbiAgICAgICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICAgICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrcztcbiAgICB9XG4gZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/ICcwJyA6IGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gICAgfVxuIGNvbmZpZ3VyZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBsb2cxMCh0aGlzLm1heCkgLSBsb2cxMChzdGFydCk7XG4gICAgfVxuICAgIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5taW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwodmFsdWUgPT09IHRoaXMubWluID8gMCA6IChsb2cxMCh2YWx1ZSkgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICAgIH1cbiAgICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250ICYmIHRpY2tPcHRzLmZvbnQuc2l6ZSwgZGVmYXVsdHMuZm9udC5zaXplKSArIHBhZGRpbmcuaGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICAgIGxhYmVsID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbCA6IFtcbiAgICAgICAgbGFiZWxcbiAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgICAgIGg6IGxhYmVsLmxlbmd0aCAqIGZvbnQubGluZUhlaWdodFxuICAgIH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcbiAgICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogcG9zIC0gc2l6ZSAvIDIsXG4gICAgICAgICAgICBlbmQ6IHBvcyArIHNpemUgLyAyXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHBvcyAtIHNpemUsXG4gICAgICAgICAgICBlbmQ6IHBvc1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogcG9zLFxuICAgICAgICBlbmQ6IHBvcyArIHNpemVcbiAgICB9O1xufVxuIGZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuICAgIGNvbnN0IG9yaWcgPSB7XG4gICAgICAgIGw6IHNjYWxlLmxlZnQgKyBzY2FsZS5fcGFkZGluZy5sZWZ0LFxuICAgICAgICByOiBzY2FsZS5yaWdodCAtIHNjYWxlLl9wYWRkaW5nLnJpZ2h0LFxuICAgICAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgICAgIGI6IHNjYWxlLmJvdHRvbSAtIHNjYWxlLl9wYWRkaW5nLmJvdHRvbVxuICAgIH07XG4gICAgY29uc3QgbGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZyk7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IFtdO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgICBjb25zdCBwb2ludExhYmVsT3B0cyA9IHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHM7XG4gICAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspe1xuICAgICAgICBjb25zdCBvcHRzID0gcG9pbnRMYWJlbE9wdHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICAgICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICAgICAgbGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBfbm9ybWFsaXplQW5nbGUoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSArIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSk7XG4gICAgICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcbiAgICAgICAgY29uc3QgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcbiAgICAgICAgdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGVSYWRpYW5zLCBoTGltaXRzLCB2TGltaXRzKTtcbiAgICB9XG4gICAgc2NhbGUuc2V0Q2VudGVyUG9pbnQob3JpZy5sIC0gbGltaXRzLmwsIGxpbWl0cy5yIC0gb3JpZy5yLCBvcmlnLnQgLSBsaW1pdHMudCwgbGltaXRzLmIgLSBvcmlnLmIpO1xuICAgIHNjYWxlLl9wb2ludExhYmVsSXRlbXMgPSBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZyk7XG59XG5mdW5jdGlvbiB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZSwgaExpbWl0cywgdkxpbWl0cykge1xuICAgIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSk7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgICAgIHggPSAob3JpZy5sIC0gaExpbWl0cy5zdGFydCkgLyBzaW47XG4gICAgICAgIGxpbWl0cy5sID0gTWF0aC5taW4obGltaXRzLmwsIG9yaWcubCAtIHgpO1xuICAgIH0gZWxzZSBpZiAoaExpbWl0cy5lbmQgPiBvcmlnLnIpIHtcbiAgICAgICAgeCA9IChoTGltaXRzLmVuZCAtIG9yaWcucikgLyBzaW47XG4gICAgICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICAgIH1cbiAgICBpZiAodkxpbWl0cy5zdGFydCA8IG9yaWcudCkge1xuICAgICAgICB5ID0gKG9yaWcudCAtIHZMaW1pdHMuc3RhcnQpIC8gY29zO1xuICAgICAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgICB9IGVsc2UgaWYgKHZMaW1pdHMuZW5kID4gb3JpZy5iKSB7XG4gICAgICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgICAgICBsaW1pdHMuYiA9IE1hdGgubWF4KGxpbWl0cy5iLCBvcmlnLmIgKyB5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsSXRlbShzY2FsZSwgaW5kZXgsIGl0ZW1PcHRzKSB7XG4gICAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICAgIGNvbnN0IHsgZXh0cmEgLCBhZGRpdGlvbmFsQW5nbGUgLCBwYWRkaW5nICwgc2l6ZSAgfSA9IGl0ZW1PcHRzO1xuICAgIGNvbnN0IHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIHBhZGRpbmcsIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG4gICAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICB4OiBwb2ludExhYmVsUG9zaXRpb24ueCxcbiAgICAgICAgeSxcbiAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHJpZ2h0OiBsZWZ0ICsgc2l6ZS53LFxuICAgICAgICBib3R0b206IHkgKyBzaXplLmhcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNOb3RPdmVybGFwcGVkKGl0ZW0sIGFyZWEpIHtcbiAgICBpZiAoIWFyZWEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHsgbGVmdCAsIHRvcCAsIHJpZ2h0ICwgYm90dG9tICB9ID0gaXRlbTtcbiAgICBjb25zdCBhcGV4ZXNJbkFyZWEgPSBfaXNQb2ludEluQXJlYSh7XG4gICAgICAgIHg6IGxlZnQsXG4gICAgICAgIHk6IHRvcFxuICAgIH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHtcbiAgICAgICAgeDogbGVmdCxcbiAgICAgICAgeTogYm90dG9tXG4gICAgfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe1xuICAgICAgICB4OiByaWdodCxcbiAgICAgICAgeTogdG9wXG4gICAgfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe1xuICAgICAgICB4OiByaWdodCxcbiAgICAgICAgeTogYm90dG9tXG4gICAgfSwgYXJlYSk7XG4gICAgcmV0dXJuICFhcGV4ZXNJbkFyZWE7XG59XG5mdW5jdGlvbiBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZykge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gICAgY29uc3Qgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG4gICAgY29uc3QgeyBjZW50ZXJQb2ludExhYmVscyAsIGRpc3BsYXkgIH0gPSBvcHRzLnBvaW50TGFiZWxzO1xuICAgIGNvbnN0IGl0ZW1PcHRzID0ge1xuICAgICAgICBleHRyYTogZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIC8gMixcbiAgICAgICAgYWRkaXRpb25hbEFuZ2xlOiBjZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDBcbiAgICB9O1xuICAgIGxldCBhcmVhO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspe1xuICAgICAgICBpdGVtT3B0cy5wYWRkaW5nID0gcGFkZGluZ1tpXTtcbiAgICAgICAgaXRlbU9wdHMuc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBjcmVhdGVQb2ludExhYmVsSXRlbShzY2FsZSwgaSwgaXRlbU9wdHMpO1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAoZGlzcGxheSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBpdGVtLnZpc2libGUgPSBpc05vdE92ZXJsYXBwZWQoaXRlbSwgYXJlYSk7XG4gICAgICAgICAgICBpZiAoaXRlbS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgYXJlYSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcbiAgICBpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgfSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH1cbiAgICByZXR1cm4gJ3JpZ2h0Jztcbn1cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeCAtPSB3O1xuICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggLT0gdyAvIDI7XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XG4gICAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG4gICAgICAgIHkgLT0gaCAvIDI7XG4gICAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG4gICAgICAgIHkgLT0gaDtcbiAgICB9XG4gICAgcmV0dXJuIHk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHMsIGl0ZW0pIHtcbiAgICBjb25zdCB7IGxlZnQgLCB0b3AgLCByaWdodCAsIGJvdHRvbSAgfSA9IGl0ZW07XG4gICAgY29uc3QgeyBiYWNrZHJvcENvbG9yICB9ID0gb3B0cztcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYmFja2Ryb3BDb2xvcikpIHtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhvcHRzLmJvcmRlclJhZGl1cyk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BDb2xvcjtcbiAgICAgICAgY29uc3QgYmFja2Ryb3BMZWZ0ID0gbGVmdCAtIHBhZGRpbmcubGVmdDtcbiAgICAgICAgY29uc3QgYmFja2Ryb3BUb3AgPSB0b3AgLSBwYWRkaW5nLnRvcDtcbiAgICAgICAgY29uc3QgYmFja2Ryb3BXaWR0aCA9IHJpZ2h0IC0gbGVmdCArIHBhZGRpbmcud2lkdGg7XG4gICAgICAgIGNvbnN0IGJhY2tkcm9wSGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQ7XG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSgodik9PnYgIT09IDApKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICAgICAgeDogYmFja2Ryb3BMZWZ0LFxuICAgICAgICAgICAgICAgIHk6IGJhY2tkcm9wVG9wLFxuICAgICAgICAgICAgICAgIHc6IGJhY2tkcm9wV2lkdGgsXG4gICAgICAgICAgICAgICAgaDogYmFja2Ryb3BIZWlnaHQsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUsIGxhYmVsQ291bnQpIHtcbiAgICBjb25zdCB7IGN0eCAsIG9wdGlvbnM6IHsgcG9pbnRMYWJlbHMgIH0gIH0gPSBzY2FsZTtcbiAgICBmb3IobGV0IGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICBjb25zdCBpdGVtID0gc2NhbGUuX3BvaW50TGFiZWxJdGVtc1tpXTtcbiAgICAgICAgaWYgKCFpdGVtLnZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gcG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgICAgIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0c0F0SW5kZXgsIGl0ZW0pO1xuICAgICAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgLCB0ZXh0QWxpZ24gIH0gPSBpdGVtO1xuICAgICAgICByZW5kZXJUZXh0KGN0eCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldLCB4LCB5ICsgcGxGb250LmxpbmVIZWlnaHQgLyAyLCBwbEZvbnQsIHtcbiAgICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCkge1xuICAgIGNvbnN0IHsgY3R4ICB9ID0gc2NhbGU7XG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuICAgICAgICBjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKyl7XG4gICAgICAgICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQsIGJvcmRlck9wdHMpIHtcbiAgICBjb25zdCBjdHggPSBzY2FsZS5jdHg7XG4gICAgY29uc3QgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XG4gICAgY29uc3QgeyBjb2xvciAsIGxpbmVXaWR0aCAgfSA9IGdyaWRMaW5lT3B0cztcbiAgICBpZiAoIWNpcmN1bGFyICYmICFsYWJlbENvdW50IHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgY3R4LnNldExpbmVEYXNoKGJvcmRlck9wdHMuZGFzaCk7XG4gICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gYm9yZGVyT3B0cy5kYXNoT2Zmc2V0O1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGluZGV4LFxuICAgICAgICB0eXBlOiAncG9pbnRMYWJlbCdcbiAgICB9KTtcbn1cbmNsYXNzIFJhZGlhbExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgICBzdGF0aWMgaWQgPSAncmFkaWFsTGluZWFyJztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgIGFuaW1hdGU6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcbiAgICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFtdLFxuICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGNpcmN1bGFyOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzdGFydEFuZ2xlOiAwLFxuICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG4gICAgICAgICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgICAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIHNpemU6IDEwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2sgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgICAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgICAgICAgfVxuICAgIH07XG4gICAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgICAgICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcbiAgICAgICAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgICAgICAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xuICAgIH07XG4gICAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgICAgICBhbmdsZUxpbmVzOiB7XG4gICAgICAgICAgICBfZmFsbGJhY2s6ICdncmlkJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdHJ1Y3RvcihjZmcpe1xuICAgICAgICBzdXBlcihjZmcpO1xuICAgICAgICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5kcmF3aW5nQXJlYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuX3BvaW50TGFiZWxzID0gW107XG4gICAgICAgIHRoaXMuX3BvaW50TGFiZWxJdGVtcyA9IFtdO1xuICAgIH1cbiAgICBzZXREaW1lbnNpb25zKCkge1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGggLSBwYWRkaW5nLndpZHRoO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xuICAgICAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICAgICAgdGhpcy55Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLnRvcCArIGggLyAyICsgcGFkZGluZy50b3ApO1xuICAgICAgICB0aGlzLmRyYXdpbmdBcmVhID0gTWF0aC5mbG9vcihNYXRoLm1pbih3LCBoKSAvIDIpO1xuICAgIH1cbiAgICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgICAgICBjb25zdCB7IG1pbiAsIG1heCAgfSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcbiAgICAgICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogMDtcbiAgICAgICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcbiAgICAgICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gICAgfVxuIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcbiAgICB9XG4gICAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgICAgIExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwodGhpcywgdGlja3MpO1xuICAgICAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCkubWFwKCh2YWx1ZSwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNhbGxiYWNrKHRoaXMub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgW1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbCB8fCBsYWJlbCA9PT0gMCA/IGxhYmVsIDogJyc7XG4gICAgICAgIH0pLmZpbHRlcigodiwgaSk9PnRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkpO1xuICAgIH1cbiAgICBmaXQoKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICAgICAgICBmaXRXaXRoUG9pbnRMYWJlbHModGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENlbnRlclBvaW50KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG4gICAgICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgICAgICB0aGlzLnlDZW50ZXIgKz0gTWF0aC5mbG9vcigodG9wTW92ZW1lbnQgLSBib3R0b21Nb3ZlbWVudCkgLyAyKTtcbiAgICAgICAgdGhpcy5kcmF3aW5nQXJlYSAtPSBNYXRoLm1pbih0aGlzLmRyYXdpbmdBcmVhIC8gMiwgTWF0aC5tYXgobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpKTtcbiAgICB9XG4gICAgZ2V0SW5kZXhBbmdsZShpbmRleCkge1xuICAgICAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyAodGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoIHx8IDEpO1xuICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcbiAgICAgICAgcmV0dXJuIF9ub3JtYWxpemVBbmdsZShpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHRvUmFkaWFucyhzdGFydEFuZ2xlKSk7XG4gICAgfVxuICAgIGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2FsaW5nRmFjdG9yID0gdGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5taW4pICogc2NhbGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoZGlzdGFuY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjYWxlZERpc3RhbmNlID0gZGlzdGFuY2UgLyAodGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IHRoaXMubWF4IC0gc2NhbGVkRGlzdGFuY2UgOiB0aGlzLm1pbiArIHNjYWxlZERpc3RhbmNlO1xuICAgIH1cbiAgICBnZXRQb2ludExhYmVsQ29udGV4dChpbmRleCkge1xuICAgICAgICBjb25zdCBwb2ludExhYmVscyA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBvaW50TGFiZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRMYWJlbCA9IHBvaW50TGFiZWxzW2luZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQb2ludExhYmVsQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHBvaW50TGFiZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFBvaW50UG9zaXRpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlciwgYWRkaXRpb25hbEFuZ2xlID0gMCkge1xuICAgICAgICBjb25zdCBhbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSBIQUxGX1BJICsgYWRkaXRpb25hbEFuZ2xlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgICAgICAgYW5nbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG4gICAgfVxuICAgIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXggfHwgMCwgdGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gICAgfVxuICAgIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgICAgICBjb25zdCB7IGxlZnQgLCB0b3AgLCByaWdodCAsIGJvdHRvbSAgfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1tpbmRleF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b21cbiAgICAgICAgfTtcbiAgICB9XG4gZHJhd0JhY2tncm91bmQoKSB7XG4gICAgICAgIGNvbnN0IHsgYmFja2dyb3VuZENvbG9yICwgZ3JpZDogeyBjaXJjdWxhciAgfSAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuIGRyYXdHcmlkKCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBhbmdsZUxpbmVzICwgZ3JpZCAsIGJvcmRlciAgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IGxhYmVsQ291bnQgPSB0aGlzLl9wb2ludExhYmVscy5sZW5ndGg7XG4gICAgICAgIGxldCBpLCBvZmZzZXQsIHBvc2l0aW9uO1xuICAgICAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICAgICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCk9PntcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aWNrLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleEJvcmRlciA9IGJvcmRlci5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50LCBvcHRzQXRJbmRleEJvcmRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuZ2xlTGluZXMuZGlzcGxheSkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGZvcihpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKXtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbG9yICwgbGluZVdpZHRoICB9ID0gb3B0c0F0SW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gdGhpcy5taW4gOiB0aGlzLm1heCk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuIGRyYXdCb3JkZXIoKSB7fVxuIGRyYXdMYWJlbHMoKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgICAgIGxldCBvZmZzZXQsIHdpZHRoO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpPT57XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgICAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aWNrLmxhYmVsKS53aWR0aDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsIC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHBhZGRpbmcudG9wLCB3aWR0aCArIHBhZGRpbmcud2lkdGgsIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuIGRyYXdUaXRsZSgpIHt9XG59XG5cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgICBtaWxsaXNlY29uZDoge1xuICAgICAgICBjb21tb246IHRydWUsXG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIHN0ZXBzOiAxMDAwXG4gICAgfSxcbiAgICBzZWNvbmQ6IHtcbiAgICAgICAgY29tbW9uOiB0cnVlLFxuICAgICAgICBzaXplOiAxMDAwLFxuICAgICAgICBzdGVwczogNjBcbiAgICB9LFxuICAgIG1pbnV0ZToge1xuICAgICAgICBjb21tb246IHRydWUsXG4gICAgICAgIHNpemU6IDYwMDAwLFxuICAgICAgICBzdGVwczogNjBcbiAgICB9LFxuICAgIGhvdXI6IHtcbiAgICAgICAgY29tbW9uOiB0cnVlLFxuICAgICAgICBzaXplOiAzNjAwMDAwLFxuICAgICAgICBzdGVwczogMjRcbiAgICB9LFxuICAgIGRheToge1xuICAgICAgICBjb21tb246IHRydWUsXG4gICAgICAgIHNpemU6IDg2NDAwMDAwLFxuICAgICAgICBzdGVwczogMzBcbiAgICB9LFxuICAgIHdlZWs6IHtcbiAgICAgICAgY29tbW9uOiBmYWxzZSxcbiAgICAgICAgc2l6ZTogNjA0ODAwMDAwLFxuICAgICAgICBzdGVwczogNFxuICAgIH0sXG4gICAgbW9udGg6IHtcbiAgICAgICAgY29tbW9uOiB0cnVlLFxuICAgICAgICBzaXplOiAyLjYyOGU5LFxuICAgICAgICBzdGVwczogMTJcbiAgICB9LFxuICAgIHF1YXJ0ZXI6IHtcbiAgICAgICAgY29tbW9uOiBmYWxzZSxcbiAgICAgICAgc2l6ZTogNy44ODRlOSxcbiAgICAgICAgc3RlcHM6IDRcbiAgICB9LFxuICAgIHllYXI6IHtcbiAgICAgICAgY29tbW9uOiB0cnVlLFxuICAgICAgICBzaXplOiAzLjE1NGUxMFxuICAgIH1cbn07XG4gY29uc3QgVU5JVFMgPSAgLyogI19fUFVSRV9fICovIE9iamVjdC5rZXlzKElOVEVSVkFMUyk7XG4gZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG4gZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gICAgY29uc3QgeyBwYXJzZXIgLCByb3VuZCAsIGlzb1dlZWtkYXkgIH0gPSBzY2FsZS5fcGFyc2VPcHRzO1xuICAgIGxldCB2YWx1ZSA9IGlucHV0O1xuICAgIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFpc051bWJlckZpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJyA/IGFkYXB0ZXIucGFyc2UodmFsdWUsICBwYXJzZXIpIDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJvdW5kKSB7XG4gICAgICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSkgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSkgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgICB9XG4gICAgcmV0dXJuICt2YWx1ZTtcbn1cbiBmdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICAgIGNvbnN0IGlsZW4gPSBVTklUUy5sZW5ndGg7XG4gICAgZm9yKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpe1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cbiBmdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgbnVtVGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG4gICAgZm9yKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pe1xuICAgICAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG4gZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgICBmb3IobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgICAgICB9XG4gICAgfVxufVxuIGZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICAgICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgeyBsbyAsIGhpICB9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gdGltZXN0YW1wc1tsb10gPj0gdGltZSA/IHRpbWVzdGFtcHNbbG9dIDogdGltZXN0YW1wc1toaV07XG4gICAgICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICAgIH1cbn1cbiBmdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gICAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICAgIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgICBsZXQgbWFqb3IsIGluZGV4O1xuICAgIGZvcihtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSl7XG4gICAgICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xufVxuIGZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICAgY29uc3QgbWFwID0ge307XG4gICAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgbGV0IGksIHZhbHVlO1xuICAgIGZvcihpID0gMDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBtYXBbdmFsdWVdID0gaTtcbiAgICAgICAgdGlja3MucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1ham9yOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cbmNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgICBzdGF0aWMgaWQgPSAndGltZSc7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuIGJvdW5kczogJ2RhdGEnLFxuICAgICAgICBhZGFwdGVyczoge30sXG4gICAgICAgIHRpbWU6IHtcbiAgICAgICAgICAgIHBhcnNlcjogZmFsc2UsXG4gICAgICAgICAgICB1bml0OiBmYWxzZSxcbiAgICAgICAgICAgIHJvdW5kOiBmYWxzZSxcbiAgICAgICAgICAgIGlzb1dlZWtkYXk6IGZhbHNlLFxuICAgICAgICAgICAgbWluVW5pdDogJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgIGRpc3BsYXlGb3JtYXRzOiB7fVxuICAgICAgICB9LFxuICAgICAgICB0aWNrczoge1xuIHNvdXJjZTogJ2F1dG8nLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZhbHNlLFxuICAgICAgICAgICAgbWFqb3I6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBsYWJlbHM6IFtdLFxuICAgICAgICAgICAgYWxsOiBbXVxuICAgICAgICB9O1xuICAgICAgICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgICAgICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9vZmZzZXRzID0ge307XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpbml0KHNjYWxlT3B0cywgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgICAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG4gICAgICAgIGFkYXB0ZXIuaW5pdChvcHRzKTtcbiAgICAgICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG4gICAgICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgICAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICAgICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgICAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgICAgICB9O1xuICAgICAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBvcHRzLm5vcm1hbGl6ZWQ7XG4gICAgfVxuIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICAgICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgICB9XG4gICAgYmVmb3JlTGF5b3V0KCkge1xuICAgICAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIGxhYmVsczogW10sXG4gICAgICAgICAgICBhbGw6IFtdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgICAgICBjb25zdCB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XG4gICAgICAgIGxldCB7IG1pbiAsIG1heCAsIG1pbkRlZmluZWQgLCBtYXhEZWZpbmVkICB9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gZnVuY3Rpb24gX2FwcGx5Qm91bmRzKGJvdW5kcykge1xuICAgICAgICAgICAgaWYgKCFtaW5EZWZpbmVkICYmICFpc05hTihib3VuZHMubWluKSkge1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1pbkRlZmluZWQgfHwgIW1heERlZmluZWQpIHtcbiAgICAgICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcbiAgICAgICAgICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtaW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICAgICAgbWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMTtcbiAgICAgICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xuICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gICAgfVxuIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICAgICAgY29uc3QgYXJyID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICAgICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgICAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIG1heFxuICAgICAgICB9O1xuICAgIH1cbiBidWlsZFRpY2tzKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICAgICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBzID0gdGlja09wdHMuc291cmNlID09PSAnbGFiZWxzJyA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubWluID0gdGhpcy5fdXNlck1pbiB8fCB0aW1lc3RhbXBzWzBdO1xuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzLl91c2VyTWF4IHx8IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuICAgICAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKSA6IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHRoaXMsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSk7XG4gICAgICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZCA6IGRldGVybWluZU1ham9yVW5pdCh0aGlzLl91bml0KTtcbiAgICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIHRpY2tzLCB0aGlzLl9tYWpvclVuaXQpO1xuICAgIH1cbiAgICBhZnRlckF1dG9Ta2lwKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldEFmdGVyQXV0b3NraXApIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdE9mZnNldHModGhpcy50aWNrcy5tYXAoKHRpY2spPT4rdGljay52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMgPSBbXSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gMDtcbiAgICAgICAgbGV0IGZpcnN0LCBsYXN0O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMSAtIGZpcnN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IChsYXN0IC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSkgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgbGltaXQpO1xuICAgICAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZClcbiAgICAgICAgfTtcbiAgICB9XG4gX2dlbmVyYXRlKCkge1xuICAgICAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICAgICAgY29uc3QgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSk7XG4gICAgICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5zdGVwU2l6ZSwgMSk7XG4gICAgICAgIGNvbnN0IHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICAgICAgbGV0IGZpcnN0ID0gbWluO1xuICAgICAgICBsZXQgdGltZSwgY291bnQ7XG4gICAgICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICAgICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG4gICAgICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgICAgICBmb3IodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKyl7XG4gICAgICAgICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZSA9PT0gbWF4IHx8IG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnIHx8IGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoc29ydGVyKS5tYXAoKHgpPT4reCk7XG4gICAgfVxuIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgICAgIGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICAgIH1cbiBmb3JtYXQodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgICAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICAgICAgY29uc3QgZm10ID0gZm9ybWF0IHx8IGZvcm1hdHNbdW5pdF07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh2YWx1ZSwgZm10KTtcbiAgICB9XG4gX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBvcHRpb25zLnRpY2tzLmNhbGxiYWNrO1xuICAgICAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZm9ybWF0dGVyLCBbXG4gICAgICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICB0aWNrc1xuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICAgICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICAgICAgY29uc3QgbWlub3JGb3JtYXQgPSB1bml0ICYmIGZvcm1hdHNbdW5pdF07XG4gICAgICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgICAgY29uc3QgbWFqb3IgPSBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGljayAmJiB0aWNrLm1ham9yO1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgICB9XG4gZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgICAgIH1cbiAgICB9XG4gZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICB9XG4gZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICAgIH1cbiBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgICAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgfVxuIF9nZXRMYWJlbFNpemUobGFiZWwpIHtcbiAgICAgICAgY29uc3QgdGlja3NPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgICAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICAgICAgY29uc3QgYW5nbGUgPSB0b1JhZGlhbnModGhpcy5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgY29uc3QgdGlja0ZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdzogdGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbiArIHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uLFxuICAgICAgICAgICAgaDogdGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbiArIHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uXG4gICAgICAgIH07XG4gICAgfVxuIF9nZXRMYWJlbENhcGFjaXR5KGV4YW1wbGVUaW1lKSB7XG4gICAgICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGRpc3BsYXlGb3JtYXRzW3RpbWVPcHRzLnVuaXRdIHx8IGRpc3BsYXlGb3JtYXRzLm1pbGxpc2Vjb25kO1xuICAgICAgICBjb25zdCBleGFtcGxlTGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgW1xuICAgICAgICAgICAgZXhhbXBsZVRpbWVcbiAgICAgICAgXSwgdGhpcy5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgICAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgICAgICByZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuICAgIH1cbiBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgICAgICBsZXQgaSwgaWxlbjtcbiAgICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZGF0YSA9IG1ldGFzWzBdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICB0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5jb25jYXQobWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcyk7XG4gICAgfVxuIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICAgICAgbGV0IGksIGlsZW47XG4gICAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcyk7XG4gICAgfVxuIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgICBsZXQgbG8gPSAwO1xuICAgIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gICAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAgICAgICAoeyBsbyAsIGhpICB9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgcG9zOiBwcmV2U291cmNlICwgdGltZTogcHJldlRhcmdldCAgfSA9IHRhYmxlW2xvXSk7XG4gICAgICAgICh7IHBvczogbmV4dFNvdXJjZSAsIHRpbWU6IG5leHRUYXJnZXQgIH0gPSB0YWJsZVtoaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAgICAgICAoeyBsbyAsIGhpICB9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgICAgICB9XG4gICAgICAgICh7IHRpbWU6IHByZXZTb3VyY2UgLCBwb3M6IHByZXZUYXJnZXQgIH0gPSB0YWJsZVtsb10pO1xuICAgICAgICAoeyB0aW1lOiBuZXh0U291cmNlICwgcG9zOiBuZXh0VGFyZ2V0ICB9ID0gdGFibGVbaGldKTtcbiAgICB9XG4gICAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xuICAgIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cbmNsYXNzIFRpbWVTZXJpZXNTY2FsZSBleHRlbmRzIFRpbWVTY2FsZSB7XG4gICAgc3RhdGljIGlkID0gJ3RpbWVzZXJpZXMnO1xuIHN0YXRpYyBkZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcbiBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgICAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLl90YWJsZVJhbmdlID0gdW5kZWZpbmVkO1xuICAgIH1cbiBpbml0T2Zmc2V0cygpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgICAgICB0aGlzLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5taW4pO1xuICAgICAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICAgICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gICAgfVxuIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgICAgICBjb25zdCB7IG1pbiAsIG1heCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICBjdXJyID0gdGltZXN0YW1wc1tpXTtcbiAgICAgICAgICAgIGlmIChjdXJyID49IG1pbiAmJiBjdXJyIDw9IG1heCkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBtaW4sXG4gICAgICAgICAgICAgICAgICAgIHBvczogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBtYXgsXG4gICAgICAgICAgICAgICAgICAgIHBvczogMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICAgICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgICAgICAgICAgdGFibGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGN1cnIsXG4gICAgICAgICAgICAgICAgICAgIHBvczogaSAvIChpbGVuIC0gMSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuIF9nZW5lcmF0ZSgpIHtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgICAgICBsZXQgdGltZXN0YW1wcyA9IHN1cGVyLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtaW4pIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGltZXN0YW1wcy5zcGxpY2UoMCwgMCwgbWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRpbWVzdGFtcHMuaW5jbHVkZXMobWF4KSB8fCB0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGltZXN0YW1wcy5wdXNoKG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVzdGFtcHMuc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICB9XG4gX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG4gICAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBzID0gdGhpcy5ub3JtYWxpemUoZGF0YS5jb25jYXQobGFiZWwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICAgICAgfVxuICAgICAgICB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsID0gdGltZXN0YW1wcztcbiAgICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCB2YWx1ZSkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgICB9XG4gZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgICAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICAgICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgZGVjaW1hbCAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsIHRydWUpO1xuICAgIH1cbn1cblxudmFyIHNjYWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkNhdGVnb3J5U2NhbGU6IENhdGVnb3J5U2NhbGUsXG5MaW5lYXJTY2FsZTogTGluZWFyU2NhbGUsXG5Mb2dhcml0aG1pY1NjYWxlOiBMb2dhcml0aG1pY1NjYWxlLFxuUmFkaWFsTGluZWFyU2NhbGU6IFJhZGlhbExpbmVhclNjYWxlLFxuVGltZVNjYWxlOiBUaW1lU2NhbGUsXG5UaW1lU2VyaWVzU2NhbGU6IFRpbWVTZXJpZXNTY2FsZVxufSk7XG5cbmNvbnN0IHJlZ2lzdGVyYWJsZXMgPSBbXG4gICAgY29udHJvbGxlcnMsXG4gICAgZWxlbWVudHMsXG4gICAgcGx1Z2lucyxcbiAgICBzY2FsZXNcbl07XG5cbmV4cG9ydCB7IEFuaW1hdGlvbiwgQW5pbWF0aW9ucywgQXJjRWxlbWVudCwgQmFyQ29udHJvbGxlciwgQmFyRWxlbWVudCwgQmFzZVBsYXRmb3JtLCBCYXNpY1BsYXRmb3JtLCBCdWJibGVDb250cm9sbGVyLCBDYXRlZ29yeVNjYWxlLCBDaGFydCwgcGx1Z2luX2NvbG9ycyBhcyBDb2xvcnMsIERhdGFzZXRDb250cm9sbGVyLCBwbHVnaW5fZGVjaW1hdGlvbiBhcyBEZWNpbWF0aW9uLCBEb21QbGF0Zm9ybSwgRG91Z2hudXRDb250cm9sbGVyLCBFbGVtZW50LCBpbmRleCBhcyBGaWxsZXIsIEludGVyYWN0aW9uLCBwbHVnaW5fbGVnZW5kIGFzIExlZ2VuZCwgTGluZUNvbnRyb2xsZXIsIExpbmVFbGVtZW50LCBMaW5lYXJTY2FsZSwgTG9nYXJpdGhtaWNTY2FsZSwgUGllQ29udHJvbGxlciwgUG9pbnRFbGVtZW50LCBQb2xhckFyZWFDb250cm9sbGVyLCBSYWRhckNvbnRyb2xsZXIsIFJhZGlhbExpbmVhclNjYWxlLCBTY2FsZSwgU2NhdHRlckNvbnRyb2xsZXIsIHBsdWdpbl9zdWJ0aXRsZSBhcyBTdWJUaXRsZSwgVGlja3MsIFRpbWVTY2FsZSwgVGltZVNlcmllc1NjYWxlLCBwbHVnaW5fdGl0bGUgYXMgVGl0bGUsIHBsdWdpbl90b29sdGlwIGFzIFRvb2x0aXAsIGFkYXB0ZXJzIGFzIF9hZGFwdGVycywgX2RldGVjdFBsYXRmb3JtLCBhbmltYXRvciwgY29udHJvbGxlcnMsIGRlZmF1bHRzLCBlbGVtZW50cywgbGF5b3V0cywgcGx1Z2lucywgcmVnaXN0ZXJhYmxlcywgcmVnaXN0cnksIHNjYWxlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnQuanMubWFwXG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcbiIsImltcG9ydCBjb3JlSnNEYXRhIGZyb20gJy4vX2NvcmVKc0RhdGEuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTWFza2VkIGZyb20gJy4vX2lzTWFza2VkLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hdGl2ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcbiIsImltcG9ydCBiYXNlSXNOYXRpdmUgZnJvbSAnLi9fYmFzZUlzTmF0aXZlLmpzJztcbmltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL19nZXRWYWx1ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5hdGl2ZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5leHBvcnQgZGVmYXVsdCBXZWFrTWFwO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlBcnJheTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZVByb3BlcnR5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUVhY2g7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCJpbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSAnLi9fZGVmaW5lUHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduVmFsdWU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnblZhbHVlO1xuIiwiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlPYmplY3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUaW1lcztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmFyeTtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBub2RlVXRpbDtcbiIsImltcG9ydCBiYXNlSXNUeXBlZEFycmF5IGZyb20gJy4vX2Jhc2VJc1R5cGVkQXJyYXkuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IG5vZGVVdGlsIGZyb20gJy4vX25vZGVVdGlsLmpzJztcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzVHlwZWRBcnJheTtcbiIsImltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG4iLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXNJbjtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5c0luIGZyb20gJy4vX25hdGl2ZUtleXNJbi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzSW47XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5c0luIGZyb20gJy4vX2Jhc2VLZXlzSW4uanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5c0luO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVDcmVhdGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoRGVsZXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hHZXQ7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEhhcztcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hTZXQ7XG4iLCJpbXBvcnQgaGFzaENsZWFyIGZyb20gJy4vX2hhc2hDbGVhci5qcyc7XG5pbXBvcnQgaGFzaERlbGV0ZSBmcm9tICcuL19oYXNoRGVsZXRlLmpzJztcbmltcG9ydCBoYXNoR2V0IGZyb20gJy4vX2hhc2hHZXQuanMnO1xuaW1wb3J0IGhhc2hIYXMgZnJvbSAnLi9faGFzaEhhcy5qcyc7XG5pbXBvcnQgaGFzaFNldCBmcm9tICcuL19oYXNoU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IEhhc2g7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUNsZWFyO1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NvY0luZGV4T2Y7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVHZXQ7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVIYXM7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlU2V0O1xuIiwiaW1wb3J0IGxpc3RDYWNoZUNsZWFyIGZyb20gJy4vX2xpc3RDYWNoZUNsZWFyLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVEZWxldGUgZnJvbSAnLi9fbGlzdENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVHZXQgZnJvbSAnLi9fbGlzdENhY2hlR2V0LmpzJztcbmltcG9ydCBsaXN0Q2FjaGVIYXMgZnJvbSAnLi9fbGlzdENhY2hlSGFzLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVTZXQgZnJvbSAnLi9fbGlzdENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBMaXN0Q2FjaGU7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcDtcbiIsImltcG9ydCBIYXNoIGZyb20gJy4vX0hhc2guanMnO1xuaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlQ2xlYXI7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzS2V5YWJsZTtcbiIsImltcG9ydCBpc0tleWFibGUgZnJvbSAnLi9faXNLZXlhYmxlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRNYXBEYXRhO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZURlbGV0ZTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlR2V0O1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlSGFzO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVTZXQ7XG4iLCJpbXBvcnQgbWFwQ2FjaGVDbGVhciBmcm9tICcuL19tYXBDYWNoZUNsZWFyLmpzJztcbmltcG9ydCBtYXBDYWNoZURlbGV0ZSBmcm9tICcuL19tYXBDYWNoZURlbGV0ZS5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVHZXQgZnJvbSAnLi9fbWFwQ2FjaGVHZXQuanMnO1xuaW1wb3J0IG1hcENhY2hlSGFzIGZyb20gJy4vX21hcENhY2hlSGFzLmpzJztcbmltcG9ydCBtYXBDYWNoZVNldCBmcm9tICcuL19tYXBDYWNoZVNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBNYXBDYWNoZTtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlQdXNoO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrSGFzO1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrU2V0O1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IHN0YWNrQ2xlYXIgZnJvbSAnLi9fc3RhY2tDbGVhci5qcyc7XG5pbXBvcnQgc3RhY2tEZWxldGUgZnJvbSAnLi9fc3RhY2tEZWxldGUuanMnO1xuaW1wb3J0IHN0YWNrR2V0IGZyb20gJy4vX3N0YWNrR2V0LmpzJztcbmltcG9ydCBzdGFja0hhcyBmcm9tICcuL19zdGFja0hhcy5qcyc7XG5pbXBvcnQgc3RhY2tTZXQgZnJvbSAnLi9fc3RhY2tTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IFN0YWNrO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ247XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ25JbjtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZUJ1ZmZlcjtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlGaWx0ZXI7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViQXJyYXk7XG4iLCJpbXBvcnQgYXJyYXlGaWx0ZXIgZnJvbSAnLi9fYXJyYXlGaWx0ZXIuanMnO1xuaW1wb3J0IHN0dWJBcnJheSBmcm9tICcuL3N0dWJBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0U3ltYm9scztcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weVN5bWJvbHM7XG4iLCJpbXBvcnQgYXJyYXlQdXNoIGZyb20gJy4vX2FycmF5UHVzaC5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9scyBmcm9tICcuL19nZXRTeW1ib2xzLmpzJztcbmltcG9ydCBzdHViQXJyYXkgZnJvbSAnLi9zdHViQXJyYXkuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXRTeW1ib2xzSW47XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBnZXRTeW1ib2xzSW4gZnJvbSAnLi9fZ2V0U3ltYm9sc0luLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5U3ltYm9sc0luO1xuIiwiaW1wb3J0IGFycmF5UHVzaCBmcm9tICcuL19hcnJheVB1c2guanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0QWxsS2V5cztcbiIsImltcG9ydCBiYXNlR2V0QWxsS2V5cyBmcm9tICcuL19iYXNlR2V0QWxsS2V5cy5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9scyBmcm9tICcuL19nZXRTeW1ib2xzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEFsbEtleXM7XG4iLCJpbXBvcnQgYmFzZUdldEFsbEtleXMgZnJvbSAnLi9fYmFzZUdldEFsbEtleXMuanMnO1xuaW1wb3J0IGdldFN5bWJvbHNJbiBmcm9tICcuL19nZXRTeW1ib2xzSW4uanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEFsbEtleXNJbjtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFWaWV3O1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IFByb21pc2U7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbmV4cG9ydCBkZWZhdWx0IFNldDtcbiIsImltcG9ydCBEYXRhVmlldyBmcm9tICcuL19EYXRhVmlldy5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuL19Qcm9taXNlLmpzJztcbmltcG9ydCBTZXQgZnJvbSAnLi9fU2V0LmpzJztcbmltcG9ydCBXZWFrTWFwIGZyb20gJy4vX1dlYWtNYXAuanMnO1xuaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbml0Q2xvbmVBcnJheTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBVaW50OEFycmF5O1xuIiwiaW1wb3J0IFVpbnQ4QXJyYXkgZnJvbSAnLi9fVWludDhBcnJheS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVBcnJheUJ1ZmZlcjtcbiIsImltcG9ydCBjbG9uZUFycmF5QnVmZmVyIGZyb20gJy4vX2Nsb25lQXJyYXlCdWZmZXIuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZURhdGFWaWV3O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVSZWdFeHA7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVTeW1ib2w7XG4iLCJpbXBvcnQgY2xvbmVBcnJheUJ1ZmZlciBmcm9tICcuL19jbG9uZUFycmF5QnVmZmVyLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5pbXBvcnQgY2xvbmVEYXRhVmlldyBmcm9tICcuL19jbG9uZURhdGFWaWV3LmpzJztcbmltcG9ydCBjbG9uZVJlZ0V4cCBmcm9tICcuL19jbG9uZVJlZ0V4cC5qcyc7XG5pbXBvcnQgY2xvbmVTeW1ib2wgZnJvbSAnLi9fY2xvbmVTeW1ib2wuanMnO1xuaW1wb3J0IGNsb25lVHlwZWRBcnJheSBmcm9tICcuL19jbG9uZVR5cGVkQXJyYXkuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lQnlUYWc7XG4iLCJpbXBvcnQgYmFzZUNyZWF0ZSBmcm9tICcuL19iYXNlQ3JlYXRlLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lT2JqZWN0O1xuIiwiaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNNYXA7XG4iLCJpbXBvcnQgYmFzZUlzTWFwIGZyb20gJy4vX2Jhc2VJc01hcC5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG5leHBvcnQgZGVmYXVsdCBpc01hcDtcbiIsImltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzU2V0O1xuIiwiaW1wb3J0IGJhc2VJc1NldCBmcm9tICcuL19iYXNlSXNTZXQuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IG5vZGVVdGlsIGZyb20gJy4vX25vZGVVdGlsLmpzJztcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTZXQobmV3IFNldCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuZXhwb3J0IGRlZmF1bHQgaXNTZXQ7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGFycmF5RWFjaCBmcm9tICcuL19hcnJheUVhY2guanMnO1xuaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBiYXNlQXNzaWduIGZyb20gJy4vX2Jhc2VBc3NpZ24uanMnO1xuaW1wb3J0IGJhc2VBc3NpZ25JbiBmcm9tICcuL19iYXNlQXNzaWduSW4uanMnO1xuaW1wb3J0IGNsb25lQnVmZmVyIGZyb20gJy4vX2Nsb25lQnVmZmVyLmpzJztcbmltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBjb3B5U3ltYm9scyBmcm9tICcuL19jb3B5U3ltYm9scy5qcyc7XG5pbXBvcnQgY29weVN5bWJvbHNJbiBmcm9tICcuL19jb3B5U3ltYm9sc0luLmpzJztcbmltcG9ydCBnZXRBbGxLZXlzIGZyb20gJy4vX2dldEFsbEtleXMuanMnO1xuaW1wb3J0IGdldEFsbEtleXNJbiBmcm9tICcuL19nZXRBbGxLZXlzSW4uanMnO1xuaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGluaXRDbG9uZUFycmF5IGZyb20gJy4vX2luaXRDbG9uZUFycmF5LmpzJztcbmltcG9ydCBpbml0Q2xvbmVCeVRhZyBmcm9tICcuL19pbml0Q2xvbmVCeVRhZy5qcyc7XG5pbXBvcnQgaW5pdENsb25lT2JqZWN0IGZyb20gJy4vX2luaXRDbG9uZU9iamVjdC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzTWFwIGZyb20gJy4vaXNNYXAuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzU2V0IGZyb20gJy4vaXNTZXQuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUNsb25lO1xuIiwiaW1wb3J0IGJhc2VDbG9uZSBmcm9tICcuL19iYXNlQ2xvbmUuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lRGVlcDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0Q2FjaGVIYXM7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuaW1wb3J0IHNldENhY2hlQWRkIGZyb20gJy4vX3NldENhY2hlQWRkLmpzJztcbmltcG9ydCBzZXRDYWNoZUhhcyBmcm9tICcuL19zZXRDYWNoZUhhcy5qcyc7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuZXhwb3J0IGRlZmF1bHQgU2V0Q2FjaGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVNvbWU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FjaGVIYXM7XG4iLCJpbXBvcnQgU2V0Q2FjaGUgZnJvbSAnLi9fU2V0Q2FjaGUuanMnO1xuaW1wb3J0IGFycmF5U29tZSBmcm9tICcuL19hcnJheVNvbWUuanMnO1xuaW1wb3J0IGNhY2hlSGFzIGZyb20gJy4vX2NhY2hlSGFzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbEFycmF5cztcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRUb0FycmF5O1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IFVpbnQ4QXJyYXkgZnJvbSAnLi9fVWludDhBcnJheS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5pbXBvcnQgZXF1YWxBcnJheXMgZnJvbSAnLi9fZXF1YWxBcnJheXMuanMnO1xuaW1wb3J0IG1hcFRvQXJyYXkgZnJvbSAnLi9fbWFwVG9BcnJheS5qcyc7XG5pbXBvcnQgc2V0VG9BcnJheSBmcm9tICcuL19zZXRUb0FycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxCeVRhZztcbiIsImltcG9ydCBnZXRBbGxLZXlzIGZyb20gJy4vX2dldEFsbEtleXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxPYmplY3RzO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgZXF1YWxCeVRhZyBmcm9tICcuL19lcXVhbEJ5VGFnLmpzJztcbmltcG9ydCBlcXVhbE9iamVjdHMgZnJvbSAnLi9fZXF1YWxPYmplY3RzLmpzJztcbmltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0VxdWFsRGVlcDtcbiIsImltcG9ydCBiYXNlSXNFcXVhbERlZXAgZnJvbSAnLi9fYmFzZUlzRXF1YWxEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzRXF1YWw7XG4iLCJpbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gKlxuICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0VtcHR5KG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSh0cnVlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gIH1cbiAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNFbXB0eTtcbiIsImltcG9ydCBiYXNlSXNFcXVhbCBmcm9tICcuL19iYXNlSXNFcXVhbC5qcyc7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0VxdWFsO1xuIiwidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5cbi8vIHNyYy9jb3JlL2NvbXBvbmVudC5idWlsZGVyLnRzXG5pbXBvcnQgKiBhcyBDaGFydGpzIGZyb20gXCJjaGFydC5qc1wiO1xuaW1wb3J0IHsgY2xvbmVEZWVwLCBpc0VtcHR5LCBpc0VxdWFsIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuXG4vLyBzcmMvdXRpbHMvZm9ybWF0LnV0aWxzLnRzXG5mdW5jdGlvbiBwYXNjYWxDYXNlKHN0cikge1xuICByZXR1cm4gKHN0ci5tYXRjaCgvW2EtekEtWjAtOV0rL2cpIHx8IFtdKS5tYXAoKHcpID0+IGAke3cuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt3LnNsaWNlKDEpfWApLmpvaW4oXCJcIik7XG59XG5cbi8vIHNyYy9jb3JlL2NvbXBvbmVudC5idWlsZGVyLnRzXG5pbXBvcnQge1xuICBkZWZpbmVDb21wb25lbnQsXG4gIGgsXG4gIG9uQmVmb3JlVW5tb3VudCxcbiAgb25Nb3VudGVkLFxuICByZWYsXG4gIHNoYWxsb3dSZWYsXG4gIHdhdGNoXG59IGZyb20gXCJ2dWVcIjtcbnZhciBkZWZpbmVDaGFydENvbXBvbmVudCA9IChjaGFydE5hbWUsIGNoYXJ0VHlwZSkgPT4ge1xuICBjb25zdCBwcm9wc0RlZnMgPSB7XG4gICAgY2hhcnREYXRhOiB7IHR5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICBvcHRpb25zOiB7IHR5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgY2hhcnRJZDogeyBkZWZhdWx0OiBjaGFydE5hbWUsIHR5cGU6IFN0cmluZyB9LFxuICAgIHdpZHRoOiB7IGRlZmF1bHQ6IDQwMCwgdHlwZTogTnVtYmVyIH0sXG4gICAgaGVpZ2h0OiB7IGRlZmF1bHQ6IDQwMCwgdHlwZTogTnVtYmVyIH0sXG4gICAgY3NzQ2xhc3NlczogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6IFwiXCIgfSxcbiAgICBzdHlsZXM6IHsgdHlwZTogT2JqZWN0IH0sXG4gICAgcGx1Z2luczogeyB0eXBlOiBBcnJheSwgZGVmYXVsdDogKCkgPT4gW10gfSxcbiAgICBvbkxhYmVsc1VwZGF0ZTogeyB0eXBlOiBGdW5jdGlvbiB9LFxuICAgIG9uQ2hhcnRVcGRhdGU6IHsgdHlwZTogRnVuY3Rpb24gfSxcbiAgICBvbkNoYXJ0RGVzdHJveTogeyB0eXBlOiBGdW5jdGlvbiB9LFxuICAgIG9uQ2hhcnRSZW5kZXI6IHsgdHlwZTogRnVuY3Rpb24gfVxuICB9O1xuICBjb25zdCBjb21wb25lbnROYW1lID0gcGFzY2FsQ2FzZShjaGFydE5hbWUpO1xuICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcbiAgICBuYW1lOiBjb21wb25lbnROYW1lLFxuICAgIHByb3BzOiBwcm9wc0RlZnMsXG4gICAgZW1pdHM6IHtcbiAgICAgIFwibGFiZWxzOnVwZGF0ZVwiOiAoKSA9PiB0cnVlLFxuICAgICAgXCJjaGFydDp1cGRhdGVcIjogKGNoYXJ0SW5zdGFuY2UpID0+IHRydWUsXG4gICAgICBcImNoYXJ0OmRlc3Ryb3lcIjogKCkgPT4gdHJ1ZSxcbiAgICAgIFwiY2hhcnQ6cmVuZGVyXCI6IChjaGFydEluc3RhbmNlKSA9PiB0cnVlXG4gICAgfSxcbiAgICBzZXR1cChwcm9wcywgeyBlbWl0LCBleHBvc2UgfSkge1xuICAgICAgY29uc3QgY2FudmFzUmVmID0gcmVmKG51bGwpO1xuICAgICAgY29uc3QgY2FudmFzSWQgPSBgJHtwcm9wcy5jaGFydElkfWA7XG4gICAgICBsZXQgY2hhcnRJbnN0YW5jZSA9IHNoYWxsb3dSZWYobnVsbCk7XG4gICAgICB3YXRjaCgoKSA9PiBwcm9wcy5jaGFydERhdGEsIHdhdGNoSGFuZGxlciwgeyBkZWVwOiB0cnVlIH0pO1xuICAgICAgd2F0Y2goKCkgPT4gcHJvcHMub3B0aW9ucywgKG5ld09wdGlvbnMpID0+IHtcbiAgICAgICAgaWYgKGNoYXJ0SW5zdGFuY2UudmFsdWUgJiYgbmV3T3B0aW9ucykge1xuICAgICAgICAgIGNoYXJ0SW5zdGFuY2UudmFsdWUub3B0aW9ucyA9IGNsb25lRGVlcChuZXdPcHRpb25zKTtcbiAgICAgICAgICBoYW5kbGVDaGFydFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7IGRlZXA6IHRydWUgfSk7XG4gICAgICBmdW5jdGlvbiB3YXRjaEhhbmRsZXIobmV3RGF0YSkge1xuICAgICAgICBpZiAoY2hhcnRJbnN0YW5jZS52YWx1ZSkge1xuICAgICAgICAgIGxldCBjaGFydCA9IGNoYXJ0SW5zdGFuY2UudmFsdWU7XG4gICAgICAgICAgaWYgKCFpc0VxdWFsKG5ld0RhdGEubGFiZWxzLCBjaGFydEluc3RhbmNlLnZhbHVlLmRhdGEubGFiZWxzKSkge1xuICAgICAgICAgICAgY2hhcnQuZGF0YS5sYWJlbHMgPSBuZXdEYXRhLmxhYmVscztcbiAgICAgICAgICAgIGhhbmRsZUxhYmVsc1VwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzRXF1YWwobmV3RGF0YS5kYXRhc2V0cywgY2hhcnRJbnN0YW5jZS52YWx1ZS5kYXRhLmRhdGFzZXRzKSkge1xuICAgICAgICAgICAgbmV3RGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkoZGF0YXNldCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGREYXRhID0gY2xvbmVEZWVwKGNoYXJ0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZERhdGFzZXRLZXlzID0gT2JqZWN0LmtleXMoKF9iID0gKF9hID0gb2xkRGF0YS5kYXRhc2V0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2luZGV4XSkgIT0gbnVsbCA/IF9iIDoge30pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGFzZXRLZXlzID0gT2JqZWN0LmtleXMoZGF0YXNldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsZXRpb25LZXlzID0gb2xkRGF0YXNldEtleXMuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkgIT09IFwiX21ldGFcIiAmJiBuZXdEYXRhc2V0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlbGV0aW9uS2V5cy5mb3JFYWNoKChkZWxldGlvbktleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0LmRhdGEuZGF0YXNldHNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGFydC5kYXRhLmRhdGFzZXRzW2luZGV4XVtkZWxldGlvbktleV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gZGF0YXNldCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXR0clZhbHVlID0gY2xvbmVEZWVwKGRhdGFzZXRbYXR0cmlidXRlXSk7XG4gICAgICAgICAgICAgICAgICBsZXQgZGF0YXNldEl0ZW0gPSBjaGFydC5kYXRhLmRhdGFzZXRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgIGlmICghZGF0YXNldEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuZGF0YS5kYXRhc2V0c1tpbmRleF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChkYXRhc2V0Lmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkgJiYgYXR0clZhbHVlICE9IG51bGwgJiYgY2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuZGF0YS5kYXRhc2V0c1tpbmRleF1bYXR0cmlidXRlXSA9IGF0dHJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhcnQuZGF0YS5kYXRhc2V0cyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGFuZGxlQ2hhcnRVcGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2hhcnRJbnN0YW5jZS52YWx1ZSkge1xuICAgICAgICAgICAgaGFuZGxlQ2hhcnREZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbmRlckNoYXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlbmRlckNoYXJ0KCkge1xuICAgICAgICBpZiAoY2FudmFzUmVmLnZhbHVlKSB7XG4gICAgICAgICAgY2hhcnRJbnN0YW5jZS52YWx1ZSA9IG5ldyBDaGFydGpzLkNoYXJ0KGNhbnZhc1JlZi52YWx1ZSwge1xuICAgICAgICAgICAgZGF0YTogY2xvbmVEZWVwKHByb3BzLmNoYXJ0RGF0YSksXG4gICAgICAgICAgICB0eXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICBvcHRpb25zOiBjbG9uZURlZXAocHJvcHMub3B0aW9ucyksXG4gICAgICAgICAgICBwbHVnaW5zOiBwcm9wcy5wbHVnaW5zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaGFuZGxlQ2hhcnRSZW5kZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBvbiBjb21wb25lbnQgJHtjb21wb25lbnROYW1lfSwgY2FudmFzIGNhbm5vdCBiZSByZW5kZXJlZC4gQ2hlY2sgaWYgdGhlIHJlbmRlciBhcHBlbmRzIHNlcnZlci1zaWRlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUxhYmVsc1VwZGF0ZSgpIHtcbiAgICAgICAgZW1pdChcImxhYmVsczp1cGRhdGVcIik7XG4gICAgICAgIHByb3BzLm9uTGFiZWxzVXBkYXRlICYmIHByb3BzLm9uTGFiZWxzVXBkYXRlKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoYW5kbGVDaGFydFJlbmRlcigpIHtcbiAgICAgICAgaWYgKGNoYXJ0SW5zdGFuY2UudmFsdWUpIHtcbiAgICAgICAgICBlbWl0KFwiY2hhcnQ6cmVuZGVyXCIsIGNoYXJ0SW5zdGFuY2UudmFsdWUpO1xuICAgICAgICAgIHByb3BzLm9uQ2hhcnRSZW5kZXIgJiYgcHJvcHMub25DaGFydFJlbmRlcihjaGFydEluc3RhbmNlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaGFuZGxlQ2hhcnRVcGRhdGUoKSB7XG4gICAgICAgIGlmIChjaGFydEluc3RhbmNlLnZhbHVlKSB7XG4gICAgICAgICAgY2hhcnRJbnN0YW5jZS52YWx1ZS51cGRhdGUoKTtcbiAgICAgICAgICBlbWl0KFwiY2hhcnQ6dXBkYXRlXCIsIGNoYXJ0SW5zdGFuY2UudmFsdWUpO1xuICAgICAgICAgIHByb3BzLm9uQ2hhcnRVcGRhdGUgJiYgcHJvcHMub25DaGFydFVwZGF0ZShjaGFydEluc3RhbmNlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaGFuZGxlQ2hhcnREZXN0cm95KCkge1xuICAgICAgICBjaGFydEluc3RhbmNlLnZhbHVlICYmIGNoYXJ0SW5zdGFuY2UudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICBlbWl0KFwiY2hhcnQ6ZGVzdHJveVwiKTtcbiAgICAgICAgcHJvcHMub25DaGFydERlc3Ryb3kgJiYgcHJvcHMub25DaGFydERlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIG9uTW91bnRlZChyZW5kZXJDaGFydCk7XG4gICAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAoY2hhcnRJbnN0YW5jZS52YWx1ZSkge1xuICAgICAgICAgIGNoYXJ0SW5zdGFuY2UudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGV4cG9zZSh7XG4gICAgICAgIGNhbnZhc1JlZixcbiAgICAgICAgcmVuZGVyQ2hhcnQsXG4gICAgICAgIGNoYXJ0SW5zdGFuY2UsXG4gICAgICAgIGNhbnZhc0lkLFxuICAgICAgICB1cGRhdGU6IGhhbmRsZUNoYXJ0VXBkYXRlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiBoKFwiZGl2XCIsIHtcbiAgICAgICAgc3R5bGU6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgIG1heFdpZHRoOiBcIjEwMCVcIlxuICAgICAgICB9LCBwcm9wcy5zdHlsZXMpLCB7XG4gICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgICAgICB9KSxcbiAgICAgICAgY2xhc3M6IHByb3BzLmNzc0NsYXNzZXNcbiAgICAgIH0sIFtcbiAgICAgICAgaChcImNhbnZhc1wiLCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIG1heFdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgIG1heEhlaWdodDogXCIxMDAlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBjYW52YXNJZCxcbiAgICAgICAgICB3aWR0aDogcHJvcHMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBwcm9wcy5oZWlnaHQsXG4gICAgICAgICAgcmVmOiBjYW52YXNSZWZcbiAgICAgICAgfSlcbiAgICAgIF0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvaG9va3MvaG9va3MuYnVpbGRlci50c1xuaW1wb3J0IHsgY29tcHV0ZWQgYXMgY29tcHV0ZWQyLCByZWYgYXMgcmVmMiwgdW5yZWYgfSBmcm9tIFwidnVlXCI7XG52YXIgZGVmaW5lQ2hhcnRIb29rID0gKGNoYXJ0VHlwZSkgPT4ge1xuICByZXR1cm4gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IENIQVJUX1JFRl9OQU1FID0gYCR7Y2hhcnRUeXBlfUNoYXJ0UmVmYDtcbiAgICBjb25zdCBfc3RydWN0ID0ge1xuICAgICAgW0NIQVJUX1JFRl9OQU1FXTogcmVmMigpXG4gICAgfTtcbiAgICBjb25zdCByZWFjdGl2ZVByb3BzID0gY29tcHV0ZWQyKCgpID0+IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHBhcmFtcyksIHBhcmFtcy5qc3ggJiYge1xuICAgICAgcmVmOiBfc3RydWN0W0NIQVJUX1JFRl9OQU1FXVxuICAgIH0pLCAhcGFyYW1zLmpzeCAmJiB7XG4gICAgICByZWY6IENIQVJUX1JFRl9OQU1FXG4gICAgfSksIHtcbiAgICAgIGNoYXJ0RGF0YTogdW5yZWYocGFyYW1zLmNoYXJ0RGF0YSksXG4gICAgICBvcHRpb25zOiB1bnJlZihwYXJhbXMub3B0aW9ucylcbiAgICB9KSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgY2hhcnRDb21wb25lbnRSZWYgPSBfc3RydWN0W0NIQVJUX1JFRl9OQU1FXS52YWx1ZTtcbiAgICAgIGlmIChjaGFydENvbXBvbmVudFJlZikge1xuICAgICAgICAoX2EgPSBjaGFydENvbXBvbmVudFJlZiA9PSBudWxsID8gdm9pZCAwIDogY2hhcnRDb21wb25lbnRSZWYuY2hhcnRJbnN0YW5jZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBjaGFydEluc3RhbmNlIHRvIHVwZGF0ZSAodXNlJHtwYXNjYWxDYXNlKGNoYXJ0VHlwZSl9Q2hhcnQpYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBbYCR7Y2hhcnRUeXBlfUNoYXJ0UHJvcHNgXTogcmVhY3RpdmVQcm9wcyxcbiAgICAgIFtDSEFSVF9SRUZfTkFNRV06IF9zdHJ1Y3RbQ0hBUlRfUkVGX05BTUVdLFxuICAgICAgdXBkYXRlXG4gICAgfTtcbiAgfTtcbn07XG5cbi8vIHNyYy9leHBvcnRzL2NvbXBvbmVudC5leHBvcnRzLnRzXG52YXIgQmFyQ2hhcnQgPSBkZWZpbmVDaGFydENvbXBvbmVudChcImJhci1jaGFydFwiLCBcImJhclwiKTtcbnZhciBEb3VnaG51dENoYXJ0ID0gZGVmaW5lQ2hhcnRDb21wb25lbnQoXCJkb3VnaG51dC1jaGFydFwiLCBcImRvdWdobnV0XCIpO1xudmFyIExpbmVDaGFydCA9IGRlZmluZUNoYXJ0Q29tcG9uZW50KFwibGluZS1jaGFydFwiLCBcImxpbmVcIik7XG52YXIgUGllQ2hhcnQgPSBkZWZpbmVDaGFydENvbXBvbmVudChcInBpZS1jaGFydFwiLCBcInBpZVwiKTtcbnZhciBQb2xhckFyZWFDaGFydCA9IGRlZmluZUNoYXJ0Q29tcG9uZW50KFwicG9sYXItY2hhcnRcIiwgXCJwb2xhckFyZWFcIik7XG52YXIgUmFkYXJDaGFydCA9IGRlZmluZUNoYXJ0Q29tcG9uZW50KFwicmFkYXItY2hhcnRcIiwgXCJyYWRhclwiKTtcbnZhciBCdWJibGVDaGFydCA9IGRlZmluZUNoYXJ0Q29tcG9uZW50KFwiYnViYmxlLWNoYXJ0XCIsIFwiYnViYmxlXCIpO1xudmFyIFNjYXR0ZXJDaGFydCA9IGRlZmluZUNoYXJ0Q29tcG9uZW50KFwic2NhdHRlci1jaGFydFwiLCBcInNjYXR0ZXJcIik7XG5cbi8vIHNyYy9leHBvcnRzL2hvb2tzLmV4cG9ydHMudHNcbnZhciB1c2VEb3VnaG51dENoYXJ0ID0gZGVmaW5lQ2hhcnRIb29rKFwiZG91Z2hudXRcIik7XG52YXIgdXNlQmFyQ2hhcnQgPSBkZWZpbmVDaGFydEhvb2soXCJiYXJcIik7XG52YXIgdXNlTGluZUNoYXJ0ID0gZGVmaW5lQ2hhcnRIb29rKFwibGluZVwiKTtcbnZhciB1c2VQaWVDaGFydCA9IGRlZmluZUNoYXJ0SG9vayhcInBpZVwiKTtcbnZhciB1c2VQb2xhckFyZWFDaGFydCA9IGRlZmluZUNoYXJ0SG9vayhcInBvbGFyQXJlYVwiKTtcbnZhciB1c2VSYWRhckNoYXJ0ID0gZGVmaW5lQ2hhcnRIb29rKFwicmFkYXJcIik7XG52YXIgdXNlQnViYmxlQ2hhcnQgPSBkZWZpbmVDaGFydEhvb2soXCJidWJibGVcIik7XG52YXIgdXNlU2NhdHRlckNoYXJ0ID0gZGVmaW5lQ2hhcnRIb29rKFwic2NhdHRlclwiKTtcbmV4cG9ydCB7XG4gIEJhckNoYXJ0LFxuICBCdWJibGVDaGFydCxcbiAgRG91Z2hudXRDaGFydCxcbiAgTGluZUNoYXJ0LFxuICBQaWVDaGFydCxcbiAgUG9sYXJBcmVhQ2hhcnQsXG4gIFJhZGFyQ2hhcnQsXG4gIFNjYXR0ZXJDaGFydCxcbiAgZGVmaW5lQ2hhcnRDb21wb25lbnQsXG4gIGRlZmluZUNoYXJ0SG9vayxcbiAgdXNlQmFyQ2hhcnQsXG4gIHVzZUJ1YmJsZUNoYXJ0LFxuICB1c2VEb3VnaG51dENoYXJ0LFxuICB1c2VMaW5lQ2hhcnQsXG4gIHVzZVBpZUNoYXJ0LFxuICB1c2VQb2xhckFyZWFDaGFydCxcbiAgdXNlUmFkYXJDaGFydCxcbiAgdXNlU2NhdHRlckNoYXJ0XG59O1xuIiwiPHRlbXBsYXRlPlxuICA8cS1wYWdlIGNsYXNzPVwicS1weC1sZ1wiPlxuICAgIDxkaXZcbiAgICAgIHYtaWY9XCJpc0xvYWRpbmdcIlxuICAgICAgY2xhc3M9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmdWxsLWhlaWdodCBmdWxsLXdpZHRoXCJcbiAgICAgIHN0eWxlPVwiaGVpZ2h0OiA1MHZoICFpbXBvcnRhbnRcIlxuICAgID5cbiAgICAgIDxxLXNwaW5uZXItaW9zIGNvbG9yPVwicHJpbWFyeVwiIHNpemU9XCIyZW1cIiAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IG5vbmVcIj57eyBnb2FsW2dvYWxUeXBlXSB9fTwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIndpZGdldCB3aWRnZXQtZ29hbFwiPlxuICAgICAgPFBpZUNoYXJ0IDpjaGFydERhdGE9XCJkYXRhXCIgOm9wdGlvbnM9XCJvcHRpb25zXCIgLz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IHYtaWY9XCJ0b3RhbEVsZWN0cmljXCIgY2xhc3M9XCJ3aWRnZXQgd2lkZ2V0LWVsZWNcIj5cbiAgICAgIDxoMj7imqEgRWxlY3RyaWM8L2gyPlxuICAgICAgPHAgY2xhc3M9XCJ0b3RhbFwiPlxuICAgICAgICB7eyB0b3RhbEVsZWN0cmljLnRvRml4ZWQodG9GaXhlZCkgfX0ve3sgZ29hbEVsZWN0cmljLnRvRml4ZWQodG9GaXhlZClcbiAgICAgICAgfX08c21hbGw+a1doPC9zbWFsbD5cbiAgICAgIDwvcD5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaGFydFwiPlxuICAgICAgICA8cCB2LWlmPVwibGFyZ2VzdEVsZWN0cmljXCIgY2xhc3M9XCJ0b3BcIj5cbiAgICAgICAgICB7eyBsYXJnZXN0RWxlY3RyaWMudG9GaXhlZCh0b0ZpeGVkKSB9fTxzbWFsbD5rV2g8L3NtYWxsPlxuICAgICAgICA8L3A+XG4gICAgICAgIDxwIHYtZWxzZSBjbGFzcz1cInRvcFwiPjAuMDA8c21hbGw+a1doPC9zbWFsbD48L3A+XG4gICAgICAgIDxCYXJDaGFydCA6Y2hhcnREYXRhPVwiY2hhcnRFbGVjdHJpY1wiIDpvcHRpb25zPVwib3B0aW9uc0VsZWN0cmljXCIgLz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImZvb3RlclwiPlxuICAgICAgICA8cD5Ub3RhbCB7eyB0b3RhbEVsZWN0cmljLnRvRml4ZWQodG9GaXhlZCkgfX08c21hbGw+a1doPC9zbWFsbD48L3A+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGl0ZW1zLWNlbnRlciBxLWd1dHRlci14LXNtXCI+XG4gICAgICAgICAgPHEtbGluZWFyLXByb2dyZXNzXG4gICAgICAgICAgICBzaXplPVwiOHB4XCJcbiAgICAgICAgICAgIHJvdW5kZWRcbiAgICAgICAgICAgIDp2YWx1ZT1cInByb2dyZXNzRWxlY3RyaWNcIlxuICAgICAgICAgICAgY29sb3I9XCJncmVlblwiXG4gICAgICAgICAgICB0cmFjay1jb2xvcj1cInJlZFwiXG4gICAgICAgICAgLz5cbiAgICAgICAgICA8cS1pY29uXG4gICAgICAgICAgICB2LWlmPVwicHJvZ3Jlc3NFbGVjdHJpYyA9PT0gMFwiXG4gICAgICAgICAgICBuYW1lPVwid2lmaV9vZmZcIlxuICAgICAgICAgICAgc2l6ZT1cIjE4cHhcIlxuICAgICAgICAgICAgY29sb3I9XCJyZWRcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHEtaWNvblxuICAgICAgICAgICAgdi1lbHNlLWlmPVwicHJvZ3Jlc3NFbGVjdHJpYyA+IDAgJiYgcHJvZ3Jlc3NFbGVjdHJpYyA8PSAwLjVcIlxuICAgICAgICAgICAgbmFtZT1cIndpZmlcIlxuICAgICAgICAgICAgc2l6ZT1cIjE4cHhcIlxuICAgICAgICAgICAgY29sb3I9XCJ5ZWxsb3dcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHEtaWNvbiB2LWVsc2UgbmFtZT1cIndpZmlcIiBzaXplPVwiMThweFwiIGNvbG9yPVwiZ3JlZW5cIiAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgdi1pZj1cInRvdGFsRWxlY3RyaWNcIiBjbGFzcz1cIndpZGdldCB3aWRnZXQtZ2FzXCI+XG4gICAgICA8aDI+8J+UpSBHYXM8L2gyPlxuICAgICAgPHAgY2xhc3M9XCJ0b3RhbFwiPlxuICAgICAgICB7eyB0b3RhbEdhcy50b0ZpeGVkKHRvRml4ZWQpIH19L3t7IGdvYWxHYXMudG9GaXhlZCh0b0ZpeGVkKVxuICAgICAgICB9fTxzbWFsbD5tPHN1cD4zPC9zdXA+PC9zbWFsbD5cbiAgICAgIDwvcD5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaGFydFwiPlxuICAgICAgICA8cCB2LWlmPVwibGFyZ2VzdEdhcyA+IDBcIiBjbGFzcz1cInRvcFwiPlxuICAgICAgICAgIHt7IGxhcmdlc3RHYXMudG9GaXhlZCh0b0ZpeGVkKSB9fTxzbWFsbD5tPHN1cD4zPC9zdXA+PC9zbWFsbD5cbiAgICAgICAgPC9wPlxuICAgICAgICA8cCB2LWVsc2UgY2xhc3M9XCJ0b3BcIj5cbiAgICAgICAgICAwLjAwPHNtYWxsPm08c3VwPjM8L3N1cD48L3NtYWxsPlxuICAgICAgICA8L3A+XG4gICAgICAgIDxCYXJDaGFydCA6Y2hhcnREYXRhPVwiY2hhcnRHYXNcIiA6b3B0aW9ucz1cIm9wdGlvbnNHYXNcIiAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiZm9vdGVyXCI+XG4gICAgICAgIDxwPlxuICAgICAgICAgIFRvdGFsIHt7IHRvdGFsR2FzLnRvRml4ZWQodG9GaXhlZCkgfX08c21hbGw+bTxzdXA+Mzwvc3VwPjwvc21hbGw+XG4gICAgICAgIDwvcD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZsZXggaXRlbXMtY2VudGVyIHEtZ3V0dGVyLXgtc21cIj5cbiAgICAgICAgICA8cS1saW5lYXItcHJvZ3Jlc3NcbiAgICAgICAgICAgIHNpemU9XCI4cHhcIlxuICAgICAgICAgICAgcm91bmRlZFxuICAgICAgICAgICAgOnZhbHVlPVwicHJvZ3Jlc3NHYXNcIlxuICAgICAgICAgICAgY29sb3I9XCJncmVlblwiXG4gICAgICAgICAgICB0cmFjay1jb2xvcj1cInJlZFwiXG4gICAgICAgICAgLz5cbiAgICAgICAgICA8cS1pY29uXG4gICAgICAgICAgICB2LWlmPVwicHJvZ3Jlc3NHYXMgPT09IDBcIlxuICAgICAgICAgICAgbmFtZT1cIndpZmlfb2ZmXCJcbiAgICAgICAgICAgIHNpemU9XCIxOHB4XCJcbiAgICAgICAgICAgIGNvbG9yPVwicmVkXCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxxLWljb25cbiAgICAgICAgICAgIHYtZWxzZS1pZj1cInByb2dyZXNzR2FzID4gMCAmJiBwcm9ncmVzc0dhcyA8PSAwLjVcIlxuICAgICAgICAgICAgbmFtZT1cIndpZmlcIlxuICAgICAgICAgICAgc2l6ZT1cIjE4cHhcIlxuICAgICAgICAgICAgY29sb3I9XCJ5ZWxsb3dcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHEtaWNvbiB2LWVsc2UgbmFtZT1cIndpZmlcIiBzaXplPVwiMThweFwiIGNvbG9yPVwiZ3JlZW5cIiAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L3EtcGFnZT5cbjwvdGVtcGxhdGU+XG5cbjwhLS0gaHR0cHM6Ly93d3cub2ZnZW0uZ292LnVrL2F2ZXJhZ2UtZ2FzLWFuZC1lbGVjdHJpY2l0eS11c2FnZSM6fjp0ZXh0PVdlJTIwZXN0aW1hdGUlMjB0aGUlMjB0eXBpY2FsJTIwaG91c2Vob2xkLG9uJTIwZW5lcmd5JTIwcHJpY2VzJTJDJTIwbGlrZSUyMHRoZVxuXG5FbmVyZ3kgVXNlXG5cbkV4YW1wbGUg4oCTIGhvbWUgdHlwZSBhbmQgbnVtYmVyIG9mIHJlc2lkZW50c1xuXG5UeXBpY2FsIGFubnVhbCBnYXMgdXNlIChrV2gpXG5cblR5cGljYWwgYW5udWFsIGVsZWN0cmljaXR5IHVzZSAoa1doKVxuXG5UeXBpY2FsIGFubnVhbCBlbGVjdHJpY2l0eSB1c2UgKG11bHRpLXJhdGUsIHN1Y2ggYXMgRWNvbm9teSA3KSAoa1doKVxuXG5Mb3dcblxuRmxhdCBvciAxLWJlZHJvb20gaG91c2U7IDEgdG8gMiBwZW9wbGVcblxuNyw1MDBcblxuMSw4MDBcblxuMiwyMDBcbk1lZGl1bVxuXG4yLTMgYmVkcm9vbSBob3VzZTsgMiB0byAzIHBlb3BsZVxuXG4xMSw1MDBcblxuMiw3MDBcblxuMyw5MDBcbkhpZ2hcblxuNCsgYmVkcm9vbSBob21lOyA0IHRvIDUgcGVvcGxlXG5cbjE3LDAwMFxuXG40LDEwMFxuXG42LDcwMCAtLT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IGRlZmluZUNvbXBvbmVudCwgcmVmLCBjb21wdXRlZCwgd2F0Y2hFZmZlY3QgfSBmcm9tICd2dWUnO1xuaW1wb3J0IHsgQmFyQ2hhcnQsIFBpZUNoYXJ0IH0gZnJvbSAndnVlLWNoYXJ0LTMnO1xuaW1wb3J0IHsgQ2hhcnQsIHJlZ2lzdGVyYWJsZXMgfSBmcm9tICdjaGFydC5qcyc7XG5cbkNoYXJ0LnJlZ2lzdGVyKC4uLnJlZ2lzdGVyYWJsZXMpO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVDb21wb25lbnQoe1xuICBuYW1lOiAnSW5kZXhQYWdlJyxcbiAgY29tcG9uZW50czogeyBCYXJDaGFydCwgUGllQ2hhcnQgfSxcbiAgcHJvcHM6IHtcbiAgICBhY2NvdW50czoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogKCkgPT4gKHt9KSxcbiAgICB9LFxuICAgIGNoYXJ0RWxlY3RyaWM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6ICgpID0+ICh7fSksXG4gICAgfSxcbiAgICBjaGFydEdhczoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogKCkgPT4gKHt9KSxcbiAgICB9LFxuICAgIG1ldGVyRWxlY3RyaWM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogKCkgPT4gW10sXG4gICAgfSxcbiAgICBtZXRlckdhczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiAoKSA9PiBbXSxcbiAgICB9LFxuICAgIHJvdW5kOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgICBpc0xvYWRpbmc6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB9LFxuICAgIGdvYWxUeXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnbWVkaXVtJyxcbiAgICB9LFxuICAgIGdvYWw6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6ICgpID0+ICh7fSksXG4gICAgfSxcbiAgfSxcbiAgc2V0dXAocHJvcHMpIHtcbiAgICBjb25zdCB0b0ZpeGVkID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgaWYgKHByb3BzLnJvdW5kKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBkYXRhID0gcmVmKG51bGwpO1xuXG4gICAgY29uc3QgcHJvZ3Jlc3NFbGVjdHJpYyA9IHJlZigwKTtcbiAgICBjb25zdCBwcm9ncmVzc0dhcyA9IHJlZigwKTtcblxuICAgIGNvbnN0IG9wdGlvbnNFbGVjdHJpYyA9IHJlZih7XG4gICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgcGx1Z2luczoge1xuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdG9vbHRpcDoge1xuICAgICAgICAvLyAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAvLyB9LFxuICAgICAgfSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGJhcjoge1xuICAgICAgICAgIGJvcmRlclJhZGl1czogMTAsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHk6IHtcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsIC8vIFRoaXMgbGluZSBoaWRlcyB0aGUgeS1heGlzIGxhYmVsc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgeDoge1xuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBhdXRvU2tpcDogdHJ1ZSwgLy8gVGhpcyBsaW5lIHdpbGwgYXV0b21hdGljYWxseSBza2lwIGxhYmVscyB0byBwcmV2ZW50IG92ZXJsYXBcbiAgICAgICAgICAgIG1heFJvdGF0aW9uOiAwLCAvLyBUaGlzIGxpbmUgcHJldmVudHMgdGhlIGxhYmVscyBmcm9tIHJvdGF0aW5nXG4gICAgICAgICAgICBtaW5Sb3RhdGlvbjogMCwgLy8gVGhpcyBsaW5lIHByZXZlbnRzIHRoZSBsYWJlbHMgZnJvbSByb3RhdGluZ1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG9wdGlvbnNHYXMgPSByZWYoe1xuICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHRvb2x0aXA6IHtcbiAgICAgICAgLy8gICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgLy8gfSxcbiAgICAgIH0sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBiYXI6IHtcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IDEwLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB5OiB7XG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLCAvLyBUaGlzIGxpbmUgaGlkZXMgdGhlIHktYXhpcyBsYWJlbHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHg6IHtcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgYXV0b1NraXA6IHRydWUsIC8vIFRoaXMgbGluZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2tpcCBsYWJlbHMgdG8gcHJldmVudCBvdmVybGFwXG4gICAgICAgICAgICBtYXhSb3RhdGlvbjogMCwgLy8gVGhpcyBsaW5lIHByZXZlbnRzIHRoZSBsYWJlbHMgZnJvbSByb3RhdGluZ1xuICAgICAgICAgICAgbWluUm90YXRpb246IDAsIC8vIFRoaXMgbGluZSBwcmV2ZW50cyB0aGUgbGFiZWxzIGZyb20gcm90YXRpbmdcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHRvdGFsRWxlY3RyaWMgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgICByZXR1cm4gcHJvcHMubWV0ZXJFbGVjdHJpYy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICByZXR1cm4gYWNjICsgY3Vyci5jb25zdW1wdGlvbjtcbiAgICAgIH0sIDApO1xuICAgIH0pO1xuXG4gICAgY29uc3QgbGFyZ2VzdEVsZWN0cmljID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KC4uLnByb3BzLm1ldGVyRWxlY3RyaWMubWFwKChpdGVtKSA9PiBpdGVtLmNvbnN1bXB0aW9uKSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0b3RhbEdhcyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICAgIHJldHVybiBwcm9wcy5tZXRlckdhcy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICByZXR1cm4gYWNjICsgY3Vyci5jb25zdW1wdGlvbjtcbiAgICAgIH0sIDApO1xuICAgIH0pO1xuXG4gICAgY29uc3QgbGFyZ2VzdEdhcyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICAgIHJldHVybiBNYXRoLm1heCguLi5wcm9wcy5tZXRlckdhcy5tYXAoKGl0ZW0pID0+IGl0ZW0uY29uc3VtcHRpb24pKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdvYWxFbGVjdHJpYyA9IHJlZihudWxsKTtcbiAgICBjb25zdCBnb2FsR2FzID0gcmVmKG51bGwpO1xuXG4gICAgY29uc3QgcGVyY2VudFRvdGFsRWxlY3RyaWMgPSByZWYobnVsbCk7XG4gICAgY29uc3QgcGVyY2VudEdvYWxFbGVjdHJpYyA9IHJlZihudWxsKTtcblxuICAgIGNvbnN0IHBlcmNlbnRUb3RhbEdhcyA9IHJlZihudWxsKTtcbiAgICBjb25zdCBwZXJjZW50R29hbEdhcyA9IHJlZihudWxsKTtcblxuICAgIHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICAgIGdvYWxFbGVjdHJpYy52YWx1ZSA9IHByb3BzLmdvYWxbcHJvcHMuZ29hbFR5cGVdLmVsZWN0cmljIC8gMzY1O1xuICAgICAgZ29hbEdhcy52YWx1ZSA9IHByb3BzLmdvYWxbcHJvcHMuZ29hbFR5cGVdLmdhcyAvIDM2NTtcblxuICAgICAgcHJvZ3Jlc3NFbGVjdHJpYy52YWx1ZSA9IHByb3BzLm1ldGVyRWxlY3RyaWMubGVuZ3RoIC8gMjQ7XG4gICAgICBwcm9ncmVzc0dhcy52YWx1ZSA9IHByb3BzLm1ldGVyR2FzLmxlbmd0aCAvIDI0O1xuXG4gICAgICBwZXJjZW50VG90YWxFbGVjdHJpYy52YWx1ZSA9XG4gICAgICAgICh0b3RhbEVsZWN0cmljLnZhbHVlIC8gZ29hbEVsZWN0cmljLnZhbHVlKSAqIDEwMDtcbiAgICAgIHBlcmNlbnRHb2FsRWxlY3RyaWMudmFsdWUgPVxuICAgICAgICB0b3RhbEVsZWN0cmljLnZhbHVlID4gZ29hbEVsZWN0cmljLnZhbHVlXG4gICAgICAgICAgPyAwXG4gICAgICAgICAgOiAxMDAgLSBwZXJjZW50VG90YWxFbGVjdHJpYy52YWx1ZTtcblxuICAgICAgcGVyY2VudFRvdGFsR2FzLnZhbHVlID0gKHRvdGFsR2FzLnZhbHVlIC8gZ29hbEdhcy52YWx1ZSkgKiAxMDA7XG4gICAgICBwZXJjZW50R29hbEdhcy52YWx1ZSA9XG4gICAgICAgIHRvdGFsR2FzLnZhbHVlID4gZ29hbEdhcy52YWx1ZSA/IDAgOiAxMDAgLSBwZXJjZW50VG90YWxHYXMudmFsdWU7XG5cbiAgICAgIGRhdGEudmFsdWUgPSB7XG4gICAgICAgIGxhYmVsczogWydFbGVjdHJpYycsICdHYXMnXSxcbiAgICAgICAgZGF0YXNldHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXRhOiBbcGVyY2VudFRvdGFsRWxlY3RyaWMsIHBlcmNlbnRHb2FsRWxlY3RyaWNdLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbJyNGQ0U5NEYnLCAnIzBFMDEyRSddLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDMsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6XG4gICAgICAgICAgICAgIHRvdGFsRWxlY3RyaWMudmFsdWUgPiBnb2FsRWxlY3RyaWMudmFsdWUgPyAwIDogTnVtYmVyLk1BWF9WQUxVRSwgLy8gQ2hhbmdlIGJvcmRlciByYWRpdXMgYmFzZWQgb24gdG90YWxFbGVjdHJpYyBhbmQgZ29hbEVsZWN0cmljXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMwRTAxMkUnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0YTogW3BlcmNlbnRUb3RhbEdhcywgcGVyY2VudEdvYWxHYXNdLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbJyM3MjlGQ0YnLCAnIzBFMDEyRSddLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDMsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHRvdGFsR2FzLnZhbHVlID4gZ29hbEdhcy52YWx1ZSA/IDAgOiBOdW1iZXIuTUFYX1ZBTFVFLCAvLyBDaGFuZ2UgYm9yZGVyIHJhZGl1cyBiYXNlZCBvbiB0b3RhbEdhcyBhbmQgZ29hbEdhc1xuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjMEUwMTJFJyxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgY3V0b3V0OiAnMzAlJyxcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG9wdGlvbnNFbGVjdHJpYyxcbiAgICAgIG9wdGlvbnNHYXMsXG4gICAgICB0b3RhbEVsZWN0cmljLFxuICAgICAgdG90YWxHYXMsXG4gICAgICBsYXJnZXN0RWxlY3RyaWMsXG4gICAgICBsYXJnZXN0R2FzLFxuICAgICAgdG9GaXhlZCxcbiAgICAgIGdvYWxFbGVjdHJpYyxcbiAgICAgIGdvYWxHYXMsXG4gICAgICBwZXJjZW50VG90YWxFbGVjdHJpYyxcbiAgICAgIHBlcmNlbnRHb2FsRWxlY3RyaWMsXG4gICAgICBwZXJjZW50VG90YWxHYXMsXG4gICAgICBwZXJjZW50R29hbEdhcyxcbiAgICAgIHByb2dyZXNzRWxlY3RyaWMsXG4gICAgICBwcm9ncmVzc0dhcyxcbiAgICB9O1xuICB9LFxufSk7XG48L3NjcmlwdD5cbiJdLCJuYW1lcyI6WyJoIiwiZXEiLCJtYXAiLCJrZXlzIiwiaW50ZXJwb2xhdGUiLCJjbG9uZSIsImNvbG9yIiwiaXNBcnJheSIsImlzT2JqZWN0IiwiaXNGdW5jdGlvbiIsImluZGV4Iiwic2V0IiwiY2FsbGJhY2siLCJkZWZhdWx0cyIsInJvb3QiLCJfZGVzY3JpcHRvcnMiLCJ3aWR0aCIsInJlc29sdmUiLCJkZXNjcmlwdG9ycyIsImdldFZhbHVlIiwiZHJhdyIsImZyb20iLCJ0byIsInNjYWxlcyIsImVsZW1lbnRzIiwibmFtZXMiLCJpIiwiaW5SYW5nZSIsImxheW91dHMiLCJwb3NpdGlvbnMiLCJ2YWxpZEluZGV4IiwicmVnaXN0cnkiLCJwbHVnaW5zIiwibGlzdGVuZXIiLCJhbHBoYSIsInNraXAiLCJmaWxsIiwicm91bmQiLCJmcmVlR2xvYmFsIiwiU3ltYm9sIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwidWlkIiwiY29yZUpzRGF0YSIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsIldlYWtNYXAiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZGVmaW5lUHJvcGVydHkiLCJhcmdzVGFnIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJmcmVlRXhwb3J0cyIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwib2JqZWN0VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJub2RlVXRpbCIsImlzQXJndW1lbnRzIiwiaXNCdWZmZXIiLCJpc1R5cGVkQXJyYXkiLCJuYXRpdmVLZXlzIiwibmF0aXZlQ3JlYXRlIiwiSEFTSF9VTkRFRklORUQiLCJNYXAiLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0U3ltYm9scyIsImdldFByb3RvdHlwZSIsImdldFN5bWJvbHNJbiIsIlByb21pc2UiLCJTZXQiLCJEYXRhVmlldyIsIlVpbnQ4QXJyYXkiLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJzeW1ib2xUYWciLCJiYXNlQ3JlYXRlIiwiZ2V0VGFnIiwiQ0xPTkVfREVFUF9GTEFHIiwiQ0xPTkVfU1lNQk9MU19GTEFHIiwiaXNTZXQiLCJpc01hcCIsImtleSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsIm90aFZhbHVlIiwiX19kZWZQcm9wIiwiX19kZWZOb3JtYWxQcm9wIiwiQ2hhcnRqcy5DaGFydCIsIl9jcmVhdGVFbGVtZW50Vk5vZGUiLCJfY3JlYXRlQmxvY2siLCJfb3BlbkJsb2NrIiwiX2NyZWF0ZUVsZW1lbnRCbG9jayIsIl9jcmVhdGVWTm9kZSIsIl90b0Rpc3BsYXlTdHJpbmciLCJfY3JlYXRlVGV4dFZOb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFNQSxNQUFNLE1BQU07QUFBQSxFQUNWLEVBQUUsS0FBSztBQUFBLElBQ0wsZ0JBQWdCO0FBQUEsSUFDaEIsa0JBQWtCO0FBQUEsRUFDdEIsR0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLElBQ0QsRUFBRSxRQUFRO0FBQUEsTUFDUixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixXQUFXO0FBQUEsSUFDakIsR0FBTztBQUFBLE1BQ0QsRUFBRSxXQUFXO0FBQUEsUUFDWCxlQUFlO0FBQUEsUUFDZixLQUFLO0FBQUEsUUFDTCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDckIsQ0FBTztBQUFBLElBQ1AsQ0FBSztBQUFBLEVBQ0wsQ0FBRztBQUNIO0FBRUEsSUFBQSxjQUFlLGdCQUFnQjtBQUFBLEVBQzdCLE1BQU07QUFBQSxFQUVOLE9BQU87QUFBQSxFQUVQLE1BQU8sT0FBTztBQUNaLFVBQU0sRUFBRSxPQUFPLFlBQVksV0FBVyxLQUFLO0FBRTNDLFdBQU8sTUFBTSxFQUFFLE9BQU87QUFBQSxNQUNwQixPQUFPLFFBQVE7QUFBQSxNQUNmLE9BQU8sTUFBTTtBQUFBLE1BQ2IsUUFBUSxNQUFNO0FBQUEsTUFDZCxRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixTQUFTO0FBQUEsSUFDVixHQUFFLEdBQUc7QUFBQSxFQUNQO0FBQ0gsQ0FBQztBQ3ZLRCxNQUFNLGVBQWU7QUFBQSxFQUNuQixJQUFJO0FBQUEsRUFDSixJQUFJO0FBQUEsRUFDSixJQUFJO0FBQUEsRUFDSixJQUFJO0FBQUEsRUFDSixJQUFJO0FBQ047QUFFQSxTQUFTLE1BQU8sS0FBSyxTQUFTLElBQUk7QUFDaEMsU0FBTztBQUFBLElBQ0wsV0FBVyxZQUFZLE9BQ25CLGNBQWUsR0FBRyxLQUFLLFFBQVEsT0FBTyxNQUFNLG1CQUFxQixDQUFDLGFBQ2xFLFdBQVk7QUFBQSxFQUNqQjtBQUNIO0FBRUEsSUFBQSxrQkFBZSxnQkFBZ0I7QUFBQSxFQUM3QixNQUFNO0FBQUEsRUFFTixPQUFPO0FBQUEsSUFDTCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFFSCxPQUFPO0FBQUEsTUFDTCxNQUFNO0FBQUEsTUFDTixTQUFTO0FBQUEsSUFDVjtBQUFBLElBQ0QsUUFBUTtBQUFBLElBRVIsT0FBTztBQUFBLElBQ1AsWUFBWTtBQUFBLElBRVosU0FBUztBQUFBLElBQ1QsUUFBUTtBQUFBLElBQ1IsZUFBZTtBQUFBLElBQ2YsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBRVQsZ0JBQWdCO0FBQUEsTUFDZCxNQUFNLENBQUUsUUFBUSxNQUFRO0FBQUEsTUFDeEIsU0FBUztBQUFBLElBQ1Y7QUFBQSxJQUVELGlCQUFpQjtBQUFBLEVBQ2xCO0FBQUEsRUFFRCxNQUFPLE9BQU8sRUFBRSxTQUFTO0FBQ3ZCLFVBQU0sRUFBRSxNQUFPLElBQUcsbUJBQW9CO0FBQ3RDLFVBQU0sU0FBUyxRQUFRLE9BQU8sTUFBTSxFQUFFO0FBQ3RDLFVBQU0sWUFBWSxRQUFRLE9BQU8sWUFBWTtBQUU3QyxVQUFNLFNBQVMsU0FBUyxNQUFNLE1BQU0sa0JBQWtCLFFBQVEsTUFBTSxVQUFVLElBQUk7QUFDbEYsVUFBTSxlQUFlLFNBQVMsTUFBTSxNQUFNLFlBQVksTUFBTSxLQUFLO0FBQ2pFLFVBQU0sUUFBUSxTQUFTLE9BQU87QUFBQSxNQUM1QixHQUFJLFVBQVUsVUFBVSxPQUFPLFVBQVUsUUFBUSxDQUFBO0FBQUEsTUFDakQsNkJBQTZCLEdBQUksTUFBTTtBQUFBLElBQzdDLEVBQU07QUFFRixVQUFNLFVBQVU7QUFBQSxNQUFTLE1BQ3ZCLHVCQUNHLE1BQU0sVUFBVSxTQUFTLFNBQVUsTUFBTSxVQUFXLE9BQ3BELE1BQU0sWUFBWSxRQUFRLE1BQU0sVUFBVSxPQUFPLGdDQUFnQyxPQUNqRixNQUFNLFlBQVksT0FBTyxxQkFBcUI7QUFBQSxJQUNsRDtBQUVELFVBQU0sYUFBYSxTQUFTLE1BQU0sTUFBTSxNQUFNLFdBQVcsU0FBUyxNQUFNLFNBQVMsR0FBRyxhQUFhLE9BQU8sTUFBTSxFQUFFLENBQUM7QUFDakgsVUFBTSxtQkFBbUIsU0FBUyxNQUFNLE9BQVEsTUFBTSxvQkFBb0IsT0FBTyxRQUFRLGVBQWdCO0FBRXpHLFVBQU0sYUFBYTtBQUFBLE1BQVMsTUFDMUIsb0VBQ2lDLGlCQUFpQixtQ0FDakIsT0FBTyxVQUFVLE9BQU8sU0FBUyxhQUMvRCxNQUFNLGVBQWUsU0FBUyxPQUFRLE1BQU0sZUFBZ0I7QUFBQSxJQUNoRTtBQUVELFVBQU0sYUFBYSxTQUFTLE1BQU0sTUFBTSxPQUFPLFVBQVUsT0FBTyxJQUFJLE1BQU0sT0FBTyxhQUFhLE9BQU8sTUFBTSxFQUFFLENBQUM7QUFDOUcsVUFBTSxhQUFhO0FBQUEsTUFBUyxNQUMxQixvRUFDaUMsaUJBQWlCLG1DQUNqQixPQUFPLFVBQVUsT0FBTyxPQUFPO0FBQUEsSUFDakU7QUFFRCxVQUFNLGNBQWMsU0FBUyxPQUFPLEVBQUUsT0FBTyxHQUFJLE1BQU0sUUFBUSxPQUFTLEVBQUM7QUFDekUsVUFBTSxjQUFjO0FBQUEsTUFBUyxNQUMzQixzQ0FBdUMsTUFBTSxZQUFZLE9BQU8sVUFBVSxxQ0FDeEMsaUJBQWlCO0FBQUEsSUFDcEQ7QUFFRCxXQUFPLE1BQU07QUFDWCxZQUFNLFFBQVE7QUFBQSxRQUNaLEVBQUUsT0FBTztBQUFBLFVBQ1AsT0FBTyxXQUFXO0FBQUEsVUFDbEIsT0FBTyxXQUFXO0FBQUEsUUFDNUIsQ0FBUztBQUFBLFFBRUQsRUFBRSxPQUFPO0FBQUEsVUFDUCxPQUFPLFdBQVc7QUFBQSxVQUNsQixPQUFPLFdBQVc7QUFBQSxRQUM1QixDQUFTO0FBQUEsTUFDRjtBQUVELFlBQU0sV0FBVyxRQUFRLE9BQU8sVUFBVSxTQUFTLE1BQU07QUFBQSxRQUN2RCxFQUFFLE9BQU87QUFBQSxVQUNQLE9BQU8sWUFBWTtBQUFBLFVBQ25CLE9BQU8sWUFBWTtBQUFBLFFBQzdCLENBQVM7QUFBQSxNQUNGO0FBRUQsYUFBTyxFQUFFLE9BQU87QUFBQSxRQUNkLE9BQU8sUUFBUTtBQUFBLFFBQ2YsT0FBTyxNQUFNO0FBQUEsUUFDYixNQUFNO0FBQUEsUUFDTixpQkFBaUI7QUFBQSxRQUNqQixpQkFBaUI7QUFBQSxRQUNqQixpQkFBaUIsTUFBTSxrQkFBa0IsT0FDckMsU0FDQSxNQUFNO0FBQUEsTUFDWCxHQUFFLFdBQVcsTUFBTSxTQUFTLEtBQUssQ0FBQztBQUFBLElBQ3BDO0FBQUEsRUFDRjtBQUNILENBQUM7QUMxSEQsSUFBQSxRQUFlLGdCQUFnQjtBQUFBLEVBQzdCLE1BQU07QUFBQSxFQUVOLE9BQU87QUFBQSxJQUNMLFNBQVM7QUFBQSxJQUNULFNBQVM7QUFBQSxFQUNWO0FBQUEsRUFFRCxNQUFPLE9BQU8sRUFBRSxTQUFTO0FBQ3ZCLFVBQU0sRUFBRSxPQUFPLEVBQUUsR0FBSSxFQUFBLElBQUssbUJBQW9CO0FBRTlDLFVBQU0sVUFBVSxPQUFPLFdBQVcsYUFBYTtBQUMvQyxRQUFJLFlBQVksZUFBZTtBQUM3QixjQUFRLE1BQU0sMkNBQTJDO0FBQ3pELGFBQU87QUFBQSxJQUNSO0FBRUQsVUFBTSxpQkFBaUIsT0FBTyxrQkFBa0IsYUFBYTtBQUM3RCxRQUFJLG1CQUFtQixlQUFlO0FBQ3BDLGNBQVEsTUFBTSwyQ0FBMkM7QUFDekQsYUFBTztBQUFBLElBQ1I7QUFFRCxVQUFNLFFBQVEsU0FBUyxNQUFNO0FBQzNCLFlBQU0sVUFDRCxRQUFRLE9BQU8sVUFBVSxPQUFPLFFBQVEsT0FBTyxPQUFPLE1BQ3RELFFBQVEsT0FBTyxVQUFVLE9BQU8sUUFBUSxPQUFPLE9BQU87QUFFM0QsVUFBSSxPQUFPLE1BQU0sWUFBWSxZQUFZO0FBQ3ZDLGNBQU0sU0FBUyxRQUFRLFlBQVksVUFBVSxPQUN6QyxRQUFRLGdCQUFnQixRQUN4QixHQUFHLE9BQU87QUFFZCxlQUFPLE1BQU0sUUFBUSxRQUFRLE1BQU07QUFBQSxNQUNwQztBQUVELGFBQU87QUFBQSxRQUNMLFdBQVcsUUFBUSxZQUFZLFVBQVUsT0FDcEMsUUFBUSxnQkFBZ0IsUUFBUSxTQUFVLE9BRXpDLEdBQUcsT0FBTyxXQUFXLElBQ2hCLFdBQVcsSUFBSSxnQkFBaUIsY0FBZSxVQUMvQyxHQUFHLE9BQU8sU0FBUyxTQUFVO0FBQUEsTUFFekM7QUFBQSxJQUNQLENBQUs7QUFFRCxVQUFNLFVBQVU7QUFBQSxNQUFTLE1BQ3ZCLFNBQVUsTUFBTSxZQUFZLE9BQU8sc0JBQXNCO0FBQUEsSUFDMUQ7QUFFRCxXQUFPLE1BQU0sRUFBRSxRQUFRO0FBQUEsTUFDckIsT0FBTyxRQUFRO0FBQUEsTUFDZixPQUFPLE1BQU07QUFBQSxJQUNuQixHQUFPLE1BQU0sTUFBTSxPQUFPLENBQUM7QUFBQSxFQUN4QjtBQUNILENBQUM7QUM5REQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUEsU0FBUyxNQUFNLEdBQUc7QUFDaEIsU0FBTyxJQUFJLE1BQU07QUFDbkI7QUFDQSxNQUFNLE1BQU0sQ0FBQyxHQUFHLEdBQUdBLE9BQU0sS0FBSyxJQUFJLEtBQUssSUFBSSxHQUFHQSxFQUFDLEdBQUcsQ0FBQztBQUNuRCxTQUFTLElBQUksR0FBRztBQUNkLFNBQU8sSUFBSSxNQUFNLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRztBQUNwQztBQUlBLFNBQVMsSUFBSSxHQUFHO0FBQ2QsU0FBTyxJQUFJLE1BQU0sSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ25DO0FBQ0EsU0FBUyxJQUFJLEdBQUc7QUFDZCxTQUFPLElBQUksTUFBTSxJQUFJLElBQUksSUFBSSxLQUFLLEdBQUcsQ0FBQztBQUN4QztBQUNBLFNBQVMsSUFBSSxHQUFHO0FBQ2QsU0FBTyxJQUFJLE1BQU0sSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ25DO0FBRUEsTUFBTSxRQUFRLEVBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxHQUFFO0FBQzdKLE1BQU0sTUFBTSxDQUFDLEdBQUcsa0JBQWtCO0FBQ2xDLE1BQU0sS0FBSyxPQUFLLElBQUksSUFBSTtBQUN4QixNQUFNLEtBQUssT0FBSyxLQUFLLElBQUksUUFBUyxLQUFLLElBQUksSUFBSTtBQUMvQyxNQUFNQyxPQUFLLFFBQU8sSUFBSSxRQUFTLE9BQVEsSUFBSTtBQUMzQyxNQUFNLFVBQVUsT0FBS0EsS0FBRyxFQUFFLENBQUMsS0FBS0EsS0FBRyxFQUFFLENBQUMsS0FBS0EsS0FBRyxFQUFFLENBQUMsS0FBS0EsS0FBRyxFQUFFLENBQUM7QUFDNUQsU0FBUyxTQUFTLEtBQUs7QUFDckIsTUFBSSxNQUFNLElBQUk7QUFDZCxNQUFJO0FBQ0osTUFBSSxJQUFJLE9BQU8sS0FBSztBQUNsQixRQUFJLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDMUIsWUFBTTtBQUFBLFFBQ0osR0FBRyxNQUFNLE1BQU0sSUFBSSxNQUFNO0FBQUEsUUFDekIsR0FBRyxNQUFNLE1BQU0sSUFBSSxNQUFNO0FBQUEsUUFDekIsR0FBRyxNQUFNLE1BQU0sSUFBSSxNQUFNO0FBQUEsUUFDekIsR0FBRyxRQUFRLElBQUksTUFBTSxJQUFJLE1BQU0sS0FBSztBQUFBLE1BQzVDO0FBQUEsSUFDSyxXQUFVLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDakMsWUFBTTtBQUFBLFFBQ0osR0FBRyxNQUFNLElBQUksT0FBTyxJQUFJLE1BQU0sSUFBSTtBQUFBLFFBQ2xDLEdBQUcsTUFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLElBQUk7QUFBQSxRQUNsQyxHQUFHLE1BQU0sSUFBSSxPQUFPLElBQUksTUFBTSxJQUFJO0FBQUEsUUFDbEMsR0FBRyxRQUFRLElBQUssTUFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLElBQUksTUFBTztBQUFBLE1BQzlEO0FBQUEsSUFDSztBQUFBLEVBQ0Y7QUFDRCxTQUFPO0FBQ1Q7QUFDQSxNQUFNLFFBQVEsQ0FBQyxHQUFHLE1BQU0sSUFBSSxNQUFNLEVBQUUsQ0FBQyxJQUFJO0FBQ3pDLFNBQVMsVUFBVSxHQUFHO0FBQ3BCLE1BQUksSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLO0FBQzFCLFNBQU8sSUFDSCxNQUFNLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsSUFDN0M7QUFDTjtBQUVBLE1BQU0sU0FBUztBQUNmLFNBQVMsU0FBU0QsSUFBRyxHQUFHLEdBQUc7QUFDekIsUUFBTSxJQUFJLElBQUksS0FBSyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQy9CLFFBQU0sSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJQSxLQUFJLE1BQU0sT0FBTyxJQUFJLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3RGLFNBQU8sQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUMxQjtBQUNBLFNBQVMsU0FBU0EsSUFBRyxHQUFHLEdBQUc7QUFDekIsUUFBTSxJQUFJLENBQUMsR0FBRyxLQUFLLElBQUlBLEtBQUksTUFBTSxNQUFNLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUM7QUFDcEYsU0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQzFCO0FBQ0EsU0FBUyxTQUFTQSxJQUFHLEdBQUcsR0FBRztBQUN6QixRQUFNLE1BQU0sU0FBU0EsSUFBRyxHQUFHLEdBQUc7QUFDOUIsTUFBSTtBQUNKLE1BQUksSUFBSSxJQUFJLEdBQUc7QUFDYixRQUFJLEtBQUssSUFBSTtBQUNiLFNBQUs7QUFDTCxTQUFLO0FBQUEsRUFDTjtBQUNELE9BQUssSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLO0FBQ3RCLFFBQUksTUFBTSxJQUFJLElBQUk7QUFDbEIsUUFBSSxNQUFNO0FBQUEsRUFDWDtBQUNELFNBQU87QUFDVDtBQUNBLFNBQVMsU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLEtBQUs7QUFDakMsTUFBSSxNQUFNLEtBQUs7QUFDYixZQUFTLElBQUksS0FBSyxLQUFNLElBQUksSUFBSSxJQUFJO0FBQUEsRUFDckM7QUFDRCxNQUFJLE1BQU0sS0FBSztBQUNiLFlBQVEsSUFBSSxLQUFLLElBQUk7QUFBQSxFQUN0QjtBQUNELFVBQVEsSUFBSSxLQUFLLElBQUk7QUFDdkI7QUFDQSxTQUFTLFFBQVEsR0FBRztBQUNsQixRQUFNLFFBQVE7QUFDZCxRQUFNLElBQUksRUFBRSxJQUFJO0FBQ2hCLFFBQU0sSUFBSSxFQUFFLElBQUk7QUFDaEIsUUFBTSxJQUFJLEVBQUUsSUFBSTtBQUNoQixRQUFNLE1BQU0sS0FBSyxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQzVCLFFBQU0sTUFBTSxLQUFLLElBQUksR0FBRyxHQUFHLENBQUM7QUFDNUIsUUFBTSxLQUFLLE1BQU0sT0FBTztBQUN4QixNQUFJQSxJQUFHLEdBQUc7QUFDVixNQUFJLFFBQVEsS0FBSztBQUNmLFFBQUksTUFBTTtBQUNWLFFBQUksSUFBSSxNQUFNLEtBQUssSUFBSSxNQUFNLE9BQU8sS0FBSyxNQUFNO0FBQy9DLElBQUFBLEtBQUksU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDNUIsSUFBQUEsS0FBSUEsS0FBSSxLQUFLO0FBQUEsRUFDZDtBQUNELFNBQU8sQ0FBQ0EsS0FBSSxHQUFHLEtBQUssR0FBRyxDQUFDO0FBQzFCO0FBQ0EsU0FBUyxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDekIsVUFDRSxNQUFNLFFBQVEsQ0FBQyxJQUNYLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsSUFDbEIsRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUNiLElBQUksR0FBRztBQUNYO0FBQ0EsU0FBUyxRQUFRQSxJQUFHLEdBQUcsR0FBRztBQUN4QixTQUFPLE1BQU0sVUFBVUEsSUFBRyxHQUFHLENBQUM7QUFDaEM7QUFDQSxTQUFTLFFBQVFBLElBQUcsR0FBRyxHQUFHO0FBQ3hCLFNBQU8sTUFBTSxVQUFVQSxJQUFHLEdBQUcsQ0FBQztBQUNoQztBQUNBLFNBQVMsUUFBUUEsSUFBRyxHQUFHLEdBQUc7QUFDeEIsU0FBTyxNQUFNLFVBQVVBLElBQUcsR0FBRyxDQUFDO0FBQ2hDO0FBQ0EsU0FBUyxJQUFJQSxJQUFHO0FBQ2QsVUFBUUEsS0FBSSxNQUFNLE9BQU87QUFDM0I7QUFDQSxTQUFTLFNBQVMsS0FBSztBQUNyQixRQUFNLElBQUksT0FBTyxLQUFLLEdBQUc7QUFDekIsTUFBSSxJQUFJO0FBQ1IsTUFBSTtBQUNKLE1BQUksQ0FBQyxHQUFHO0FBQ047QUFBQSxFQUNEO0FBQ0QsTUFBSSxFQUFFLE9BQU8sR0FBRztBQUNkLFFBQUksRUFBRSxLQUFLLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxFQUFFO0FBQUEsRUFDbEM7QUFDRCxRQUFNQSxLQUFJLElBQUksQ0FBQyxFQUFFLEVBQUU7QUFDbkIsUUFBTSxLQUFLLENBQUMsRUFBRSxLQUFLO0FBQ25CLFFBQU0sS0FBSyxDQUFDLEVBQUUsS0FBSztBQUNuQixNQUFJLEVBQUUsT0FBTyxPQUFPO0FBQ2xCLFFBQUksUUFBUUEsSUFBRyxJQUFJLEVBQUU7QUFBQSxFQUN0QixXQUFVLEVBQUUsT0FBTyxPQUFPO0FBQ3pCLFFBQUksUUFBUUEsSUFBRyxJQUFJLEVBQUU7QUFBQSxFQUN6QixPQUFTO0FBQ0wsUUFBSSxRQUFRQSxJQUFHLElBQUksRUFBRTtBQUFBLEVBQ3RCO0FBQ0QsU0FBTztBQUFBLElBQ0wsR0FBRyxFQUFFO0FBQUEsSUFDTCxHQUFHLEVBQUU7QUFBQSxJQUNMLEdBQUcsRUFBRTtBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQ0E7QUFDQSxTQUFTLE9BQU8sR0FBRyxLQUFLO0FBQ3RCLE1BQUlBLEtBQUksUUFBUSxDQUFDO0FBQ2pCLEVBQUFBLEdBQUUsS0FBSyxJQUFJQSxHQUFFLEtBQUssR0FBRztBQUNyQixFQUFBQSxLQUFJLFFBQVFBLEVBQUM7QUFDYixJQUFFLElBQUlBLEdBQUU7QUFDUixJQUFFLElBQUlBLEdBQUU7QUFDUixJQUFFLElBQUlBLEdBQUU7QUFDVjtBQUNBLFNBQVMsVUFBVSxHQUFHO0FBQ3BCLE1BQUksQ0FBQyxHQUFHO0FBQ047QUFBQSxFQUNEO0FBQ0QsUUFBTSxJQUFJLFFBQVEsQ0FBQztBQUNuQixRQUFNQSxLQUFJLEVBQUU7QUFDWixRQUFNLElBQUksSUFBSSxFQUFFLEVBQUU7QUFDbEIsUUFBTSxJQUFJLElBQUksRUFBRSxFQUFFO0FBQ2xCLFNBQU8sRUFBRSxJQUFJLE1BQ1QsUUFBUUEsT0FBTSxPQUFPLE9BQU8sSUFBSSxFQUFFLENBQUMsT0FDbkMsT0FBT0EsT0FBTSxPQUFPO0FBQzFCO0FBRUEsTUFBTUUsUUFBTTtBQUFBLEVBQ1YsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUNMO0FBQ0EsTUFBTSxVQUFVO0FBQUEsRUFDZCxRQUFRO0FBQUEsRUFDUixhQUFhO0FBQUEsRUFDYixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxjQUFjO0FBQUEsRUFDZCxJQUFJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxhQUFhO0FBQUEsRUFDYixTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxVQUFVO0FBQUEsRUFDVixZQUFZO0FBQUEsRUFDWixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEs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
